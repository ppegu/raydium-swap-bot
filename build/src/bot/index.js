var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};

// node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.3.1",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://github.com/motdotla/dotenv?sponsor=1",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@definitelytyped/dtslint": "^0.0.133",
      "@types/node": "^18.11.3",
      decache: "^4.6.1",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.5.0",
      tap: "^16.3.0",
      tar: "^6.1.11",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var parse = function(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, "\n");
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  };
  var _parseVault = function(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      throw new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  };
  var _log = function(message) {
    console.log(`[dotenv@${version}][INFO] ${message}`);
  };
  var _warn = function(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  };
  var _debug = function(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  };
  var _dotenvKey = function(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  };
  var _instructions = function(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        throw new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      throw new Error("INVALID_DOTENV_KEY: Missing key part");
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      throw new Error("INVALID_DOTENV_KEY: Missing environment part");
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    }
    return { ciphertext, key };
  };
  var _vaultPath = function(options) {
    let dotenvPath = path.resolve(process.cwd(), ".env");
    if (options && options.path && options.path.length > 0) {
      dotenvPath = options.path;
    }
    return dotenvPath.endsWith(".vault") ? dotenvPath : `${dotenvPath}.vault`;
  };
  var _resolveHome = function(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  };
  var _configVault = function(options) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  };
  var configDotenv = function(options) {
    let dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options) {
      if (options.path != null) {
        dotenvPath = _resolveHome(options.path);
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      }
    }
    try {
      const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }));
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    } catch (e) {
      if (debug) {
        _debug(`Failed to load ${dotenvPath} ${e.message}`);
      }
      return { error: e };
    }
  };
  var config = function(options) {
    const vaultPath = _vaultPath(options);
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    if (!fs.existsSync(vaultPath)) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  };
  var decrypt = function(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.slice(0, 12);
    const authTag = ciphertext.slice(-16);
    ciphertext = ciphertext.slice(12, -16);
    try {
      const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const msg = "INVALID_DOTENV_KEY: It must be 64 characters long (or more)";
        throw new Error(msg);
      } else if (decryptionFailed) {
        const msg = "DECRYPTION_FAILED: Please check your DOTENV_KEY";
        throw new Error(msg);
      } else {
        console.error("Error: ", error.code);
        console.error("Error: ", error.message);
        throw error;
      }
    }
  };
  var populate = function(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      throw new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  };
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var crypto2 = __require("crypto");
  var packageJson = require_package();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/@noble/hashes/_assert.js
var require__assert = __commonJS((exports) => {
  var number = function(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  };
  var bool = function(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  };
  var isBytes = function(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  };
  var bytes = function(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  };
  var hash = function(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  };
  var exists = function(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  };
  var output = function(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = undefined;
  exports.number = number;
  exports.bool = bool;
  exports.bytes = bytes;
  exports.hash = hash;
  exports.exists = exists;
  exports.output = output;
  var assert = { number, bool, bytes, hash, exists, output };
  exports.default = assert;
});

// node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crypto = undefined;
  var nc = __require("node:crypto");
  exports.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : undefined;
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS((exports) => {
  var isBytes = function(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  };
  var bytesToHex = function(bytes) {
    if (!isBytes(bytes))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0;i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  };
  var asciiToBase16 = function(char) {
    if (char >= asciis._0 && char <= asciis._9)
      return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
      return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
      return char - (asciis._a - 10);
    return;
  };
  var hexToBytes = function(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === undefined || n2 === undefined) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  };
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0;i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await (0, exports.nextTick)();
      ts += diff;
    }
  }
  var utf8ToBytes = function(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  };
  var toBytes = function(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!isBytes(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  };
  var concatBytes = function(...arrays) {
    let sum = 0;
    for (let i = 0;i < arrays.length; i++) {
      const a = arrays[i];
      if (!isBytes(a))
        throw new Error("Uint8Array expected");
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0;i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  };
  var checkOpts = function(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  };
  var wrapConstructor = function(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  };
  var wrapConstructorWithOpts = function(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  };
  var wrapXOFConstructorWithOpts = function(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  };
  var randomBytes = function(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
      return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  };
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = undefined;
  var crypto_1 = require_cryptoNode();
  var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.u8 = u8;
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  exports.u32 = u32;
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.createView = createView;
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  exports.rotr = rotr;
  exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!exports.isLE)
    throw new Error("Non little-endian hardware is not supported");
  var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  exports.bytesToHex = bytesToHex;
  var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  exports.hexToBytes = hexToBytes;
  var nextTick = async () => {
  };
  exports.nextTick = nextTick;
  exports.asyncLoop = asyncLoop;
  exports.utf8ToBytes = utf8ToBytes;
  exports.toBytes = toBytes;
  exports.concatBytes = concatBytes;

  class Hash {
    clone() {
      return this._cloneInto();
    }
  }
  exports.Hash = Hash;
  var toStr = {}.toString;
  exports.checkOpts = checkOpts;
  exports.wrapConstructor = wrapConstructor;
  exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
  exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
  exports.randomBytes = randomBytes;
});

// node_modules/@noble/hashes/_sha2.js
var require__sha2 = __commonJS((exports) => {
  var setBigUint64 = function(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SHA2 = undefined;
  var _assert_js_1 = require__assert();
  var utils_js_1 = require_utils();

  class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
      (0, _assert_js_1.exists)(this);
      const { view, buffer, blockLen } = this;
      data = (0, utils_js_1.toBytes)(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = (0, utils_js_1.createView)(data);
          for (;blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      (0, _assert_js_1.exists)(this);
      (0, _assert_js_1.output)(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos;i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      const oview = (0, utils_js_1.createView)(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0;i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  }
  exports.SHA2 = SHA2;
});

// node_modules/@noble/hashes/_u64.js
var require__u64 = __commonJS((exports) => {
  var fromBig = function(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  };
  var split = function(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0;i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  };
  var add = function(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = undefined;
  var U32_MASK64 = BigInt(2 ** 32 - 1);
  var _32n = BigInt(32);
  exports.fromBig = fromBig;
  exports.split = split;
  var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  exports.toBig = toBig;
  var shrSH = (h, _l, s) => h >>> s;
  exports.shrSH = shrSH;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.shrSL = shrSL;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  exports.rotrSH = rotrSH;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.rotrSL = rotrSL;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  exports.rotrBH = rotrBH;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  exports.rotrBL = rotrBL;
  var rotr32H = (_h, l) => l;
  exports.rotr32H = rotr32H;
  var rotr32L = (h, _l) => h;
  exports.rotr32L = rotr32L;
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  exports.rotlSH = rotlSH;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  exports.rotlSL = rotlSL;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  exports.rotlBH = rotlBH;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  exports.rotlBL = rotlBL;
  exports.add = add;
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  exports.add3L = add3L;
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  exports.add3H = add3H;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  exports.add4L = add4L;
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  exports.add4H = add4H;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  exports.add5L = add5L;
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  exports.add5H = add5H;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  exports.default = u64;
});

// node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = undefined;
  var _sha2_js_1 = require__sha2();
  var _u64_js_1 = require__u64();
  var utils_js_1 = require_utils();
  var [SHA512_Kh, SHA512_Kl] = (() => _u64_js_1.default.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  var SHA512_W_H = new Uint32Array(80);
  var SHA512_W_L = new Uint32Array(80);

  class SHA512 extends _sha2_js_1.SHA2 {
    constructor() {
      super(128, 64, 16, false);
      this.Ah = 1779033703 | 0;
      this.Al = 4089235720 | 0;
      this.Bh = 3144134277 | 0;
      this.Bl = 2227873595 | 0;
      this.Ch = 1013904242 | 0;
      this.Cl = 4271175723 | 0;
      this.Dh = 2773480762 | 0;
      this.Dl = 1595750129 | 0;
      this.Eh = 1359893119 | 0;
      this.El = 2917565137 | 0;
      this.Fh = 2600822924 | 0;
      this.Fl = 725511199 | 0;
      this.Gh = 528734635 | 0;
      this.Gl = 4215389547 | 0;
      this.Hh = 1541459225 | 0;
      this.Hl = 327033209 | 0;
    }
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16;i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
        const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
        const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
        const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0;i < 80; i++) {
        const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
        const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
        const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
        Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      SHA512_W_H.fill(0);
      SHA512_W_L.fill(0);
    }
    destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  exports.SHA512 = SHA512;

  class SHA512_224 extends SHA512 {
    constructor() {
      super();
      this.Ah = 2352822216 | 0;
      this.Al = 424955298 | 0;
      this.Bh = 1944164710 | 0;
      this.Bl = 2312950998 | 0;
      this.Ch = 502970286 | 0;
      this.Cl = 855612546 | 0;
      this.Dh = 1738396948 | 0;
      this.Dl = 1479516111 | 0;
      this.Eh = 258812777 | 0;
      this.El = 2077511080 | 0;
      this.Fh = 2011393907 | 0;
      this.Fl = 79989058 | 0;
      this.Gh = 1067287976 | 0;
      this.Gl = 1780299464 | 0;
      this.Hh = 286451373 | 0;
      this.Hl = 2446758561 | 0;
      this.outputLen = 28;
    }
  }

  class SHA512_256 extends SHA512 {
    constructor() {
      super();
      this.Ah = 573645204 | 0;
      this.Al = 4230739756 | 0;
      this.Bh = 2673172387 | 0;
      this.Bl = 3360449730 | 0;
      this.Ch = 596883563 | 0;
      this.Cl = 1867755857 | 0;
      this.Dh = 2520282905 | 0;
      this.Dl = 1497426621 | 0;
      this.Eh = 2519219938 | 0;
      this.El = 2827943907 | 0;
      this.Fh = 3193839141 | 0;
      this.Fl = 1401305490 | 0;
      this.Gh = 721525244 | 0;
      this.Gl = 746961066 | 0;
      this.Hh = 246885852 | 0;
      this.Hl = 2177182882 | 0;
      this.outputLen = 32;
    }
  }

  class SHA384 extends SHA512 {
    constructor() {
      super();
      this.Ah = 3418070365 | 0;
      this.Al = 3238371032 | 0;
      this.Bh = 1654270250 | 0;
      this.Bl = 914150663 | 0;
      this.Ch = 2438529370 | 0;
      this.Cl = 812702999 | 0;
      this.Dh = 355462360 | 0;
      this.Dl = 4144912697 | 0;
      this.Eh = 1731405415 | 0;
      this.El = 4290775857 | 0;
      this.Fh = 2394180231 | 0;
      this.Fl = 1750603025 | 0;
      this.Gh = 3675008525 | 0;
      this.Gl = 1694076839 | 0;
      this.Hh = 1203062813 | 0;
      this.Hl = 3204075428 | 0;
      this.outputLen = 48;
    }
  }
  exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512);
  exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224);
  exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256);
  exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384);
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils2 = __commonJS((exports) => {
  var isBytes = function(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  };
  var bytesToHex = function(bytes) {
    if (!isBytes(bytes))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0;i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  };
  var numberToHexUnpadded = function(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  };
  var hexToNumber = function(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  };
  var asciiToBase16 = function(char) {
    if (char >= asciis._0 && char <= asciis._9)
      return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
      return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
      return char - (asciis._a - 10);
    return;
  };
  var hexToBytes = function(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === undefined || n2 === undefined) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  };
  var bytesToNumberBE = function(bytes) {
    return hexToNumber(bytesToHex(bytes));
  };
  var bytesToNumberLE = function(bytes) {
    if (!isBytes(bytes))
      throw new Error("Uint8Array expected");
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
  };
  var numberToBytesBE = function(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
  };
  var numberToBytesLE = function(n, len) {
    return numberToBytesBE(n, len).reverse();
  };
  var numberToVarBytesBE = function(n) {
    return hexToBytes(numberToHexUnpadded(n));
  };
  var ensureBytes = function(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (isBytes(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  };
  var concatBytes = function(...arrays) {
    let sum = 0;
    for (let i = 0;i < arrays.length; i++) {
      const a = arrays[i];
      if (!isBytes(a))
        throw new Error("Uint8Array expected");
      sum += a.length;
    }
    let res = new Uint8Array(sum);
    let pad = 0;
    for (let i = 0;i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  };
  var equalBytes = function(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0;i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  };
  var utf8ToBytes = function(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  };
  var bitLen = function(n) {
    let len;
    for (len = 0;n > _0n; n >>= _1n, len += 1)
      ;
    return len;
  };
  var bitGet = function(n, pos) {
    return n >> BigInt(pos) & _1n;
  };
  var createHmacDrbg = function(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n()) => {
      k = h(u8fr([0]), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8fr([1]), seed);
      v = h();
    };
    const gen = () => {
      if (i++ >= 1000)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = undefined;
      while (!(res = pred(gen())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  };
  var validateObject = function(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type}", expected function`);
      const val = object[fieldName];
      if (isOptional && val === undefined)
        return;
      if (!checkVal(val, object)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = exports.isBytes = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  exports.isBytes = isBytes;
  var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  exports.bytesToHex = bytesToHex;
  exports.numberToHexUnpadded = numberToHexUnpadded;
  exports.hexToNumber = hexToNumber;
  var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  exports.hexToBytes = hexToBytes;
  exports.bytesToNumberBE = bytesToNumberBE;
  exports.bytesToNumberLE = bytesToNumberLE;
  exports.numberToBytesBE = numberToBytesBE;
  exports.numberToBytesLE = numberToBytesLE;
  exports.numberToVarBytesBE = numberToVarBytesBE;
  exports.ensureBytes = ensureBytes;
  exports.concatBytes = concatBytes;
  exports.equalBytes = equalBytes;
  exports.utf8ToBytes = utf8ToBytes;
  exports.bitLen = bitLen;
  exports.bitGet = bitGet;
  var bitSet = (n, pos, value) => {
    return n | (value ? _1n : _0n) << BigInt(pos);
  };
  exports.bitSet = bitSet;
  var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
  exports.bitMask = bitMask;
  var u8n = (data) => new Uint8Array(data);
  var u8fr = (arr) => Uint8Array.from(arr);
  exports.createHmacDrbg = createHmacDrbg;
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  exports.validateObject = validateObject;
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS((exports) => {
  var mod = function(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
  };
  var pow = function(num, power, modulo) {
    if (modulo <= _0n || power < _0n)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n)
      return _0n;
    let res = _1n;
    while (power > _0n) {
      if (power & _1n)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n;
    }
    return res;
  };
  var pow2 = function(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
      res *= res;
      res %= modulo;
    }
    return res;
  };
  var invert = function(number, modulo) {
    if (number === _0n || modulo <= _0n) {
      throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  };
  var tonelliShanks = function(P) {
    const legendreC = (P - _1n) / _2n;
    let Q, S, Z;
    for (Q = P - _1n, S = 0;Q % _2n === _0n; Q /= _2n, S++)
      ;
    for (Z = _2n;Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
      ;
    if (S === 1) {
      const p1div4 = (P + _1n) / _4n;
      return function tonelliFast(Fp, n) {
        const root = Fp.pow(n, p1div4);
        if (!Fp.eql(Fp.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
      if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
        throw new Error("Cannot find square root");
      let r = S;
      let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
      let x = Fp.pow(n, Q1div2);
      let b = Fp.pow(n, Q);
      while (!Fp.eql(b, Fp.ONE)) {
        if (Fp.eql(b, Fp.ZERO))
          return Fp.ZERO;
        let m = 1;
        for (let t2 = Fp.sqr(b);m < r; m++) {
          if (Fp.eql(t2, Fp.ONE))
            break;
          t2 = Fp.sqr(t2);
        }
        const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
        g = Fp.sqr(ge);
        x = Fp.mul(x, ge);
        b = Fp.mul(b, g);
        r = m;
      }
      return x;
    };
  };
  var FpSqrt = function(P) {
    if (P % _4n === _3n) {
      const p1div4 = (P + _1n) / _4n;
      return function sqrt3mod4(Fp, n) {
        const root = Fp.pow(n, p1div4);
        if (!Fp.eql(Fp.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n === _5n) {
      const c1 = (P - _5n) / _8n;
      return function sqrt5mod8(Fp, n) {
        const n2 = Fp.mul(n, _2n);
        const v = Fp.pow(n2, c1);
        const nv = Fp.mul(n, v);
        const i = Fp.mul(Fp.mul(nv, _2n), v);
        const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
        if (!Fp.eql(Fp.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _16n === _9n) {
    }
    return tonelliShanks(P);
  };
  var validateField = function(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return (0, utils_js_1.validateObject)(field, opts);
  };
  var FpPow = function(f, num, power) {
    if (power < _0n)
      throw new Error("Expected power > 0");
    if (power === _0n)
      return f.ONE;
    if (power === _1n)
      return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n) {
      if (power & _1n)
        p = f.mul(p, d);
      d = f.sqr(d);
      power >>= _1n;
    }
    return p;
  };
  var FpInvertBatch = function(f, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = acc;
      return f.mul(acc, num);
    }, f.ONE);
    const inverted = f.inv(lastMultiplied);
    nums.reduceRight((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = f.mul(acc, tmp[i]);
      return f.mul(acc, num);
    }, inverted);
    return tmp;
  };
  var FpDiv = function(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
  };
  var FpIsSquare = function(f) {
    const legendreConst = (f.ORDER - _1n) / _2n;
    return (x) => {
      const p = f.pow(x, legendreConst);
      return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
  };
  var nLength = function(n, nBitLength) {
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  };
  var Field = function(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: (0, utils_js_1.bitMask)(BITS),
      ZERO: _0n,
      ONE: _1n,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n <= num && num < ORDER;
      },
      is0: (num) => num === _0n,
      isOdd: (num) => (num & _1n) === _1n,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
      invertBatch: (lst) => FpInvertBatch(f, lst),
      cmov: (a, b, c) => c ? b : a,
      toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
      fromBytes: (bytes) => {
        if (bytes.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
        return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
      }
    });
    return Object.freeze(f);
  };
  var FpSqrtOdd = function(Fp, elm) {
    if (!Fp.isOdd)
      throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
  };
  var FpSqrtEven = function(Fp, elm) {
    if (!Fp.isOdd)
      throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
  };
  var hashToPrivateScalar = function(hash, groupOrder, isLE = false) {
    hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
      throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
  };
  var getFieldBytesLength = function(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  };
  var getMinHashLength = function(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  };
  var mapHashToField = function(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var utils_js_1 = require_utils2();
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _3n = BigInt(3);
  var _4n = BigInt(4);
  var _5n = BigInt(5);
  var _8n = BigInt(8);
  var _9n = BigInt(9);
  var _16n = BigInt(16);
  exports.mod = mod;
  exports.pow = pow;
  exports.pow2 = pow2;
  exports.invert = invert;
  exports.tonelliShanks = tonelliShanks;
  exports.FpSqrt = FpSqrt;
  var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
  exports.isNegativeLE = isNegativeLE;
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  exports.validateField = validateField;
  exports.FpPow = FpPow;
  exports.FpInvertBatch = FpInvertBatch;
  exports.FpDiv = FpDiv;
  exports.FpIsSquare = FpIsSquare;
  exports.nLength = nLength;
  exports.Field = Field;
  exports.FpSqrtOdd = FpSqrtOdd;
  exports.FpSqrtEven = FpSqrtEven;
  exports.hashToPrivateScalar = hashToPrivateScalar;
  exports.getFieldBytesLength = getFieldBytesLength;
  exports.getMinHashLength = getMinHashLength;
  exports.mapHashToField = mapHashToField;
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS((exports) => {
  var wNAF = function(c, bits) {
    const constTimeNegate = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W) => {
      const windows = Math.ceil(bits / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      unsafeLadder(elm, n) {
        let p = c.ZERO;
        let d = elm;
        while (n > _0n) {
          if (n & _1n)
            p = p.add(d);
          d = d.double();
          n >>= _1n;
        }
        return p;
      },
      precomputeWindow(elm, W) {
        const { windows, windowSize } = opts(W);
        const points = [];
        let p = elm;
        let base = p;
        for (let window2 = 0;window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1;i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      },
      wNAF(W, precomputes, n) {
        const { windows, windowSize } = opts(W);
        let p = c.ZERO;
        let f = c.BASE;
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0;window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f = f.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p, f };
      },
      wNAFCached(P, precomputesMap, n, transform) {
        const W = P._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            precomputesMap.set(P, transform(comp));
          }
        }
        return this.wNAF(W, comp, n);
      }
    };
  };
  var validateBasic = function(curve) {
    (0, modular_js_1.validateField)(curve.Fp);
    (0, utils_js_1.validateObject)(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateBasic = exports.wNAF = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var modular_js_1 = require_modular();
  var utils_js_1 = require_utils2();
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  exports.wNAF = wNAF;
  exports.validateBasic = validateBasic;
});

// node_modules/@noble/curves/abstract/edwards.js
var require_edwards = __commonJS((exports) => {
  var validateOpts = function(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(curve, {
      hash: "function",
      a: "bigint",
      d: "bigint",
      randomBytes: "function"
    }, {
      adjustScalarBytes: "function",
      domain: "function",
      uvRatio: "function",
      mapToCurve: "function"
    });
    return Object.freeze({ ...opts });
  };
  var twistedEdwards = function(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER, prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
    const MASK = _2n << BigInt(nByteLength * 8) - _1n;
    const modP = Fp.create;
    const uvRatio = CURVE.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
      } catch (e) {
        return { isValid: false, value: _0n };
      }
    });
    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
    const domain = CURVE.domain || ((data, ctx, phflag) => {
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    const inBig = (n) => typeof n === "bigint" && _0n < n;
    const inRange = (n, max) => inBig(n) && inBig(max) && n < max;
    const in0MaskRange = (n) => n === _0n || inRange(n, MASK);
    function assertInRange(n, max) {
      if (inRange(n, max))
        return n;
      throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);
    }
    function assertGE0(n) {
      return n === _0n ? n : assertInRange(n, CURVE_ORDER);
    }
    const pointPrecomputes = new Map;
    function isPoint(other) {
      if (!(other instanceof Point))
        throw new Error("ExtendedPoint expected");
    }

    class Point {
      constructor(ex, ey, ez, et) {
        this.ex = ex;
        this.ey = ey;
        this.ez = ez;
        this.et = et;
        if (!in0MaskRange(ex))
          throw new Error("x required");
        if (!in0MaskRange(ey))
          throw new Error("y required");
        if (!in0MaskRange(ez))
          throw new Error("z required");
        if (!in0MaskRange(et))
          throw new Error("t required");
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p) {
        if (p instanceof Point)
          throw new Error("extended point not allowed");
        const { x, y } = p || {};
        if (!in0MaskRange(x) || !in0MaskRange(y))
          throw new Error("invalid affine point");
        return new Point(x, y, _1n, modP(x * y));
      }
      static normalizeZ(points) {
        const toInv = Fp.invertBatch(points.map((p) => p.ez));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      assertValidity() {
        const { a, d } = CURVE;
        if (this.is0())
          throw new Error("bad point: ZERO");
        const { ex: X, ey: Y, ez: Z, et: T } = this;
        const X2 = modP(X * X);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X2 * a);
        const left = modP(Z2 * modP(aX2 + Y2));
        const right = modP(Z4 + modP(d * modP(X2 * Y2)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
      }
      equals(other) {
        isPoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      negate() {
        return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
      }
      double() {
        const { a } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n * modP(Z1 * Z1));
        const D = modP(a * A);
        const x1y1 = X1 + Y1;
        const E = modP(modP(x1y1 * x1y1) - A - B);
        const G2 = D + B;
        const F = G2 - C;
        const H = D - B;
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point(X3, Y3, Z3, T3);
      }
      add(other) {
        isPoint(other);
        const { a, d } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
        if (a === BigInt(-1)) {
          const A2 = modP((Y1 - X1) * (Y2 + X2));
          const B2 = modP((Y1 + X1) * (Y2 - X2));
          const F2 = modP(B2 - A2);
          if (F2 === _0n)
            return this.double();
          const C2 = modP(Z1 * _2n * T2);
          const D2 = modP(T1 * _2n * Z2);
          const E2 = D2 + C2;
          const G3 = B2 + A2;
          const H2 = D2 - C2;
          const X32 = modP(E2 * F2);
          const Y32 = modP(G3 * H2);
          const T32 = modP(E2 * H2);
          const Z32 = modP(F2 * G3);
          return new Point(X32, Y32, Z32, T32);
        }
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T1 * d * T2);
        const D = modP(Z1 * Z2);
        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G2 = D + C;
        const H = modP(B - a * A);
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
      }
      multiply(scalar) {
        const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
        return Point.normalizeZ([p, f])[0];
      }
      multiplyUnsafe(scalar) {
        let n = assertGE0(scalar);
        if (n === _0n)
          return I;
        if (this.equals(I) || n === _1n)
          return this;
        if (this.equals(G))
          return this.wNAF(n).p;
        return wnaf.unsafeLadder(this, n);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      isTorsionFree() {
        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
      }
      toAffine(iz) {
        const { ex: x, ey: y, ez: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? _8n : Fp.inv(z);
        const ax = modP(x * iz);
        const ay = modP(y * iz);
        const zz = modP(z * iz);
        if (is0)
          return { x: _0n, y: _1n };
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      clearCofactor() {
        const { h: cofactor2 } = CURVE;
        if (cofactor2 === _1n)
          return this;
        return this.multiplyUnsafe(cofactor2);
      }
      static fromHex(hex, zip215 = false) {
        const { d, a } = CURVE;
        const len = Fp.BYTES;
        hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len);
        const normed = hex.slice();
        const lastByte = hex[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y = ut.bytesToNumberLE(normed);
        if (y === _0n) {
        } else {
          if (zip215)
            assertInRange(y, MASK);
          else
            assertInRange(y, Fp.ORDER);
        }
        const y2 = modP(y * y);
        const u = modP(y2 - _1n);
        const v = modP(d * y2 - a);
        let { isValid, value: x } = uvRatio(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n) === _1n;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP(-x);
        return Point.fromAffine({ x, y });
      }
      static fromPrivateKey(privKey) {
        return getExtendedPublicKey(privKey).point;
      }
      toRawBytes() {
        const { x, y } = this.toAffine();
        const bytes = ut.numberToBytesLE(y, Fp.BYTES);
        bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
        return bytes;
      }
      toHex() {
        return ut.bytesToHex(this.toRawBytes());
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
    Point.ZERO = new Point(_0n, _1n, _1n, _0n);
    const { BASE: G, ZERO: I } = Point;
    const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
    function modN(a) {
      return (0, modular_js_1.mod)(a, CURVE_ORDER);
    }
    function modN_LE(hash) {
      return modN(ut.bytesToNumberLE(hash));
    }
    function getExtendedPublicKey(key) {
      const len = nByteLength;
      key = (0, utils_js_1.ensureBytes)("private key", key, len);
      const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      const point = G.multiply(scalar);
      const pointBytes = point.toRawBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context = new Uint8Array, ...msgs) {
      const msg = ut.concatBytes(...msgs);
      return modN_LE(cHash(domain(msg, (0, utils_js_1.ensureBytes)("context", context), !!prehash)));
    }
    function sign(msg, privKey, options = {}) {
      msg = (0, utils_js_1.ensureBytes)("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R = G.multiply(r).toRawBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s = modN(r + k * scalar);
      assertGE0(s);
      const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
      return (0, utils_js_1.ensureBytes)("result", res, nByteLength * 2);
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = Fp.BYTES;
      sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len);
      msg = (0, utils_js_1.ensureBytes)("message", msg);
      if (prehash)
        msg = prehash(msg);
      const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
      let A, R, SB;
      try {
        A = Point.fromHex(publicKey, zip215);
        R = Point.fromHex(sig.slice(0, len), zip215);
        SB = G.multiplyUnsafe(s);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
    }
    G._setWindowSize(8);
    const utils = {
      getExtendedPublicKey,
      randomPrivateKey: () => randomBytes(Fp.BYTES),
      precompute(windowSize = 8, point = Point.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    return {
      CURVE,
      getPublicKey,
      sign,
      verify,
      ExtendedPoint: Point,
      utils
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.twistedEdwards = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var modular_js_1 = require_modular();
  var ut = require_utils2();
  var utils_js_1 = require_utils2();
  var curve_js_1 = require_curve();
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _8n = BigInt(8);
  var VERIFY_DEFAULT = { zip215: true };
  exports.twistedEdwards = twistedEdwards;
});

// node_modules/@noble/curves/abstract/montgomery.js
var require_montgomery = __commonJS((exports) => {
  var validateOpts = function(curve) {
    (0, utils_js_1.validateObject)(curve, {
      a: "bigint"
    }, {
      montgomeryBits: "isSafeInteger",
      nByteLength: "isSafeInteger",
      adjustScalarBytes: "function",
      domain: "function",
      powPminus2: "function",
      Gu: "bigint"
    });
    return Object.freeze({ ...curve });
  };
  var montgomery = function(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P } = CURVE;
    const modP = (n) => (0, modular_js_1.mod)(n, P);
    const montgomeryBits = CURVE.montgomeryBits;
    const montgomeryBytes = Math.ceil(montgomeryBits / 8);
    const fieldLen = CURVE.nByteLength;
    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
    const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
    function cswap(swap, x_2, x_3) {
      const dummy = modP(swap * (x_2 - x_3));
      x_2 = modP(x_2 - dummy);
      x_3 = modP(x_3 + dummy);
      return [x_2, x_3];
    }
    function assertFieldElement(n) {
      if (typeof n === "bigint" && _0n <= n && n < P)
        return n;
      throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
    }
    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
    function montgomeryLadder(pointU, scalar) {
      const u = assertFieldElement(pointU);
      const k = assertFieldElement(scalar);
      const x_1 = u;
      let x_2 = _1n;
      let z_2 = _0n;
      let x_3 = u;
      let z_3 = _1n;
      let swap = _0n;
      let sw;
      for (let t = BigInt(montgomeryBits - 1);t >= _0n; t--) {
        const k_t = k >> t & _1n;
        swap ^= k_t;
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        swap = k_t;
        const A = x_2 + z_2;
        const AA = modP(A * A);
        const B = x_2 - z_2;
        const BB = modP(B * B);
        const E = AA - BB;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = modP(D * A);
        const CB = modP(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = modP(dacb * dacb);
        z_3 = modP(x_1 * modP(da_cb * da_cb));
        x_2 = modP(AA * BB);
        z_2 = modP(E * (AA + modP(a24 * E)));
      }
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      const z2 = powPminus2(z_2);
      return modP(x_2 * z2);
    }
    function encodeUCoordinate(u) {
      return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
    }
    function decodeUCoordinate(uEnc) {
      const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
      if (fieldLen === 32)
        u[31] &= 127;
      return (0, utils_js_1.bytesToNumberLE)(u);
    }
    function decodeScalar(n) {
      const bytes = (0, utils_js_1.ensureBytes)("scalar", n);
      const len = bytes.length;
      if (len !== montgomeryBytes && len !== fieldLen)
        throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);
      return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
    }
    function scalarMult(scalar, u) {
      const pointU = decodeUCoordinate(u);
      const _scalar = decodeScalar(scalar);
      const pu = montgomeryLadder(pointU, _scalar);
      if (pu === _0n)
        throw new Error("Invalid private or public key received");
      return encodeUCoordinate(pu);
    }
    const GuBytes = encodeUCoordinate(CURVE.Gu);
    function scalarMultBase(scalar) {
      return scalarMult(scalar, GuBytes);
    }
    return {
      scalarMult,
      scalarMultBase,
      getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
      getPublicKey: (privateKey) => scalarMultBase(privateKey),
      utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
      GuBytes
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.montgomery = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var modular_js_1 = require_modular();
  var utils_js_1 = require_utils2();
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  exports.montgomery = montgomery;
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS((exports) => {
  var validateDST = function(dst) {
    if ((0, utils_js_1.isBytes)(dst))
      return dst;
    if (typeof dst === "string")
      return (0, utils_js_1.utf8ToBytes)(dst);
    throw new Error("DST must be Uint8Array or string");
  };
  var i2osp = function(value, length) {
    if (value < 0 || value >= 1 << 8 * length) {
      throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1;i >= 0; i--) {
      res[i] = value & 255;
      value >>>= 8;
    }
    return new Uint8Array(res);
  };
  var strxor = function(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0;i < a.length; i++) {
      arr[i] = a[i] ^ b[i];
    }
    return arr;
  };
  var abytes = function(item) {
    if (!(0, utils_js_1.isBytes)(item))
      throw new Error("Uint8Array expected");
  };
  var isNum = function(item) {
    if (!Number.isSafeInteger(item))
      throw new Error("number expected");
  };
  var expand_message_xmd = function(msg, DST, lenInBytes, H) {
    abytes(msg);
    abytes(DST);
    isNum(lenInBytes);
    if (DST.length > 255)
      DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255)
      throw new Error("Invalid xmd length");
    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2);
    const b = new Array(ell);
    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1;i <= ell; i++) {
      const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
      b[i] = H((0, utils_js_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
  };
  var expand_message_xof = function(msg, DST, lenInBytes, k, H) {
    abytes(msg);
    abytes(DST);
    isNum(lenInBytes);
    if (DST.length > 255) {
      const dkLen = Math.ceil(2 * k / 8);
      DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
      throw new Error("expand_message_xof: invalid lenInBytes");
    return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
  };
  var hash_to_field = function(msg, count, options) {
    (0, utils_js_1.validateObject)(options, {
      DST: "stringOrUint8Array",
      p: "bigint",
      m: "isSafeInteger",
      k: "isSafeInteger",
      hash: "hash"
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    abytes(msg);
    isNum(count);
    const DST = validateDST(_DST);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8);
    const len_in_bytes = count * m * L;
    let prb;
    if (expand === "xmd") {
      prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    } else if (expand === "xof") {
      prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    } else if (expand === "_internal_pass") {
      prb = msg;
    } else {
      throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0;i < count; i++) {
      const e = new Array(m);
      for (let j = 0;j < m; j++) {
        const elm_offset = L * (j + i * m);
        const tv = prb.subarray(elm_offset, elm_offset + L);
        e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
      }
      u[i] = e;
    }
    return u;
  };
  var isogenyMap = function(field, map) {
    const COEFF = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
      const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
      x = field.div(xNum, xDen);
      y = field.mul(y, field.div(yNum, yDen));
      return { x, y };
    };
  };
  var createHasher = function(Point, mapToCurve, def) {
    if (typeof mapToCurve !== "function")
      throw new Error("mapToCurve() must be defined");
    return {
      hashToCurve(msg, options) {
        const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
        const u0 = Point.fromAffine(mapToCurve(u[0]));
        const u1 = Point.fromAffine(mapToCurve(u[1]));
        const P = u0.add(u1).clearCofactor();
        P.assertValidity();
        return P;
      },
      encodeToCurve(msg, options) {
        const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
        const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
        P.assertValidity();
        return P;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = undefined;
  var modular_js_1 = require_modular();
  var utils_js_1 = require_utils2();
  var os2ip = utils_js_1.bytesToNumberBE;
  exports.expand_message_xmd = expand_message_xmd;
  exports.expand_message_xof = expand_message_xof;
  exports.hash_to_field = hash_to_field;
  exports.isogenyMap = isogenyMap;
  exports.createHasher = createHasher;
});

// node_modules/@noble/curves/ed25519.js
var require_ed25519 = __commonJS((exports) => {
  var ed25519_pow_2_252_3 = function(x) {
    const P = ED25519_P;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P;
    const b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P;
    const b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;
    const b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;
    const b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;
    const b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;
    const b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;
    const b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;
    const b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;
    return { pow_p_5_8, b2 };
  };
  var adjustScalarBytes = function(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 127;
    bytes[31] |= 64;
    return bytes;
  };
  var uvRatio = function(u, v) {
    const P = ED25519_P;
    const v3 = (0, modular_js_1.mod)(v * v * v, P);
    const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P);
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = (0, modular_js_1.mod)(u * v3 * pow, P);
    const vx2 = (0, modular_js_1.mod)(v * x * x, P);
    const root1 = x;
    const root2 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P);
    const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if ((0, modular_js_1.isNegativeLE)(x, P))
      x = (0, modular_js_1.mod)(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  };
  var ed25519_domain = function(data, ctx, phflag) {
    if (ctx.length > 255)
      throw new Error("Context is too big");
    return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
  };
  var edwardsToMontgomeryPub = function(edwardsPub) {
    const { y } = exports.ed25519.ExtendedPoint.fromHex(edwardsPub);
    const _1n2 = BigInt(1);
    return Fp.toBytes(Fp.create((_1n2 + y) * Fp.inv(_1n2 - y)));
  };
  var edwardsToMontgomeryPriv = function(edwardsPriv) {
    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
  };
  var map_to_curve_elligator2_curve25519 = function(u) {
    let tv1 = Fp.sqr(u);
    tv1 = Fp.mul(tv1, _2n);
    let xd = Fp.add(tv1, Fp.ONE);
    let x1n = Fp.neg(ELL2_J);
    let tv2 = Fp.sqr(xd);
    let gxd = Fp.mul(tv2, xd);
    let gx1 = Fp.mul(tv1, ELL2_J);
    gx1 = Fp.mul(gx1, x1n);
    gx1 = Fp.add(gx1, tv2);
    gx1 = Fp.mul(gx1, x1n);
    let tv3 = Fp.sqr(gxd);
    tv2 = Fp.sqr(tv3);
    tv3 = Fp.mul(tv3, gxd);
    tv3 = Fp.mul(tv3, gx1);
    tv2 = Fp.mul(tv2, tv3);
    let y11 = Fp.pow(tv2, ELL2_C4);
    y11 = Fp.mul(y11, tv3);
    let y12 = Fp.mul(y11, ELL2_C3);
    tv2 = Fp.sqr(y11);
    tv2 = Fp.mul(tv2, gxd);
    let e1 = Fp.eql(tv2, gx1);
    let y1 = Fp.cmov(y12, y11, e1);
    let x2n = Fp.mul(x1n, tv1);
    let y21 = Fp.mul(y11, u);
    y21 = Fp.mul(y21, ELL2_C2);
    let y22 = Fp.mul(y21, ELL2_C3);
    let gx2 = Fp.mul(gx1, tv1);
    tv2 = Fp.sqr(y21);
    tv2 = Fp.mul(tv2, gxd);
    let e2 = Fp.eql(tv2, gx2);
    let y2 = Fp.cmov(y22, y21, e2);
    tv2 = Fp.sqr(y1);
    tv2 = Fp.mul(tv2, gxd);
    let e3 = Fp.eql(tv2, gx1);
    let xn = Fp.cmov(x2n, x1n, e3);
    let y = Fp.cmov(y2, y1, e3);
    let e4 = Fp.isOdd(y);
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
  };
  var map_to_curve_elligator2_edwards25519 = function(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
    let xn = Fp.mul(xMn, yMd);
    xn = Fp.mul(xn, ELL2_C1_EDWARDS);
    let xd = Fp.mul(xMd, yMn);
    let yn = Fp.sub(xMn, xMd);
    let yd = Fp.add(xMn, xMd);
    let tv1 = Fp.mul(xd, yd);
    let e = Fp.eql(tv1, Fp.ZERO);
    xn = Fp.cmov(xn, Fp.ZERO, e);
    xd = Fp.cmov(xd, Fp.ONE, e);
    yn = Fp.cmov(yn, Fp.ONE, e);
    yd = Fp.cmov(yd, Fp.ONE, e);
    const inv = Fp.invertBatch([xd, yd]);
    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) };
  };
  var assertRstPoint = function(other) {
    if (!(other instanceof RistPoint))
      throw new Error("RistrettoPoint expected");
  };
  var calcElligatorRistrettoMap = function(r0) {
    const { d } = exports.ed25519.CURVE;
    const P = exports.ed25519.CURVE.Fp.ORDER;
    const mod = exports.ed25519.CURVE.Fp.create;
    const r = mod(SQRT_M1 * r0 * r0);
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod((c - d * r) * mod(r + d));
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
    let s_ = mod(s * r0);
    if (!(0, modular_js_1.isNegativeLE)(s_, P))
      s_ = mod(-s_);
    if (!Ns_D_is_sq)
      s = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
    const s2 = s * s;
    const W0 = mod((s + s) * D);
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod(_1n - s2);
    const W3 = mod(_1n + s2);
    return new exports.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.edwardsToMontgomeryPriv = exports.edwardsToMontgomery = exports.edwardsToMontgomeryPub = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var sha512_1 = require_sha512();
  var utils_1 = require_utils();
  var edwards_js_1 = require_edwards();
  var montgomery_js_1 = require_montgomery();
  var modular_js_1 = require_modular();
  var utils_js_1 = require_utils2();
  var hash_to_curve_js_1 = require_hash_to_curve();
  var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
  var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _5n = BigInt(5);
  var _10n = BigInt(10);
  var _20n = BigInt(20);
  var _40n = BigInt(40);
  var _80n = BigInt(80);
  exports.ED25519_TORSION_SUBGROUP = [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ];
  var Fp = (0, modular_js_1.Field)(ED25519_P, undefined, true);
  var ed25519Defaults = {
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: BigInt(8),
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: sha512_1.sha512,
    randomBytes: utils_1.randomBytes,
    adjustScalarBytes,
    uvRatio
  };
  exports.ed25519 = (0, edwards_js_1.twistedEdwards)(ed25519Defaults);
  exports.ed25519ctx = (0, edwards_js_1.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain
  });
  exports.ed25519ph = (0, edwards_js_1.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain,
    prehash: sha512_1.sha512
  });
  exports.x25519 = (() => (0, montgomery_js_1.montgomery)({
    P: ED25519_P,
    a: BigInt(486662),
    montgomeryBits: 255,
    nByteLength: 32,
    Gu: BigInt(9),
    powPminus2: (x) => {
      const P = ED25519_P;
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
      return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);
    },
    adjustScalarBytes,
    randomBytes: utils_1.randomBytes
  }))();
  exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
  exports.edwardsToMontgomery = edwardsToMontgomeryPub;
  exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
  var ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
  var ELL2_C2 = Fp.pow(_2n, ELL2_C1);
  var ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
  var ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
  var ELL2_J = BigInt(486662);
  var ELL2_C1_EDWARDS = (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664)));
  var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
    encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha512_1.sha512
  }))();
  exports.hashToCurve = (() => htf.hashToCurve)();
  exports.encodeToCurve = (() => htf.encodeToCurve)();
  var SQRT_M1 = ED25519_SQRT_M1;
  var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  var invertSqrt = (number) => uvRatio(_1n, number);
  var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var bytes255ToNumberLE = (bytes) => exports.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);

  class RistPoint {
    constructor(ep) {
      this.ep = ep;
    }
    static fromAffine(ap) {
      return new RistPoint(exports.ed25519.ExtendedPoint.fromAffine(ap));
    }
    static hashToCurve(hex) {
      hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
      const r1 = bytes255ToNumberLE(hex.slice(0, 32));
      const R1 = calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE(hex.slice(32, 64));
      const R2 = calcElligatorRistrettoMap(r2);
      return new RistPoint(R1.add(R2));
    }
    static fromHex(hex) {
      hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
      const { a, d } = exports.ed25519.CURVE;
      const P = exports.ed25519.CURVE.Fp.ORDER;
      const mod = exports.ed25519.CURVE.Fp.create;
      const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
      const s = bytes255ToNumberLE(hex);
      if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
        throw new Error(emsg);
      const s2 = mod(s * s);
      const u1 = mod(_1n + a * s2);
      const u2 = mod(_1n - a * s2);
      const u1_2 = mod(u1 * u1);
      const u2_2 = mod(u2 * u2);
      const v = mod(a * d * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt(mod(v * u2_2));
      const Dx = mod(I * u2);
      const Dy = mod(I * Dx * v);
      let x = mod((s + s) * Dx);
      if ((0, modular_js_1.isNegativeLE)(x, P))
        x = mod(-x);
      const y = mod(u1 * Dy);
      const t = mod(x * y);
      if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)
        throw new Error(emsg);
      return new RistPoint(new exports.ed25519.ExtendedPoint(x, y, _1n, t));
    }
    toRawBytes() {
      let { ex: x, ey: y, ez: z, et: t } = this.ep;
      const P = exports.ed25519.CURVE.Fp.ORDER;
      const mod = exports.ed25519.CURVE.Fp.create;
      const u1 = mod(mod(z + y) * mod(z - y));
      const u2 = mod(x * y);
      const u2sq = mod(u2 * u2);
      const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
      const D1 = mod(invsqrt * u1);
      const D2 = mod(invsqrt * u2);
      const zInv = mod(D1 * D2 * t);
      let D;
      if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
        let _x = mod(y * SQRT_M1);
        let _y = mod(x * SQRT_M1);
        x = _x;
        y = _y;
        D = mod(D1 * INVSQRT_A_MINUS_D);
      } else {
        D = D2;
      }
      if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
        y = mod(-y);
      let s = mod((z - y) * D);
      if ((0, modular_js_1.isNegativeLE)(s, P))
        s = mod(-s);
      return (0, utils_js_1.numberToBytesLE)(s, 32);
    }
    toHex() {
      return (0, utils_js_1.bytesToHex)(this.toRawBytes());
    }
    toString() {
      return this.toHex();
    }
    equals(other) {
      assertRstPoint(other);
      const { ex: X1, ey: Y1 } = this.ep;
      const { ex: X2, ey: Y2 } = other.ep;
      const mod = exports.ed25519.CURVE.Fp.create;
      const one = mod(X1 * Y2) === mod(Y1 * X2);
      const two = mod(Y1 * Y2) === mod(X1 * X2);
      return one || two;
    }
    add(other) {
      assertRstPoint(other);
      return new RistPoint(this.ep.add(other.ep));
    }
    subtract(other) {
      assertRstPoint(other);
      return new RistPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
      return new RistPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
      return new RistPoint(this.ep.multiplyUnsafe(scalar));
    }
    double() {
      return new RistPoint(this.ep.double());
    }
    negate() {
      return new RistPoint(this.ep.negate());
    }
  }
  exports.RistrettoPoint = (() => {
    if (!RistPoint.BASE)
      RistPoint.BASE = new RistPoint(exports.ed25519.ExtendedPoint.BASE);
    if (!RistPoint.ZERO)
      RistPoint.ZERO = new RistPoint(exports.ed25519.ExtendedPoint.ZERO);
    return RistPoint;
  })();
  var hashToRistretto255 = (msg, options) => {
    const d = options.DST;
    const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
    const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
    const P = RistPoint.hashToCurve(uniform_bytes);
    return P;
  };
  exports.hashToRistretto255 = hashToRistretto255;
  exports.hash_to_ristretto255 = exports.hashToRistretto255;
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS((exports, module) => {
  (function(module2, exports2) {
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor;
      ctor.prototype.constructor = ctor;
    }
    function BN(number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }
        this._init(number || 0, base || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN;
    } else {
      exports2.BN = BN;
    }
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = __require("buffer").Buffer;
      }
    } catch (e) {
    }
    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base, endian);
      }
      if (base === "hex") {
        base = 16;
      }
      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
      assert(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number.length - 1, j = 0;i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0;i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert(false, "Invalid character in " + string);
      }
    }
    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number.length - 1;i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start;i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul) {
      var r = 0;
      var b = 0;
      var len = Math.min(str.length, end);
      for (var i = start;i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
          b = c - 49 + 10;
        } else if (c >= 17) {
          b = c - 17 + 10;
        } else {
          b = c;
        }
        assert(c >= 0 && b < mul, "Invalid character");
        r += b;
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start;i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
        for (i = 0;i < mod; i++) {
          pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
      } catch (e) {
        BN.prototype.inspect = inspect;
      }
    } else {
      BN.prototype.inspect = inspect;
    }
    function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64000000,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      24300000,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;
      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0;i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modrn(groupBase).toString(base);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, "byte array longer than desired length");
      assert(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength);
      return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0;i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0;i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0;bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 1;
      }
      return w;
    }
    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r = 0;
      for (var i = 0;i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26)
          break;
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0;i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN.prototype.ior = function ior(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0;i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this._strip();
    };
    BN.prototype.iand = function iand(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0;i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN.prototype.inotn = function inotn(width) {
      assert(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0;i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0;i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0;i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1;k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0;k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;
      for (var i = 0;i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1)
        return x;
      var rb = 0;
      for (var i = 0;i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0;i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s = 1;s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0;p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0;j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0;N; N = N >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1)
        return;
      for (var i = 0;i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;
      for (var i = 0;i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;
      for (var i = 0;i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i = 2 * len;i < N; ++i) {
        rws[i] = 0;
      }
      assert(carry === 0);
      assert((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);
      for (var i = 0;i < N; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _ = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);
      for (var i = 0;i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out._strip();
    };
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert(typeof num === "number");
      assert(num < 67108864);
      var carry = 0;
      for (var i = 0;i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN(1);
      var res = this;
      for (var i = 0;i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr();i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN.prototype.iushln = function iushln(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0;i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1;i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0;i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
      assert(this.negative === 0);
      return this.iushln(bits);
    };
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0;i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) {
      } else if (this.length > s) {
        this.length -= s;
        for (i = 0;i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1;i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s)
        return false;
      var w = this.words[s];
      return !!(w & q);
    };
    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0;i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0;i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0;i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (;i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert(carry === -1);
      carry = 0;
      for (i = 0;i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m = a.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0;i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1;j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN(1);
      var B = new BN(0);
      var C = new BN(0);
      var D = new BN(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1;(x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN.prototype._invmp = function _invmp(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1;(a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0;a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i = s;carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b)
          continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN.red = function red(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert(!this.red, "Already a number in reduction context");
      assert(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt() {
      assert(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg() {
      assert(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0;i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10;i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0;i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0;i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime;
      if (name === "k256") {
        prime = new K256;
      } else if (name === "p224") {
        prime = new P224;
      } else if (name === "p192") {
        prime = new P192;
      } else if (name === "p25519") {
        prime = new P25519;
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime;
      return prime;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert(a.negative === 0, "red works only with positives");
      assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert((a.negative | b.negative) === 0, "red works only with positives");
      assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0;tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i = 2;i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1;i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1;j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
      if (a.isZero() || b.isZero())
        return new BN(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module === "undefined" || module, exports);
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var copyProps = function(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  };
  var SafeBuffer = function(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  };
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/@solana/web3.js/node_modules/bs58/node_modules/base-x/src/index.js
var require_src = __commonJS((exports, module) => {
  var base = function(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode(string) {
      var buffer = decodeUnsafe(string);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE + " character");
    }
    return {
      encode,
      decodeUnsafe,
      decode
    };
  };
  var _Buffer = require_safe_buffer().Buffer;
  module.exports = base;
});

// node_modules/@solana/web3.js/node_modules/bs58/index.js
var require_bs58 = __commonJS((exports, module) => {
  var basex = require_src();
  var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET);
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha224 = exports.sha256 = undefined;
  var _sha2_js_1 = require__sha2();
  var utils_js_1 = require_utils();
  var Chi = (a, b, c) => a & b ^ ~a & c;
  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  var SHA256_K = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = new Uint32Array(64);

  class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16;i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
        const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0;i < 64; i++) {
        const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  }

  class SHA224 extends SHA256 {
    constructor() {
      super();
      this.A = 3238371032 | 0;
      this.B = 914150663 | 0;
      this.C = 812702999 | 0;
      this.D = 4144912697 | 0;
      this.E = 4290775857 | 0;
      this.F = 1750603025 | 0;
      this.G = 1694076839 | 0;
      this.H = 3204075428 | 0;
      this.outputLen = 28;
    }
  }
  exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256);
  exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224);
});

// node_modules/borsh/node_modules/bs58/node_modules/base-x/src/index.js
var require_src2 = __commonJS((exports, module) => {
  var base = function(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode(string) {
      var buffer = decodeUnsafe(string);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE + " character");
    }
    return {
      encode,
      decodeUnsafe,
      decode
    };
  };
  var _Buffer = require_safe_buffer().Buffer;
  module.exports = base;
});

// node_modules/borsh/node_modules/bs58/index.js
var require_bs582 = __commonJS((exports, module) => {
  var basex = require_src2();
  var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET);
});

// node_modules/text-encoding-utf-8/lib/encoding.lib.js
var require_encoding_lib = __commonJS((exports) => {
  var inRange = function(a, min, max) {
    return min <= a && a <= max;
  };
  var ToDictionary = function(o) {
    if (o === undefined)
      return {};
    if (o === Object(o))
      return o;
    throw TypeError("Could not convert argument to dictionary");
  };
  var stringToCodePoints = function(string) {
    var s = String(string);
    var n = s.length;
    var i = 0;
    var u = [];
    while (i < n) {
      var c = s.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        u.push(c);
      } else if (56320 <= c && c <= 57343) {
        u.push(65533);
      } else if (55296 <= c && c <= 56319) {
        if (i === n - 1) {
          u.push(65533);
        } else {
          var d = string.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            var a = c & 1023;
            var b = d & 1023;
            u.push(65536 + (a << 10) + b);
            i += 1;
          } else {
            u.push(65533);
          }
        }
      }
      i += 1;
    }
    return u;
  };
  var codePointsToString = function(code_points) {
    var s = "";
    for (var i = 0;i < code_points.length; ++i) {
      var cp = code_points[i];
      if (cp <= 65535) {
        s += String.fromCharCode(cp);
      } else {
        cp -= 65536;
        s += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
      }
    }
    return s;
  };
  var Stream = function(tokens) {
    this.tokens = [].slice.call(tokens);
  };
  var decoderError = function(fatal, opt_code_point) {
    if (fatal)
      throw TypeError("Decoder error");
    return opt_code_point || 65533;
  };
  var TextDecoder2 = function(encoding, options) {
    if (!(this instanceof TextDecoder2)) {
      return new TextDecoder2(encoding, options);
    }
    encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
    if (encoding !== DEFAULT_ENCODING) {
      throw new Error("Encoding not supported. Only utf-8 is supported");
    }
    options = ToDictionary(options);
    this._streaming = false;
    this._BOMseen = false;
    this._decoder = null;
    this._fatal = Boolean(options["fatal"]);
    this._ignoreBOM = Boolean(options["ignoreBOM"]);
    Object.defineProperty(this, "encoding", { value: "utf-8" });
    Object.defineProperty(this, "fatal", { value: this._fatal });
    Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
  };
  var TextEncoder2 = function(encoding, options) {
    if (!(this instanceof TextEncoder2))
      return new TextEncoder2(encoding, options);
    encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
    if (encoding !== DEFAULT_ENCODING) {
      throw new Error("Encoding not supported. Only utf-8 is supported");
    }
    options = ToDictionary(options);
    this._streaming = false;
    this._encoder = null;
    this._options = { fatal: Boolean(options["fatal"]) };
    Object.defineProperty(this, "encoding", { value: "utf-8" });
  };
  var UTF8Decoder = function(options) {
    var fatal = options.fatal;
    var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream && utf8_bytes_needed !== 0) {
        utf8_bytes_needed = 0;
        return decoderError(fatal);
      }
      if (bite === end_of_stream)
        return finished;
      if (utf8_bytes_needed === 0) {
        if (inRange(bite, 0, 127)) {
          return bite;
        }
        if (inRange(bite, 194, 223)) {
          utf8_bytes_needed = 1;
          utf8_code_point = bite - 192;
        } else if (inRange(bite, 224, 239)) {
          if (bite === 224)
            utf8_lower_boundary = 160;
          if (bite === 237)
            utf8_upper_boundary = 159;
          utf8_bytes_needed = 2;
          utf8_code_point = bite - 224;
        } else if (inRange(bite, 240, 244)) {
          if (bite === 240)
            utf8_lower_boundary = 144;
          if (bite === 244)
            utf8_upper_boundary = 143;
          utf8_bytes_needed = 3;
          utf8_code_point = bite - 240;
        } else {
          return decoderError(fatal);
        }
        utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
        return null;
      }
      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        utf8_lower_boundary = 128;
        utf8_upper_boundary = 191;
        stream.prepend(bite);
        return decoderError(fatal);
      }
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      utf8_bytes_seen += 1;
      utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
      if (utf8_bytes_seen !== utf8_bytes_needed)
        return null;
      var code_point = utf8_code_point;
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      return code_point;
    };
  };
  var UTF8Encoder = function(options) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (inRange(code_point, 0, 127))
        return code_point;
      var count, offset;
      if (inRange(code_point, 128, 2047)) {
        count = 1;
        offset = 192;
      } else if (inRange(code_point, 2048, 65535)) {
        count = 2;
        offset = 224;
      } else if (inRange(code_point, 65536, 1114111)) {
        count = 3;
        offset = 240;
      }
      var bytes = [(code_point >> 6 * count) + offset];
      while (count > 0) {
        var temp = code_point >> 6 * (count - 1);
        bytes.push(128 | temp & 63);
        count -= 1;
      }
      return bytes;
    };
  };
  var end_of_stream = -1;
  Stream.prototype = {
    endOfStream: function() {
      return !this.tokens.length;
    },
    read: function() {
      if (!this.tokens.length)
        return end_of_stream;
      return this.tokens.shift();
    },
    prepend: function(token) {
      if (Array.isArray(token)) {
        var tokens = token;
        while (tokens.length)
          this.tokens.unshift(tokens.pop());
      } else {
        this.tokens.unshift(token);
      }
    },
    push: function(token) {
      if (Array.isArray(token)) {
        var tokens = token;
        while (tokens.length)
          this.tokens.push(tokens.shift());
      } else {
        this.tokens.push(token);
      }
    }
  };
  var finished = -1;
  var DEFAULT_ENCODING = "utf-8";
  TextDecoder2.prototype = {
    decode: function decode(input, options) {
      var bytes;
      if (typeof input === "object" && input instanceof ArrayBuffer) {
        bytes = new Uint8Array(input);
      } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
        bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
      } else {
        bytes = new Uint8Array(0);
      }
      options = ToDictionary(options);
      if (!this._streaming) {
        this._decoder = new UTF8Decoder({ fatal: this._fatal });
        this._BOMseen = false;
      }
      this._streaming = Boolean(options["stream"]);
      var input_stream = new Stream(bytes);
      var code_points = [];
      var result;
      while (!input_stream.endOfStream()) {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(code_points, result);
        else
          code_points.push(result);
      }
      if (!this._streaming) {
        do {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(code_points, result);
          else
            code_points.push(result);
        } while (!input_stream.endOfStream());
        this._decoder = null;
      }
      if (code_points.length) {
        if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
          if (code_points[0] === 65279) {
            this._BOMseen = true;
            code_points.shift();
          } else {
            this._BOMseen = true;
          }
        }
      }
      return codePointsToString(code_points);
    }
  };
  TextEncoder2.prototype = {
    encode: function encode(opt_string, options) {
      opt_string = opt_string ? String(opt_string) : "";
      options = ToDictionary(options);
      if (!this._streaming)
        this._encoder = new UTF8Encoder(this._options);
      this._streaming = Boolean(options["stream"]);
      var bytes = [];
      var input_stream = new Stream(stringToCodePoints(opt_string));
      var result;
      while (!input_stream.endOfStream()) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          bytes.push.apply(bytes, result);
        else
          bytes.push(result);
      }
      if (!this._streaming) {
        while (true) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes.push.apply(bytes, result);
          else
            bytes.push(result);
        }
        this._encoder = null;
      }
      return new Uint8Array(bytes);
    }
  };
  exports.TextEncoder = TextEncoder2;
  exports.TextDecoder = TextDecoder2;
});

// node_modules/borsh/lib/index.js
var require_lib = __commonJS((exports) => {
  var baseEncode = function(value) {
    if (typeof value === "string") {
      value = Buffer.from(value, "utf8");
    }
    return bs58_1.default.encode(Buffer.from(value));
  };
  var baseDecode = function(value) {
    return Buffer.from(bs58_1.default.decode(value));
  };
  var handlingRangeError = function(target, propertyKey, propertyDescriptor) {
    const originalMethod = propertyDescriptor.value;
    propertyDescriptor.value = function(...args) {
      try {
        return originalMethod.apply(this, args);
      } catch (e) {
        if (e instanceof RangeError) {
          const code = e.code;
          if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
            throw new BorshError("Reached the end of buffer when deserializing");
          }
        }
        throw e;
      }
    };
  };
  var capitalizeFirstLetter = function(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  var serializeField = function(schema, fieldName, value, fieldType, writer) {
    try {
      if (typeof fieldType === "string") {
        writer[`write${capitalizeFirstLetter(fieldType)}`](value);
      } else if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          if (value.length !== fieldType[0]) {
            throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
          }
          writer.writeFixedArray(value);
        } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
          if (value.length !== fieldType[1]) {
            throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
          }
          for (let i = 0;i < fieldType[1]; i++) {
            serializeField(schema, null, value[i], fieldType[0], writer);
          }
        } else {
          writer.writeArray(value, (item) => {
            serializeField(schema, fieldName, item, fieldType[0], writer);
          });
        }
      } else if (fieldType.kind !== undefined) {
        switch (fieldType.kind) {
          case "option": {
            if (value === null || value === undefined) {
              writer.writeU8(0);
            } else {
              writer.writeU8(1);
              serializeField(schema, fieldName, value, fieldType.type, writer);
            }
            break;
          }
          case "map": {
            writer.writeU32(value.size);
            value.forEach((val, key) => {
              serializeField(schema, fieldName, key, fieldType.key, writer);
              serializeField(schema, fieldName, val, fieldType.value, writer);
            });
            break;
          }
          default:
            throw new BorshError(`FieldType ${fieldType} unrecognized`);
        }
      } else {
        serializeStruct(schema, value, writer);
      }
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }
      throw error;
    }
  };
  var serializeStruct = function(schema, obj, writer) {
    if (typeof obj.borshSerialize === "function") {
      obj.borshSerialize(writer);
      return;
    }
    const structSchema = schema.get(obj.constructor);
    if (!structSchema) {
      throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
      structSchema.fields.map(([fieldName, fieldType]) => {
        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
      });
    } else if (structSchema.kind === "enum") {
      const name = obj[structSchema.field];
      for (let idx = 0;idx < structSchema.values.length; ++idx) {
        const [fieldName, fieldType] = structSchema.values[idx];
        if (fieldName === name) {
          writer.writeU8(idx);
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          break;
        }
      }
    } else {
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
    }
  };
  var serialize = function(schema, obj, Writer = BinaryWriter) {
    const writer = new Writer;
    serializeStruct(schema, obj, writer);
    return writer.toArray();
  };
  var deserializeField = function(schema, fieldName, fieldType, reader) {
    try {
      if (typeof fieldType === "string") {
        return reader[`read${capitalizeFirstLetter(fieldType)}`]();
      }
      if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          return reader.readFixedArray(fieldType[0]);
        } else if (typeof fieldType[1] === "number") {
          const arr = [];
          for (let i = 0;i < fieldType[1]; i++) {
            arr.push(deserializeField(schema, null, fieldType[0], reader));
          }
          return arr;
        } else {
          return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
        }
      }
      if (fieldType.kind === "option") {
        const option = reader.readU8();
        if (option) {
          return deserializeField(schema, fieldName, fieldType.type, reader);
        }
        return;
      }
      if (fieldType.kind === "map") {
        let map = new Map;
        const length = reader.readU32();
        for (let i = 0;i < length; i++) {
          const key = deserializeField(schema, fieldName, fieldType.key, reader);
          const val = deserializeField(schema, fieldName, fieldType.value, reader);
          map.set(key, val);
        }
        return map;
      }
      return deserializeStruct(schema, fieldType, reader);
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }
      throw error;
    }
  };
  var deserializeStruct = function(schema, classType, reader) {
    if (typeof classType.borshDeserialize === "function") {
      return classType.borshDeserialize(reader);
    }
    const structSchema = schema.get(classType);
    if (!structSchema) {
      throw new BorshError(`Class ${classType.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
      const result = {};
      for (const [fieldName, fieldType] of schema.get(classType).fields) {
        result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
      }
      return new classType(result);
    }
    if (structSchema.kind === "enum") {
      const idx = reader.readU8();
      if (idx >= structSchema.values.length) {
        throw new BorshError(`Enum index: ${idx} is out of range`);
      }
      const [fieldName, fieldType] = structSchema.values[idx];
      const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
      return new classType({ [fieldName]: fieldValue });
    }
    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
  };
  var deserialize = function(schema, classType, buffer, Reader = BinaryReader) {
    const reader = new Reader(buffer);
    const result = deserializeStruct(schema, classType, reader);
    if (reader.offset < buffer.length) {
      throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
    }
    return result;
  };
  var deserializeUnchecked = function(schema, classType, buffer, Reader = BinaryReader) {
    const reader = new Reader(buffer);
    return deserializeStruct(schema, classType, reader);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1;i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = undefined;
  var bn_js_1 = __importDefault(require_bn());
  var bs58_1 = __importDefault(require_bs582());
  var encoding = __importStar(require_encoding_lib());
  var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
  var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
  exports.baseEncode = baseEncode;
  exports.baseDecode = baseDecode;
  var INITIAL_LENGTH = 1024;

  class BorshError extends Error {
    constructor(message) {
      super(message);
      this.fieldPath = [];
      this.originalMessage = message;
    }
    addToFieldPath(fieldName) {
      this.fieldPath.splice(0, 0, fieldName);
      this.message = this.originalMessage + ": " + this.fieldPath.join(".");
    }
  }
  exports.BorshError = BorshError;

  class BinaryWriter {
    constructor() {
      this.buf = Buffer.alloc(INITIAL_LENGTH);
      this.length = 0;
    }
    maybeResize() {
      if (this.buf.length < 16 + this.length) {
        this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
      }
    }
    writeU8(value) {
      this.maybeResize();
      this.buf.writeUInt8(value, this.length);
      this.length += 1;
    }
    writeU16(value) {
      this.maybeResize();
      this.buf.writeUInt16LE(value, this.length);
      this.length += 2;
    }
    writeU32(value) {
      this.maybeResize();
      this.buf.writeUInt32LE(value, this.length);
      this.length += 4;
    }
    writeU64(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
    }
    writeU128(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
    }
    writeU256(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
    }
    writeU512(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
    }
    writeBuffer(buffer) {
      this.buf = Buffer.concat([
        Buffer.from(this.buf.subarray(0, this.length)),
        buffer,
        Buffer.alloc(INITIAL_LENGTH)
      ]);
      this.length += buffer.length;
    }
    writeString(str) {
      this.maybeResize();
      const b = Buffer.from(str, "utf8");
      this.writeU32(b.length);
      this.writeBuffer(b);
    }
    writeFixedArray(array) {
      this.writeBuffer(Buffer.from(array));
    }
    writeArray(array, fn) {
      this.maybeResize();
      this.writeU32(array.length);
      for (const elem of array) {
        this.maybeResize();
        fn(elem);
      }
    }
    toArray() {
      return this.buf.subarray(0, this.length);
    }
  }
  exports.BinaryWriter = BinaryWriter;

  class BinaryReader {
    constructor(buf) {
      this.buf = buf;
      this.offset = 0;
    }
    readU8() {
      const value = this.buf.readUInt8(this.offset);
      this.offset += 1;
      return value;
    }
    readU16() {
      const value = this.buf.readUInt16LE(this.offset);
      this.offset += 2;
      return value;
    }
    readU32() {
      const value = this.buf.readUInt32LE(this.offset);
      this.offset += 4;
      return value;
    }
    readU64() {
      const buf = this.readBuffer(8);
      return new bn_js_1.default(buf, "le");
    }
    readU128() {
      const buf = this.readBuffer(16);
      return new bn_js_1.default(buf, "le");
    }
    readU256() {
      const buf = this.readBuffer(32);
      return new bn_js_1.default(buf, "le");
    }
    readU512() {
      const buf = this.readBuffer(64);
      return new bn_js_1.default(buf, "le");
    }
    readBuffer(len) {
      if (this.offset + len > this.buf.length) {
        throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
      }
      const result = this.buf.slice(this.offset, this.offset + len);
      this.offset += len;
      return result;
    }
    readString() {
      const len = this.readU32();
      const buf = this.readBuffer(len);
      try {
        return textDecoder.decode(buf);
      } catch (e) {
        throw new BorshError(`Error decoding UTF-8 string: ${e}`);
      }
    }
    readFixedArray(len) {
      return new Uint8Array(this.readBuffer(len));
    }
    readArray(fn) {
      const len = this.readU32();
      const result = Array();
      for (let i = 0;i < len; ++i) {
        result.push(fn());
      }
      return result;
    }
  }
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU8", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU16", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU32", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU64", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU128", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU256", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU512", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readString", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readFixedArray", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readArray", null);
  exports.BinaryReader = BinaryReader;
  exports.serialize = serialize;
  exports.deserialize = deserialize;
  exports.deserializeUnchecked = deserializeUnchecked;
});

// node_modules/@solana/buffer-layout/lib/Layout.js
var require_Layout = __commonJS((exports) => {
  var checkUint8Array = function(b) {
    if (!(b instanceof Uint8Array)) {
      throw new TypeError("b must be a Uint8Array");
    }
  };
  var uint8ArrayToBuffer = function(b) {
    checkUint8Array(b);
    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
  };
  var nameWithProperty = function(name, lo) {
    if (lo.property) {
      return name + "[" + lo.property + "]";
    }
    return name;
  };
  var bindConstructorLayout = function(Class, layout) {
    if (typeof Class !== "function") {
      throw new TypeError("Class must be constructor");
    }
    if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
      throw new Error("Class is already bound to a layout");
    }
    if (!(layout && layout instanceof Layout)) {
      throw new TypeError("layout must be a Layout");
    }
    if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
      throw new Error("layout is already bound to a constructor");
    }
    Class.layout_ = layout;
    layout.boundConstructor_ = Class;
    layout.makeDestinationObject = () => new Class;
    Object.defineProperty(Class.prototype, "encode", {
      value(b, offset) {
        return layout.encode(this, b, offset);
      },
      writable: true
    });
    Object.defineProperty(Class, "decode", {
      value(b, offset) {
        return layout.decode(b, offset);
      },
      writable: true
    });
  };
  var divmodInt64 = function(src) {
    const hi32 = Math.floor(src / V2E32);
    const lo32 = src - hi32 * V2E32;
    return { hi32, lo32 };
  };
  var roundedInt64 = function(hi32, lo32) {
    return hi32 * V2E32 + lo32;
  };
  var fixBitwiseResult = function(v) {
    if (0 > v) {
      v += 4294967296;
    }
    return v;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = undefined;
  exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = undefined;
  var buffer_1 = __require("buffer");
  exports.checkUint8Array = checkUint8Array;
  exports.uint8ArrayToBuffer = uint8ArrayToBuffer;

  class Layout {
    constructor(span, property) {
      if (!Number.isInteger(span)) {
        throw new TypeError("span must be an integer");
      }
      this.span = span;
      this.property = property;
    }
    makeDestinationObject() {
      return {};
    }
    getSpan(b, offset) {
      if (0 > this.span) {
        throw new RangeError("indeterminate span");
      }
      return this.span;
    }
    replicate(property) {
      const rv = Object.create(this.constructor.prototype);
      Object.assign(rv, this);
      rv.property = property;
      return rv;
    }
    fromArray(values) {
      return;
    }
  }
  exports.Layout = Layout;
  exports.nameWithProperty = nameWithProperty;
  exports.bindConstructorLayout = bindConstructorLayout;

  class ExternalLayout extends Layout {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  }
  exports.ExternalLayout = ExternalLayout;

  class GreedyCount extends ExternalLayout {
    constructor(elementSpan = 1, property) {
      if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
        throw new TypeError("elementSpan must be a (positive) integer");
      }
      super(-1, property);
      this.elementSpan = elementSpan;
    }
    isCount() {
      return true;
    }
    decode(b, offset = 0) {
      checkUint8Array(b);
      const rem = b.length - offset;
      return Math.floor(rem / this.elementSpan);
    }
    encode(src, b, offset) {
      return 0;
    }
  }
  exports.GreedyCount = GreedyCount;

  class OffsetLayout extends ExternalLayout {
    constructor(layout, offset = 0, property) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (!Number.isInteger(offset)) {
        throw new TypeError("offset must be integer or undefined");
      }
      super(layout.span, property || layout.property);
      this.layout = layout;
      this.offset = offset;
    }
    isCount() {
      return this.layout instanceof UInt || this.layout instanceof UIntBE;
    }
    decode(b, offset = 0) {
      return this.layout.decode(b, offset + this.offset);
    }
    encode(src, b, offset = 0) {
      return this.layout.encode(src, b, offset + this.offset);
    }
  }
  exports.OffsetLayout = OffsetLayout;

  class UInt extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);
      return this.span;
    }
  }
  exports.UInt = UInt;

  class UIntBE extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);
      return this.span;
    }
  }
  exports.UIntBE = UIntBE;

  class Int extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);
      return this.span;
    }
  }
  exports.Int = Int;

  class IntBE extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);
      return this.span;
    }
  }
  exports.IntBE = IntBE;
  var V2E32 = Math.pow(2, 32);

  class NearUInt64 extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      const buffer = uint8ArrayToBuffer(b);
      const lo32 = buffer.readUInt32LE(offset);
      const hi32 = buffer.readUInt32LE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b, offset = 0) {
      const split = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b);
      buffer.writeUInt32LE(split.lo32, offset);
      buffer.writeUInt32LE(split.hi32, offset + 4);
      return 8;
    }
  }
  exports.NearUInt64 = NearUInt64;

  class NearUInt64BE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      const buffer = uint8ArrayToBuffer(b);
      const hi32 = buffer.readUInt32BE(offset);
      const lo32 = buffer.readUInt32BE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b, offset = 0) {
      const split = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b);
      buffer.writeUInt32BE(split.hi32, offset);
      buffer.writeUInt32BE(split.lo32, offset + 4);
      return 8;
    }
  }
  exports.NearUInt64BE = NearUInt64BE;

  class NearInt64 extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      const buffer = uint8ArrayToBuffer(b);
      const lo32 = buffer.readUInt32LE(offset);
      const hi32 = buffer.readInt32LE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b, offset = 0) {
      const split = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b);
      buffer.writeUInt32LE(split.lo32, offset);
      buffer.writeInt32LE(split.hi32, offset + 4);
      return 8;
    }
  }
  exports.NearInt64 = NearInt64;

  class NearInt64BE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      const buffer = uint8ArrayToBuffer(b);
      const hi32 = buffer.readInt32BE(offset);
      const lo32 = buffer.readUInt32BE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b, offset = 0) {
      const split = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b);
      buffer.writeInt32BE(split.hi32, offset);
      buffer.writeUInt32BE(split.lo32, offset + 4);
      return 8;
    }
  }
  exports.NearInt64BE = NearInt64BE;

  class Float extends Layout {
    constructor(property) {
      super(4, property);
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readFloatLE(offset);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeFloatLE(src, offset);
      return 4;
    }
  }
  exports.Float = Float;

  class FloatBE extends Layout {
    constructor(property) {
      super(4, property);
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readFloatBE(offset);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeFloatBE(src, offset);
      return 4;
    }
  }
  exports.FloatBE = FloatBE;

  class Double extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readDoubleLE(offset);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeDoubleLE(src, offset);
      return 8;
    }
  }
  exports.Double = Double;

  class DoubleBE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readDoubleBE(offset);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeDoubleBE(src, offset);
      return 8;
    }
  }
  exports.DoubleBE = DoubleBE;

  class Sequence extends Layout {
    constructor(elementLayout, count, property) {
      if (!(elementLayout instanceof Layout)) {
        throw new TypeError("elementLayout must be a Layout");
      }
      if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
        throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
        span = count * elementLayout.span;
      }
      super(span, property);
      this.elementLayout = elementLayout;
      this.count = count;
    }
    getSpan(b, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let span = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b, offset);
      }
      if (0 < this.elementLayout.span) {
        span = count * this.elementLayout.span;
      } else {
        let idx = 0;
        while (idx < count) {
          span += this.elementLayout.getSpan(b, offset + span);
          ++idx;
        }
      }
      return span;
    }
    decode(b, offset = 0) {
      const rv = [];
      let i = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b, offset);
      }
      while (i < count) {
        rv.push(this.elementLayout.decode(b, offset));
        offset += this.elementLayout.getSpan(b, offset);
        i += 1;
      }
      return rv;
    }
    encode(src, b, offset = 0) {
      const elo = this.elementLayout;
      const span = src.reduce((span2, v) => {
        return span2 + elo.encode(v, b, offset + span2);
      }, 0);
      if (this.count instanceof ExternalLayout) {
        this.count.encode(src.length, b, offset);
      }
      return span;
    }
  }
  exports.Sequence = Sequence;

  class Structure extends Layout {
    constructor(fields, property, decodePrefixes) {
      if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {
        throw new TypeError("fields must be array of Layout instances");
      }
      if (typeof property === "boolean" && decodePrefixes === undefined) {
        decodePrefixes = property;
        property = undefined;
      }
      for (const fd of fields) {
        if (0 > fd.span && fd.property === undefined) {
          throw new Error("fields cannot contain unnamed variable-length layout");
        }
      }
      let span = -1;
      try {
        span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
      } catch (e) {
      }
      super(span, property);
      this.fields = fields;
      this.decodePrefixes = !!decodePrefixes;
    }
    getSpan(b, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let span = 0;
      try {
        span = this.fields.reduce((span2, fd) => {
          const fsp = fd.getSpan(b, offset);
          offset += fsp;
          return span2 + fsp;
        }, 0);
      } catch (e) {
        throw new RangeError("indeterminate span");
      }
      return span;
    }
    decode(b, offset = 0) {
      checkUint8Array(b);
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          dest[fd.property] = fd.decode(b, offset);
        }
        offset += fd.getSpan(b, offset);
        if (this.decodePrefixes && b.length === offset) {
          break;
        }
      }
      return dest;
    }
    encode(src, b, offset = 0) {
      const firstOffset = offset;
      let lastOffset = 0;
      let lastWrote = 0;
      for (const fd of this.fields) {
        let span = fd.span;
        lastWrote = 0 < span ? span : 0;
        if (fd.property !== undefined) {
          const fv = src[fd.property];
          if (fv !== undefined) {
            lastWrote = fd.encode(fv, b, offset);
            if (0 > span) {
              span = fd.getSpan(b, offset);
            }
          }
        }
        lastOffset = offset;
        offset += span;
      }
      return lastOffset + lastWrote - firstOffset;
    }
    fromArray(values) {
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (fd.property !== undefined && 0 < values.length) {
          dest[fd.property] = values.shift();
        }
      }
      return dest;
    }
    layoutFor(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
      return;
    }
    offsetOf(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      let offset = 0;
      for (const fd of this.fields) {
        if (fd.property === property) {
          return offset;
        }
        if (0 > fd.span) {
          offset = -1;
        } else if (0 <= offset) {
          offset += fd.span;
        }
      }
      return;
    }
  }
  exports.Structure = Structure;

  class UnionDiscriminator {
    constructor(property) {
      this.property = property;
    }
    decode(b, offset) {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode(src, b, offset) {
      throw new Error("UnionDiscriminator is abstract");
    }
  }
  exports.UnionDiscriminator = UnionDiscriminator;

  class UnionLayoutDiscriminator extends UnionDiscriminator {
    constructor(layout, property) {
      if (!(layout instanceof ExternalLayout && layout.isCount())) {
        throw new TypeError("layout must be an unsigned integer ExternalLayout");
      }
      super(property || layout.property || "variant");
      this.layout = layout;
    }
    decode(b, offset) {
      return this.layout.decode(b, offset);
    }
    encode(src, b, offset) {
      return this.layout.encode(src, b, offset);
    }
  }
  exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;

  class Union extends Layout {
    constructor(discr, defaultLayout, property) {
      let discriminator;
      if (discr instanceof UInt || discr instanceof UIntBE) {
        discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
      } else if (discr instanceof ExternalLayout && discr.isCount()) {
        discriminator = new UnionLayoutDiscriminator(discr);
      } else if (!(discr instanceof UnionDiscriminator)) {
        throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
      } else {
        discriminator = discr;
      }
      if (defaultLayout === undefined) {
        defaultLayout = null;
      }
      if (!(defaultLayout === null || defaultLayout instanceof Layout)) {
        throw new TypeError("defaultLayout must be null or a Layout");
      }
      if (defaultLayout !== null) {
        if (0 > defaultLayout.span) {
          throw new Error("defaultLayout must have constant span");
        }
        if (defaultLayout.property === undefined) {
          defaultLayout = defaultLayout.replicate("content");
        }
      }
      let span = -1;
      if (defaultLayout) {
        span = defaultLayout.span;
        if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
          span += discriminator.layout.span;
        }
      }
      super(span, property);
      this.discriminator = discriminator;
      this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
      this.defaultLayout = defaultLayout;
      this.registry = {};
      let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
      this.getSourceVariant = function(src) {
        return boundGetSourceVariant(src);
      };
      this.configGetSourceVariant = function(gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };
    }
    getSpan(b, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      const vlo = this.getVariant(b, offset);
      if (!vlo) {
        throw new Error("unable to determine span for unrecognized variant");
      }
      return vlo.getSpan(b, offset);
    }
    defaultGetSourceVariant(src) {
      if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
        if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
          return;
        }
        const vlo = this.registry[src[this.discriminator.property]];
        if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
          return vlo;
        }
      } else {
        for (const tag in this.registry) {
          const vlo = this.registry[tag];
          if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
            return vlo;
          }
        }
      }
      throw new Error("unable to infer src variant");
    }
    decode(b, offset = 0) {
      let dest;
      const dlo = this.discriminator;
      const discr = dlo.decode(b, offset);
      const clo = this.registry[discr];
      if (clo === undefined) {
        const defaultLayout = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dest = this.makeDestinationObject();
        dest[dlo.property] = discr;
        dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);
      } else {
        dest = clo.decode(b, offset);
      }
      return dest;
    }
    encode(src, b, offset = 0) {
      const vlo = this.getSourceVariant(src);
      if (vlo === undefined) {
        const dlo = this.discriminator;
        const clo = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dlo.encode(src[dlo.property], b, offset);
        return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
      }
      return vlo.encode(src, b, offset);
    }
    addVariant(variant, layout, property) {
      const rv = new VariantLayout(this, variant, layout, property);
      this.registry[variant] = rv;
      return rv;
    }
    getVariant(vb, offset = 0) {
      let variant;
      if (vb instanceof Uint8Array) {
        variant = this.discriminator.decode(vb, offset);
      } else {
        variant = vb;
      }
      return this.registry[variant];
    }
  }
  exports.Union = Union;

  class VariantLayout extends Layout {
    constructor(union, variant, layout, property) {
      if (!(union instanceof Union)) {
        throw new TypeError("union must be a Union");
      }
      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError("variant must be a (non-negative) integer");
      }
      if (typeof layout === "string" && property === undefined) {
        property = layout;
        layout = null;
      }
      if (layout) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (union.defaultLayout !== null && 0 <= layout.span && layout.span > union.defaultLayout.span) {
          throw new Error("variant span exceeds span of containing union");
        }
        if (typeof property !== "string") {
          throw new TypeError("variant must have a String property");
        }
      }
      let span = union.span;
      if (0 > union.span) {
        span = layout ? layout.span : 0;
        if (0 <= span && union.usesPrefixDiscriminator) {
          span += union.discriminator.layout.span;
        }
      }
      super(span, property);
      this.union = union;
      this.variant = variant;
      this.layout = layout || null;
    }
    getSpan(b, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      let span = 0;
      if (this.layout) {
        span = this.layout.getSpan(b, offset + contentOffset);
      }
      return contentOffset + span;
    }
    decode(b, offset = 0) {
      const dest = this.makeDestinationObject();
      if (this !== this.union.getVariant(b, offset)) {
        throw new Error("variant mismatch");
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout) {
        dest[this.property] = this.layout.decode(b, offset + contentOffset);
      } else if (this.property) {
        dest[this.property] = true;
      } else if (this.union.usesPrefixDiscriminator) {
        dest[this.union.discriminator.property] = this.variant;
      }
      return dest;
    }
    encode(src, b, offset = 0) {
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
        throw new TypeError("variant lacks property " + this.property);
      }
      this.union.discriminator.encode(this.variant, b, offset);
      let span = contentOffset;
      if (this.layout) {
        this.layout.encode(src[this.property], b, offset + contentOffset);
        span += this.layout.getSpan(b, offset + contentOffset);
        if (0 <= this.union.span && span > this.union.span) {
          throw new Error("encoded variant overruns containing union");
        }
      }
      return span;
    }
    fromArray(values) {
      if (this.layout) {
        return this.layout.fromArray(values);
      }
      return;
    }
  }
  exports.VariantLayout = VariantLayout;

  class BitStructure extends Layout {
    constructor(word, msb, property) {
      if (!(word instanceof UInt || word instanceof UIntBE)) {
        throw new TypeError("word must be a UInt or UIntBE layout");
      }
      if (typeof msb === "string" && property === undefined) {
        property = msb;
        msb = false;
      }
      if (4 < word.span) {
        throw new RangeError("word cannot exceed 32 bits");
      }
      super(word.span, property);
      this.word = word;
      this.msb = !!msb;
      this.fields = [];
      let value = 0;
      this._packedSetValue = function(v) {
        value = fixBitwiseResult(v);
        return this;
      };
      this._packedGetValue = function() {
        return value;
      };
    }
    decode(b, offset = 0) {
      const dest = this.makeDestinationObject();
      const value = this.word.decode(b, offset);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          dest[fd.property] = fd.decode(b);
        }
      }
      return dest;
    }
    encode(src, b, offset = 0) {
      const value = this.word.decode(b, offset);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          const fv = src[fd.property];
          if (fv !== undefined) {
            fd.encode(fv);
          }
        }
      }
      return this.word.encode(this._packedGetValue(), b, offset);
    }
    addField(bits, property) {
      const bf = new BitField(this, bits, property);
      this.fields.push(bf);
      return bf;
    }
    addBoolean(property) {
      const bf = new Boolean2(this, property);
      this.fields.push(bf);
      return bf;
    }
    fieldFor(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
      return;
    }
  }
  exports.BitStructure = BitStructure;

  class BitField {
    constructor(container, bits, property) {
      if (!(container instanceof BitStructure)) {
        throw new TypeError("container must be a BitStructure");
      }
      if (!Number.isInteger(bits) || 0 >= bits) {
        throw new TypeError("bits must be positive integer");
      }
      const totalBits = 8 * container.span;
      const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
      if (bits + usedBits > totalBits) {
        throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
      }
      this.container = container;
      this.bits = bits;
      this.valueMask = (1 << bits) - 1;
      if (bits === 32) {
        this.valueMask = 4294967295;
      }
      this.start = usedBits;
      if (this.container.msb) {
        this.start = totalBits - usedBits - bits;
      }
      this.wordMask = fixBitwiseResult(this.valueMask << this.start);
      this.property = property;
    }
    decode(b, offset) {
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(word & this.wordMask);
      const value = wordValue >>> this.start;
      return value;
    }
    encode(value) {
      if (typeof value !== "number" || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
        throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
      }
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(value << this.start);
      this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
    }
  }
  exports.BitField = BitField;

  class Boolean2 extends BitField {
    constructor(container, property) {
      super(container, 1, property);
    }
    decode(b, offset) {
      return !!super.decode(b, offset);
    }
    encode(value) {
      if (typeof value === "boolean") {
        value = +value;
      }
      super.encode(value);
    }
  }
  exports.Boolean = Boolean2;

  class Blob extends Layout {
    constructor(length, property) {
      if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(length instanceof ExternalLayout)) {
        span = length;
      }
      super(span, property);
      this.length = length;
    }
    getSpan(b, offset) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b, offset);
      }
      return span;
    }
    decode(b, offset = 0) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b, offset);
      }
      return uint8ArrayToBuffer(b).slice(offset, offset + span);
    }
    encode(src, b, offset) {
      let span = this.length;
      if (this.length instanceof ExternalLayout) {
        span = src.length;
      }
      if (!(src instanceof Uint8Array && span === src.length)) {
        throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
      }
      if (offset + span > b.length) {
        throw new RangeError("encoding overruns Uint8Array");
      }
      const srcBuffer = uint8ArrayToBuffer(src);
      uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset, span, "hex");
      if (this.length instanceof ExternalLayout) {
        this.length.encode(span, b, offset);
      }
      return span;
    }
  }
  exports.Blob = Blob;

  class CString extends Layout {
    constructor(property) {
      super(-1, property);
    }
    getSpan(b, offset = 0) {
      checkUint8Array(b);
      let idx = offset;
      while (idx < b.length && b[idx] !== 0) {
        idx += 1;
      }
      return 1 + idx - offset;
    }
    decode(b, offset = 0) {
      const span = this.getSpan(b, offset);
      return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString("utf-8");
    }
    encode(src, b, offset = 0) {
      if (typeof src !== "string") {
        src = String(src);
      }
      const srcb = buffer_1.Buffer.from(src, "utf8");
      const span = srcb.length;
      if (offset + span > b.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      const buffer = uint8ArrayToBuffer(b);
      srcb.copy(buffer, offset);
      buffer[offset + span] = 0;
      return span + 1;
    }
  }
  exports.CString = CString;

  class UTF8 extends Layout {
    constructor(maxSpan, property) {
      if (typeof maxSpan === "string" && property === undefined) {
        property = maxSpan;
        maxSpan = undefined;
      }
      if (maxSpan === undefined) {
        maxSpan = -1;
      } else if (!Number.isInteger(maxSpan)) {
        throw new TypeError("maxSpan must be an integer");
      }
      super(-1, property);
      this.maxSpan = maxSpan;
    }
    getSpan(b, offset = 0) {
      checkUint8Array(b);
      return b.length - offset;
    }
    decode(b, offset = 0) {
      const span = this.getSpan(b, offset);
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      return uint8ArrayToBuffer(b).slice(offset, offset + span).toString("utf-8");
    }
    encode(src, b, offset = 0) {
      if (typeof src !== "string") {
        src = String(src);
      }
      const srcb = buffer_1.Buffer.from(src, "utf8");
      const span = srcb.length;
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      if (offset + span > b.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      srcb.copy(uint8ArrayToBuffer(b), offset);
      return span;
    }
  }
  exports.UTF8 = UTF8;

  class Constant extends Layout {
    constructor(value, property) {
      super(0, property);
      this.value = value;
    }
    decode(b, offset) {
      return this.value;
    }
    encode(src, b, offset) {
      return 0;
    }
  }
  exports.Constant = Constant;
  exports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
  exports.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);
  exports.u8 = (property) => new UInt(1, property);
  exports.u16 = (property) => new UInt(2, property);
  exports.u24 = (property) => new UInt(3, property);
  exports.u32 = (property) => new UInt(4, property);
  exports.u40 = (property) => new UInt(5, property);
  exports.u48 = (property) => new UInt(6, property);
  exports.nu64 = (property) => new NearUInt64(property);
  exports.u16be = (property) => new UIntBE(2, property);
  exports.u24be = (property) => new UIntBE(3, property);
  exports.u32be = (property) => new UIntBE(4, property);
  exports.u40be = (property) => new UIntBE(5, property);
  exports.u48be = (property) => new UIntBE(6, property);
  exports.nu64be = (property) => new NearUInt64BE(property);
  exports.s8 = (property) => new Int(1, property);
  exports.s16 = (property) => new Int(2, property);
  exports.s24 = (property) => new Int(3, property);
  exports.s32 = (property) => new Int(4, property);
  exports.s40 = (property) => new Int(5, property);
  exports.s48 = (property) => new Int(6, property);
  exports.ns64 = (property) => new NearInt64(property);
  exports.s16be = (property) => new IntBE(2, property);
  exports.s24be = (property) => new IntBE(3, property);
  exports.s32be = (property) => new IntBE(4, property);
  exports.s40be = (property) => new IntBE(5, property);
  exports.s48be = (property) => new IntBE(6, property);
  exports.ns64be = (property) => new NearInt64BE(property);
  exports.f32 = (property) => new Float(property);
  exports.f32be = (property) => new FloatBE(property);
  exports.f64 = (property) => new Double(property);
  exports.f64be = (property) => new DoubleBE(property);
  exports.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
  exports.bits = (word, msb, property) => new BitStructure(word, msb, property);
  exports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
  exports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
  exports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
  exports.blob = (length, property) => new Blob(length, property);
  exports.cstr = (property) => new CString(property);
  exports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
  exports.constant = (value, property) => new Constant(value, property);
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS((exports, module) => {
  var fileUriToPath = function(uri) {
    if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
      throw new TypeError("must pass in a file:// URI to convert to a file path");
    }
    var rest = decodeURI(uri.substring(7));
    var firstSlash = rest.indexOf("/");
    var host = rest.substring(0, firstSlash);
    var path = rest.substring(firstSlash + 1);
    if (host == "localhost")
      host = "";
    if (host) {
      host = sep + sep + host;
    }
    path = path.replace(/^(.+)\|/, "$1:");
    if (sep == "\\") {
      path = path.replace(/\//g, "\\");
    }
    if (/^.+\:/.test(path)) {
    } else {
      path = sep + path;
    }
    return host + path;
  };
  var sep = __require("path").sep || "/";
  module.exports = fileUriToPath;
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS((exports, module) => {
  var bindings = function(opts) {
    if (typeof opts == "string") {
      opts = { bindings: opts };
    } else if (!opts) {
      opts = {};
    }
    Object.keys(defaults).map(function(i2) {
      if (!(i2 in opts))
        opts[i2] = defaults[i2];
    });
    if (!opts.module_root) {
      opts.module_root = exports.getRoot(exports.getFileName());
    }
    if (path.extname(opts.bindings) != ".node") {
      opts.bindings += ".node";
    }
    var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var tries = [], i = 0, l = opts.try.length, n, b, err;
    for (;i < l; i++) {
      n = join.apply(null, opts.try[i].map(function(p) {
        return opts[p] || p;
      }));
      tries.push(n);
      try {
        b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
        if (!opts.path) {
          b.path = n;
        }
        return b;
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
          throw e;
        }
      }
    }
    err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
      return opts.arrow + a;
    }).join("\n"));
    err.tries = tries;
    throw err;
  };
  var __filename = "/Users/ppegu/Projects/Raydium/RaydiumSwapBot/node_modules/bindings/bindings.js";
  var fs = __require("fs");
  var path = __require("path");
  var fileURLToPath = require_file_uri_to_path();
  var join = path.join;
  var dirname = path.dirname;
  var exists = fs.accessSync && function(path2) {
    try {
      fs.accessSync(path2);
    } catch (e) {
      return false;
    }
    return true;
  } || fs.existsSync || path.existsSync;
  var defaults = {
    arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
    platform: process.platform,
    arch: process.arch,
    nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
    version: process.versions.node,
    bindings: "bindings.node",
    try: [
      ["module_root", "build", "bindings"],
      ["module_root", "build", "Debug", "bindings"],
      ["module_root", "build", "Release", "bindings"],
      ["module_root", "out", "Debug", "bindings"],
      ["module_root", "Debug", "bindings"],
      ["module_root", "out", "Release", "bindings"],
      ["module_root", "Release", "bindings"],
      ["module_root", "build", "default", "bindings"],
      ["module_root", "compiled", "version", "platform", "arch", "bindings"],
      ["module_root", "addon-build", "release", "install-root", "bindings"],
      ["module_root", "addon-build", "debug", "install-root", "bindings"],
      ["module_root", "addon-build", "default", "install-root", "bindings"],
      ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
    ]
  };
  module.exports = exports = bindings;
  exports.getFileName = function getFileName(calling_file) {
    var { prepareStackTrace: origPST, stackTraceLimit: origSTL } = Error, dummy = {}, fileName;
    Error.stackTraceLimit = 10;
    Error.prepareStackTrace = function(e, st) {
      for (var i = 0, l = st.length;i < l; i++) {
        fileName = st[i].getFileName();
        if (fileName !== __filename) {
          if (calling_file) {
            if (fileName !== calling_file) {
              return;
            }
          } else {
            return;
          }
        }
      }
    };
    Error.captureStackTrace(dummy);
    dummy.stack;
    Error.prepareStackTrace = origPST;
    Error.stackTraceLimit = origSTL;
    var fileSchema = "file://";
    if (fileName.indexOf(fileSchema) === 0) {
      fileName = fileURLToPath(fileName);
    }
    return fileName;
  };
  exports.getRoot = function getRoot(file) {
    var dir = dirname(file), prev;
    while (true) {
      if (dir === ".") {
        dir = process.cwd();
      }
      if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
        return dir;
      }
      if (prev === dir) {
        throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
      }
      prev = dir;
      dir = join(dir, "..");
    }
  };
});

// node_modules/bigint-buffer/dist/node.js
var require_node = __commonJS((exports) => {
  var toBigIntLE = function(buf) {
    if (converter === undefined) {
      const reversed = Buffer.from(buf);
      reversed.reverse();
      const hex = reversed.toString("hex");
      if (hex.length === 0) {
        return BigInt(0);
      }
      return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, false);
  };
  var toBigIntBE = function(buf) {
    if (converter === undefined) {
      const hex = buf.toString("hex");
      if (hex.length === 0) {
        return BigInt(0);
      }
      return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, true);
  };
  var toBufferLE = function(num, width) {
    if (converter === undefined) {
      const hex = num.toString(16);
      const buffer = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
      buffer.reverse();
      return buffer;
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
  };
  var toBufferBE = function(num, width) {
    if (converter === undefined) {
      const hex = num.toString(16);
      return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var converter;
  {
    try {
      converter = require_bindings()("bigint_buffer");
    } catch (e) {
      console.warn("bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)");
    }
  }
  exports.toBigIntLE = toBigIntLE;
  exports.toBigIntBE = toBigIntBE;
  exports.toBufferLE = toBufferLE;
  exports.toBufferBE = toBufferBE;
});

// node_modules/superstruct/lib/index.cjs
var require_lib2 = __commonJS((exports) => {
  var isIterable = function(x) {
    return isObject(x) && typeof x[Symbol.iterator] === "function";
  };
  var isObject = function(x) {
    return typeof x === "object" && x != null;
  };
  var isPlainObject = function(x) {
    if (Object.prototype.toString.call(x) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(x);
    return prototype === null || prototype === Object.prototype;
  };
  var print = function(value) {
    return typeof value === "string" ? JSON.stringify(value) : "" + value;
  };
  var shiftIterator = function(input) {
    const {
      done,
      value
    } = input.next();
    return done ? undefined : value;
  };
  var toFailure = function(result, context, struct2, value) {
    if (result === true) {
      return;
    } else if (result === false) {
      result = {};
    } else if (typeof result === "string") {
      result = {
        message: result
      };
    }
    const {
      path,
      branch
    } = context;
    const {
      type: type2
    } = struct2;
    const {
      refinement,
      message = "Expected a value of type `" + type2 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print(value) + "`"
    } = result;
    return {
      value,
      type: type2,
      refinement,
      key: path[path.length - 1],
      path,
      branch,
      ...result,
      message
    };
  };
  function* toFailures(result, context, struct2, value) {
    if (!isIterable(result)) {
      result = [result];
    }
    for (const r of result) {
      const failure = toFailure(r, context, struct2, value);
      if (failure) {
        yield failure;
      }
    }
  }
  function* run(value, struct2, options = {}) {
    const {
      path = [],
      branch = [value],
      coerce: coerce2 = false,
      mask: mask2 = false
    } = options;
    const ctx = {
      path,
      branch
    };
    if (coerce2) {
      value = struct2.coercer(value, ctx);
      if (mask2 && struct2.type !== "type" && isObject(struct2.schema) && isObject(value) && !Array.isArray(value)) {
        for (const key in value) {
          if (struct2.schema[key] === undefined) {
            delete value[key];
          }
        }
      }
    }
    let valid = true;
    for (const failure of struct2.validator(value, ctx)) {
      valid = false;
      yield [failure, undefined];
    }
    for (let [k, v, s] of struct2.entries(value, ctx)) {
      const ts = run(v, s, {
        path: k === undefined ? path : [...path, k],
        branch: k === undefined ? branch : [...branch, v],
        coerce: coerce2,
        mask: mask2
      });
      for (const t of ts) {
        if (t[0]) {
          valid = false;
          yield [t[0], undefined];
        } else if (coerce2) {
          v = t[1];
          if (k === undefined) {
            value = v;
          } else if (value instanceof Map) {
            value.set(k, v);
          } else if (value instanceof Set) {
            value.add(v);
          } else if (isObject(value)) {
            value[k] = v;
          }
        }
      }
    }
    if (valid) {
      for (const failure of struct2.refiner(value, ctx)) {
        valid = false;
        yield [failure, undefined];
      }
    }
    if (valid) {
      yield [undefined, value];
    }
  }
  var assert = function(value, struct2) {
    const result = validate(value, struct2);
    if (result[0]) {
      throw result[0];
    }
  };
  var create = function(value, struct2) {
    const result = validate(value, struct2, {
      coerce: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  };
  var mask = function(value, struct2) {
    const result = validate(value, struct2, {
      coerce: true,
      mask: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  };
  var is = function(value, struct2) {
    const result = validate(value, struct2);
    return !result[0];
  };
  var validate = function(value, struct2, options = {}) {
    const tuples = run(value, struct2, options);
    const tuple2 = shiftIterator(tuples);
    if (tuple2[0]) {
      const error = new StructError(tuple2[0], function* () {
        for (const t of tuples) {
          if (t[0]) {
            yield t[0];
          }
        }
      });
      return [error, undefined];
    } else {
      const v = tuple2[1];
      return [undefined, v];
    }
  };
  var assign = function(...Structs) {
    const schemas = Structs.map((s) => s.schema);
    const schema = Object.assign({}, ...schemas);
    return object(schema);
  };
  var define2 = function(name, validator) {
    return new Struct({
      type: name,
      schema: null,
      validator
    });
  };
  var deprecated = function(struct2, log) {
    return new Struct({
      ...struct2,
      refiner: (value, ctx) => value === undefined || struct2.refiner(value, ctx),
      validator(value, ctx) {
        if (value === undefined) {
          return true;
        } else {
          log(value, ctx);
          return struct2.validator(value, ctx);
        }
      }
    });
  };
  var dynamic = function(fn) {
    return new Struct({
      type: "dynamic",
      schema: null,
      *entries(value, ctx) {
        const struct2 = fn(value, ctx);
        yield* struct2.entries(value, ctx);
      },
      validator(value, ctx) {
        const struct2 = fn(value, ctx);
        return struct2.validator(value, ctx);
      },
      coercer(value, ctx) {
        const struct2 = fn(value, ctx);
        return struct2.coercer(value, ctx);
      }
    });
  };
  var lazy = function(fn) {
    let struct2;
    return new Struct({
      type: "lazy",
      schema: null,
      *entries(value, ctx) {
        var _struct;
        (_struct = struct2) != null || (struct2 = fn());
        yield* struct2.entries(value, ctx);
      },
      validator(value, ctx) {
        var _struct2;
        (_struct2 = struct2) != null || (struct2 = fn());
        return struct2.validator(value, ctx);
      },
      coercer(value, ctx) {
        var _struct3;
        (_struct3 = struct2) != null || (struct2 = fn());
        return struct2.coercer(value, ctx);
      }
    });
  };
  var omit = function(struct2, keys) {
    const {
      schema
    } = struct2;
    const subschema = {
      ...schema
    };
    for (const key of keys) {
      delete subschema[key];
    }
    return object(subschema);
  };
  var partial = function(struct2) {
    const schema = struct2 instanceof Struct ? {
      ...struct2.schema
    } : {
      ...struct2
    };
    for (const key in schema) {
      schema[key] = optional(schema[key]);
    }
    return object(schema);
  };
  var pick = function(struct2, keys) {
    const {
      schema
    } = struct2;
    const subschema = {};
    for (const key of keys) {
      subschema[key] = schema[key];
    }
    return object(subschema);
  };
  var struct = function(name, validator) {
    console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");
    return define2(name, validator);
  };
  var any = function() {
    return define2("any", () => true);
  };
  var array = function(Element) {
    return new Struct({
      type: "array",
      schema: Element,
      *entries(value) {
        if (Element && Array.isArray(value)) {
          for (const [i, v] of value.entries()) {
            yield [i, v, Element];
          }
        }
      },
      coercer(value) {
        return Array.isArray(value) ? value.slice() : value;
      },
      validator(value) {
        return Array.isArray(value) || "Expected an array value, but received: " + print(value);
      }
    });
  };
  var boolean = function() {
    return define2("boolean", (value) => {
      return typeof value === "boolean";
    });
  };
  var date = function() {
    return define2("date", (value) => {
      return value instanceof Date && !isNaN(value.getTime()) || "Expected a valid `Date` object, but received: " + print(value);
    });
  };
  var enums = function(values) {
    const schema = {};
    const description = values.map((v) => print(v)).join();
    for (const key of values) {
      schema[key] = key;
    }
    return new Struct({
      type: "enums",
      schema,
      validator(value) {
        return values.includes(value) || "Expected one of `" + description + "`, but received: " + print(value);
      }
    });
  };
  var func = function() {
    return define2("func", (value) => {
      return typeof value === "function" || "Expected a function, but received: " + print(value);
    });
  };
  var instance = function(Class) {
    return define2("instance", (value) => {
      return value instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print(value);
    });
  };
  var integer = function() {
    return define2("integer", (value) => {
      return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || "Expected an integer, but received: " + print(value);
    });
  };
  var intersection = function(Structs) {
    return new Struct({
      type: "intersection",
      schema: null,
      *entries(value, ctx) {
        for (const S of Structs) {
          yield* S.entries(value, ctx);
        }
      },
      *validator(value, ctx) {
        for (const S of Structs) {
          yield* S.validator(value, ctx);
        }
      },
      *refiner(value, ctx) {
        for (const S of Structs) {
          yield* S.refiner(value, ctx);
        }
      }
    });
  };
  var literal = function(constant) {
    const description = print(constant);
    const t = typeof constant;
    return new Struct({
      type: "literal",
      schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
      validator(value) {
        return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
      }
    });
  };
  var map = function(Key, Value) {
    return new Struct({
      type: "map",
      schema: null,
      *entries(value) {
        if (Key && Value && value instanceof Map) {
          for (const [k, v] of value.entries()) {
            yield [k, k, Key];
            yield [k, v, Value];
          }
        }
      },
      coercer(value) {
        return value instanceof Map ? new Map(value) : value;
      },
      validator(value) {
        return value instanceof Map || "Expected a `Map` object, but received: " + print(value);
      }
    });
  };
  var never = function() {
    return define2("never", () => false);
  };
  var nullable = function(struct2) {
    return new Struct({
      ...struct2,
      validator: (value, ctx) => value === null || struct2.validator(value, ctx),
      refiner: (value, ctx) => value === null || struct2.refiner(value, ctx)
    });
  };
  var number = function() {
    return define2("number", (value) => {
      return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print(value);
    });
  };
  var object = function(schema) {
    const knowns = schema ? Object.keys(schema) : [];
    const Never = never();
    return new Struct({
      type: "object",
      schema: schema ? schema : null,
      *entries(value) {
        if (schema && isObject(value)) {
          const unknowns = new Set(Object.keys(value));
          for (const key of knowns) {
            unknowns.delete(key);
            yield [key, value[key], schema[key]];
          }
          for (const key of unknowns) {
            yield [key, value[key], Never];
          }
        }
      },
      validator(value) {
        return isObject(value) || "Expected an object, but received: " + print(value);
      },
      coercer(value) {
        return isObject(value) ? {
          ...value
        } : value;
      }
    });
  };
  var optional = function(struct2) {
    return new Struct({
      ...struct2,
      validator: (value, ctx) => value === undefined || struct2.validator(value, ctx),
      refiner: (value, ctx) => value === undefined || struct2.refiner(value, ctx)
    });
  };
  var record = function(Key, Value) {
    return new Struct({
      type: "record",
      schema: null,
      *entries(value) {
        if (isObject(value)) {
          for (const k in value) {
            const v = value[k];
            yield [k, k, Key];
            yield [k, v, Value];
          }
        }
      },
      validator(value) {
        return isObject(value) || "Expected an object, but received: " + print(value);
      }
    });
  };
  var regexp = function() {
    return define2("regexp", (value) => {
      return value instanceof RegExp;
    });
  };
  var set = function(Element) {
    return new Struct({
      type: "set",
      schema: null,
      *entries(value) {
        if (Element && value instanceof Set) {
          for (const v of value) {
            yield [v, v, Element];
          }
        }
      },
      coercer(value) {
        return value instanceof Set ? new Set(value) : value;
      },
      validator(value) {
        return value instanceof Set || "Expected a `Set` object, but received: " + print(value);
      }
    });
  };
  var string = function() {
    return define2("string", (value) => {
      return typeof value === "string" || "Expected a string, but received: " + print(value);
    });
  };
  var tuple = function(Elements) {
    const Never = never();
    return new Struct({
      type: "tuple",
      schema: null,
      *entries(value) {
        if (Array.isArray(value)) {
          const length = Math.max(Elements.length, value.length);
          for (let i = 0;i < length; i++) {
            yield [i, value[i], Elements[i] || Never];
          }
        }
      },
      validator(value) {
        return Array.isArray(value) || "Expected an array, but received: " + print(value);
      }
    });
  };
  var type = function(schema) {
    const keys = Object.keys(schema);
    return new Struct({
      type: "type",
      schema,
      *entries(value) {
        if (isObject(value)) {
          for (const k of keys) {
            yield [k, value[k], schema[k]];
          }
        }
      },
      validator(value) {
        return isObject(value) || "Expected an object, but received: " + print(value);
      }
    });
  };
  var union = function(Structs) {
    const description = Structs.map((s) => s.type).join(" | ");
    return new Struct({
      type: "union",
      schema: null,
      validator(value, ctx) {
        const failures = [];
        for (const S of Structs) {
          const [...tuples] = run(value, S, ctx);
          const [first] = tuples;
          if (!first[0]) {
            return [];
          } else {
            for (const [failure] of tuples) {
              if (failure) {
                failures.push(failure);
              }
            }
          }
        }
        return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
      }
    });
  };
  var unknown = function() {
    return define2("unknown", () => true);
  };
  var coerce = function(struct2, condition, coercer) {
    return new Struct({
      ...struct2,
      coercer: (value, ctx) => {
        return is(value, condition) ? struct2.coercer(coercer(value, ctx), ctx) : struct2.coercer(value, ctx);
      }
    });
  };
  var defaulted = function(struct2, fallback, options = {}) {
    return coerce(struct2, unknown(), (x) => {
      const f = typeof fallback === "function" ? fallback() : fallback;
      if (x === undefined) {
        return f;
      }
      if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
        const ret = {
          ...x
        };
        let changed = false;
        for (const key in f) {
          if (ret[key] === undefined) {
            ret[key] = f[key];
            changed = true;
          }
        }
        if (changed) {
          return ret;
        }
      }
      return x;
    });
  };
  var trimmed = function(struct2) {
    return coerce(struct2, string(), (x) => x.trim());
  };
  var empty = function(struct2) {
    const expected = "Expected an empty " + struct2.type;
    return refine(struct2, "empty", (value) => {
      if (value instanceof Map || value instanceof Set) {
        const {
          size: size2
        } = value;
        return size2 === 0 || expected + " but received one with a size of `" + size2 + "`";
      } else {
        const {
          length
        } = value;
        return length === 0 || expected + " but received one with a length of `" + length + "`";
      }
    });
  };
  var max = function(struct2, threshold, options = {}) {
    const {
      exclusive
    } = options;
    return refine(struct2, "max", (value) => {
      return exclusive ? value < threshold : value <= threshold || "Expected a " + struct2.type + " greater than " + (exclusive ? "" : "or equal to ") + threshold + " but received `" + value + "`";
    });
  };
  var min = function(struct2, threshold, options = {}) {
    const {
      exclusive
    } = options;
    return refine(struct2, "min", (value) => {
      return exclusive ? value > threshold : value >= threshold || "Expected a " + struct2.type + " greater than " + (exclusive ? "" : "or equal to ") + threshold + " but received `" + value + "`";
    });
  };
  var pattern = function(struct2, regexp2) {
    return refine(struct2, "pattern", (value) => {
      return regexp2.test(value) || "Expected a " + struct2.type + " matching `/" + regexp2.source + "/` but received \"" + value + "\"";
    });
  };
  var size = function(struct2, min2, max2 = min2) {
    const expected = "Expected a " + struct2.type;
    const of = min2 === max2 ? "of `" + min2 + "`" : "between `" + min2 + "` and `" + max2 + "`";
    return refine(struct2, "size", (value) => {
      if (typeof value === "number" || value instanceof Date) {
        return min2 <= value && value <= max2 || expected + " " + of + " but received `" + value + "`";
      } else if (value instanceof Map || value instanceof Set) {
        const {
          size: size2
        } = value;
        return min2 <= size2 && size2 <= max2 || expected + " with a size " + of + " but received one with a size of `" + size2 + "`";
      } else {
        const {
          length
        } = value;
        return min2 <= length && length <= max2 || expected + " with a length " + of + " but received one with a length of `" + length + "`";
      }
    });
  };
  var refine = function(struct2, name, refiner) {
    return new Struct({
      ...struct2,
      *refiner(value, ctx) {
        yield* struct2.refiner(value, ctx);
        const result = refiner(value, ctx);
        const failures = toFailures(result, ctx, struct2, value);
        for (const failure of failures) {
          yield {
            ...failure,
            refinement: name
          };
        }
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class StructError extends TypeError {
    constructor(failure, failures) {
      let cached;
      const {
        message,
        ...rest
      } = failure;
      const {
        path
      } = failure;
      const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
      super(msg);
      Object.assign(this, rest);
      this.name = this.constructor.name;
      this.failures = () => {
        var _cached;
        return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
      };
    }
  }

  class Struct {
    constructor(props) {
      const {
        type: type2,
        schema,
        validator,
        refiner,
        coercer = (value) => value,
        entries = function* () {
        }
      } = props;
      this.type = type2;
      this.schema = schema;
      this.entries = entries;
      this.coercer = coercer;
      if (validator) {
        this.validator = (value, context) => {
          const result = validator(value, context);
          return toFailures(result, context, this, value);
        };
      } else {
        this.validator = () => [];
      }
      if (refiner) {
        this.refiner = (value, context) => {
          const result = refiner(value, context);
          return toFailures(result, context, this, value);
        };
      } else {
        this.refiner = () => [];
      }
    }
    assert(value) {
      return assert(value, this);
    }
    create(value) {
      return create(value, this);
    }
    is(value) {
      return is(value, this);
    }
    mask(value) {
      return mask(value, this);
    }
    validate(value, options = {}) {
      return validate(value, this, options);
    }
  }
  exports.Struct = Struct;
  exports.StructError = StructError;
  exports.any = any;
  exports.array = array;
  exports.assert = assert;
  exports.assign = assign;
  exports.boolean = boolean;
  exports.coerce = coerce;
  exports.create = create;
  exports.date = date;
  exports.defaulted = defaulted;
  exports.define = define2;
  exports.deprecated = deprecated;
  exports.dynamic = dynamic;
  exports.empty = empty;
  exports.enums = enums;
  exports.func = func;
  exports.instance = instance;
  exports.integer = integer;
  exports.intersection = intersection;
  exports.is = is;
  exports.lazy = lazy;
  exports.literal = literal;
  exports.map = map;
  exports.mask = mask;
  exports.max = max;
  exports.min = min;
  exports.never = never;
  exports.nullable = nullable;
  exports.number = number;
  exports.object = object;
  exports.omit = omit;
  exports.optional = optional;
  exports.partial = partial;
  exports.pattern = pattern;
  exports.pick = pick;
  exports.record = record;
  exports.refine = refine;
  exports.regexp = regexp;
  exports.set = set;
  exports.size = size;
  exports.string = string;
  exports.struct = struct;
  exports.trimmed = trimmed;
  exports.tuple = tuple;
  exports.type = type;
  exports.union = union;
  exports.unknown = unknown;
  exports.validate = validate;
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validate = function(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate;
  exports.default = _default;
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringify = function(arr, offset = 0) {
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  var _default = stringify;
  exports.default = _default;
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v1 = function(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.default)(b);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify());
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v1;
  exports.default = _default;
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parse = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse;
  exports.default = _default;
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringToBytes = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  };
  var _default = function(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.default)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  exports.URL = exports.DNS = undefined;
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var md5 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = md5;
  exports.default = _default;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v4 = function(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.default)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify());
  var _default = v4;
  exports.default = _default;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var sha1 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var version = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version;
  exports.default = _default;
});

// node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
});

// node_modules/jayson/lib/generateRequest.js
var require_generateRequest = __commonJS((exports, module) => {
  var uuid = require_dist().v4;
  var generateRequest = function(method, params, id, options) {
    if (typeof method !== "string") {
      throw new TypeError(method + " must be a string");
    }
    options = options || {};
    const version = typeof options.version === "number" ? options.version : 2;
    if (version !== 1 && version !== 2) {
      throw new TypeError(version + " must be 1 or 2");
    }
    const request = {
      method
    };
    if (version === 2) {
      request.jsonrpc = "2.0";
    }
    if (params) {
      if (typeof params !== "object" && !Array.isArray(params)) {
        throw new TypeError(params + " must be an object, array or omitted");
      }
      request.params = params;
    }
    if (typeof id === "undefined") {
      const generator = typeof options.generator === "function" ? options.generator : function() {
        return uuid();
      };
      request.id = generator(request, options);
    } else if (version === 2 && id === null) {
      if (options.notificationIdNull) {
        request.id = null;
      }
    } else {
      request.id = id;
    }
    return request;
  };
  module.exports = generateRequest;
});

// node_modules/jayson/lib/client/browser/index.js
var require_browser = __commonJS((exports, module) => {
  var uuid = require_dist().v4;
  var generateRequest = require_generateRequest();
  var ClientBrowser = function(callServer, options) {
    if (!(this instanceof ClientBrowser)) {
      return new ClientBrowser(callServer, options);
    }
    if (!options) {
      options = {};
    }
    this.options = {
      reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
      replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
      generator: typeof options.generator !== "undefined" ? options.generator : function() {
        return uuid();
      },
      version: typeof options.version !== "undefined" ? options.version : 2,
      notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
    };
    this.callServer = callServer;
  };
  module.exports = ClientBrowser;
  ClientBrowser.prototype.request = function(method, params, id, callback) {
    const self2 = this;
    let request = null;
    const isBatch = Array.isArray(method) && typeof params === "function";
    if (this.options.version === 1 && isBatch) {
      throw new TypeError("JSON-RPC 1.0 does not support batching");
    }
    const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
    if (isBatch || isRaw) {
      callback = params;
      request = method;
    } else {
      if (typeof id === "function") {
        callback = id;
        id = undefined;
      }
      const hasCallback = typeof callback === "function";
      try {
        request = generateRequest(method, params, id, {
          generator: this.options.generator,
          version: this.options.version,
          notificationIdNull: this.options.notificationIdNull
        });
      } catch (err) {
        if (hasCallback) {
          return callback(err);
        }
        throw err;
      }
      if (!hasCallback) {
        return request;
      }
    }
    let message;
    try {
      message = JSON.stringify(request, this.options.replacer);
    } catch (err) {
      return callback(err);
    }
    this.callServer(message, function(err, response) {
      self2._parseResponse(err, response, callback);
    });
    return request;
  };
  ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
    if (err) {
      callback(err);
      return;
    }
    if (!responseText) {
      return callback();
    }
    let response;
    try {
      response = JSON.parse(responseText, this.options.reviver);
    } catch (err2) {
      return callback(err2);
    }
    if (callback.length === 3) {
      if (Array.isArray(response)) {
        const isError = function(res) {
          return typeof res.error !== "undefined";
        };
        const isNotError = function(res) {
          return !isError(res);
        };
        return callback(null, response.filter(isError), response.filter(isNotError));
      } else {
        return callback(null, response.error, response.result);
      }
    }
    callback(null, response);
  };
});

// node_modules/webidl-conversions/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var sign = function(x) {
    return x < 0 ? -1 : 1;
  };
  var evenRound = function(x) {
    if (x % 1 === 0.5 && (x & 1) === 0) {
      return Math.floor(x);
    } else {
      return Math.round(x);
    }
  };
  var createNumberConversion = function(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
      --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;
    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
    return function(V, opts) {
      if (!opts)
        opts = {};
      let x = +V;
      if (opts.enforceRange) {
        if (!Number.isFinite(x)) {
          throw new TypeError("Argument is not a finite number");
        }
        x = sign(x) * Math.floor(Math.abs(x));
        if (x < lowerBound || x > upperBound) {
          throw new TypeError("Argument is not in byte range");
        }
        return x;
      }
      if (!isNaN(x) && opts.clamp) {
        x = evenRound(x);
        if (x < lowerBound)
          x = lowerBound;
        if (x > upperBound)
          x = upperBound;
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      x = sign(x) * Math.floor(Math.abs(x));
      x = x % moduloVal;
      if (!typeOpts.unsigned && x >= moduloBound) {
        return x - moduloVal;
      } else if (typeOpts.unsigned) {
        if (x < 0) {
          x += moduloVal;
        } else if (x === -0) {
          return 0;
        }
      }
      return x;
    };
  };
  var conversions = {};
  module.exports = conversions;
  conversions["void"] = function() {
    return;
  };
  conversions["boolean"] = function(val) {
    return !!val;
  };
  conversions["byte"] = createNumberConversion(8, { unsigned: false });
  conversions["octet"] = createNumberConversion(8, { unsigned: true });
  conversions["short"] = createNumberConversion(16, { unsigned: false });
  conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
  conversions["long"] = createNumberConversion(32, { unsigned: false });
  conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
  conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
  conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
  conversions["double"] = function(V) {
    const x = +V;
    if (!Number.isFinite(x)) {
      throw new TypeError("Argument is not a finite floating-point value");
    }
    return x;
  };
  conversions["unrestricted double"] = function(V) {
    const x = +V;
    if (isNaN(x)) {
      throw new TypeError("Argument is NaN");
    }
    return x;
  };
  conversions["float"] = conversions["double"];
  conversions["unrestricted float"] = conversions["unrestricted double"];
  conversions["DOMString"] = function(V, opts) {
    if (!opts)
      opts = {};
    if (opts.treatNullAsEmptyString && V === null) {
      return "";
    }
    return String(V);
  };
  conversions["ByteString"] = function(V, opts) {
    const x = String(V);
    let c = undefined;
    for (let i = 0;(c = x.codePointAt(i)) !== undefined; ++i) {
      if (c > 255) {
        throw new TypeError("Argument is not a valid bytestring");
      }
    }
    return x;
  };
  conversions["USVString"] = function(V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for (let i = 0;i < n; ++i) {
      const c = S.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        U.push(String.fromCodePoint(c));
      } else if (56320 <= c && c <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else {
        if (i === n - 1) {
          U.push(String.fromCodePoint(65533));
        } else {
          const d = S.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            const a = c & 1023;
            const b = d & 1023;
            U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
            ++i;
          } else {
            U.push(String.fromCodePoint(65533));
          }
        }
      }
    }
    return U.join("");
  };
  conversions["Date"] = function(V, opts) {
    if (!(V instanceof Date)) {
      throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
      return;
    }
    return V;
  };
  conversions["RegExp"] = function(V, opts) {
    if (!(V instanceof RegExp)) {
      V = new RegExp(V);
    }
    return V;
  };
});

// node_modules/whatwg-url/lib/utils.js
var require_utils3 = __commonJS((exports, module) => {
  exports.mixin = function mixin(target, source) {
    const keys = Object.getOwnPropertyNames(source);
    for (let i = 0;i < keys.length; ++i) {
      Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
    }
  };
  exports.wrapperSymbol = Symbol("wrapper");
  exports.implSymbol = Symbol("impl");
  exports.wrapperForImpl = function(impl) {
    return impl[exports.wrapperSymbol];
  };
  exports.implForWrapper = function(wrapper) {
    return wrapper[exports.implSymbol];
  };
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS((exports, module) => {
  module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1000, 1000], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6000], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8000, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8000]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9000], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [30000]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13000, 13000], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43000, 43000], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64000, 64000], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66000, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[120000, 120000], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128000, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23000]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149000]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32000]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195000, 195000], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [40000]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918000, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS((exports, module) => {
  var normalize = function(str) {
    return str.split("\0").map(function(s) {
      return s.normalize("NFC");
    }).join("\0");
  };
  var findStatus = function(val) {
    var start = 0;
    var end = mappingTable.length - 1;
    while (start <= end) {
      var mid = Math.floor((start + end) / 2);
      var target = mappingTable[mid];
      if (target[0][0] <= val && target[0][1] >= val) {
        return target;
      } else if (target[0][0] > val) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  };
  var countSymbols = function(string) {
    return string.replace(regexAstralSymbols, "_").length;
  };
  var mapChars = function(domain_name, useSTD3, processing_option) {
    var hasError = false;
    var processed = "";
    var len = countSymbols(domain_name);
    for (var i = 0;i < len; ++i) {
      var codePoint = domain_name.codePointAt(i);
      var status = findStatus(codePoint);
      switch (status[1]) {
        case "disallowed":
          hasError = true;
          processed += String.fromCodePoint(codePoint);
          break;
        case "ignored":
          break;
        case "mapped":
          processed += String.fromCodePoint.apply(String, status[2]);
          break;
        case "deviation":
          if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
            processed += String.fromCodePoint.apply(String, status[2]);
          } else {
            processed += String.fromCodePoint(codePoint);
          }
          break;
        case "valid":
          processed += String.fromCodePoint(codePoint);
          break;
        case "disallowed_STD3_mapped":
          if (useSTD3) {
            hasError = true;
            processed += String.fromCodePoint(codePoint);
          } else {
            processed += String.fromCodePoint.apply(String, status[2]);
          }
          break;
        case "disallowed_STD3_valid":
          if (useSTD3) {
            hasError = true;
          }
          processed += String.fromCodePoint(codePoint);
          break;
      }
    }
    return {
      string: processed,
      error: hasError
    };
  };
  var validateLabel = function(label, processing_option) {
    if (label.substr(0, 4) === "xn--") {
      label = punycode.toUnicode(label);
      processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
    }
    var error = false;
    if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
      error = true;
    }
    var len = countSymbols(label);
    for (var i = 0;i < len; ++i) {
      var status = findStatus(label.codePointAt(i));
      if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
        error = true;
        break;
      }
    }
    return {
      label,
      error
    };
  };
  var processing = function(domain_name, useSTD3, processing_option) {
    var result = mapChars(domain_name, useSTD3, processing_option);
    result.string = normalize(result.string);
    var labels = result.string.split(".");
    for (var i = 0;i < labels.length; ++i) {
      try {
        var validation = validateLabel(labels[i]);
        labels[i] = validation.label;
        result.error = result.error || validation.error;
      } catch (e) {
        result.error = true;
      }
    }
    return {
      string: labels.join("."),
      error: result.error
    };
  };
  var punycode = __require("punycode");
  var mappingTable = require_mappingTable();
  var PROCESSING_OPTIONS = {
    TRANSITIONAL: 0,
    NONTRANSITIONAL: 1
  };
  var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
  exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
    var result = processing(domain_name, useSTD3, processing_option);
    var labels = result.string.split(".");
    labels = labels.map(function(l) {
      try {
        return punycode.toASCII(l);
      } catch (e) {
        result.error = true;
        return l;
      }
    });
    if (verifyDnsLength) {
      var total = labels.slice(0, labels.length - 1).join(".").length;
      if (total.length > 253 || total.length === 0) {
        result.error = true;
      }
      for (var i = 0;i < labels.length; ++i) {
        if (labels.length > 63 || labels.length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error)
      return null;
    return labels.join(".");
  };
  exports.toUnicode = function(domain_name, useSTD3) {
    var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
    return {
      domain: result.string,
      error: result.error
    };
  };
  exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS((exports, module) => {
  var countSymbols = function(str) {
    return punycode.ucs2.decode(str).length;
  };
  var at = function(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
  };
  var isASCIIDigit = function(c) {
    return c >= 48 && c <= 57;
  };
  var isASCIIAlpha = function(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  };
  var isASCIIAlphanumeric = function(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
  };
  var isASCIIHex = function(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  };
  var isSingleDot = function(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  };
  var isDoubleDot = function(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  };
  var isWindowsDriveLetterCodePoints = function(cp1, cp2) {
    return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
  };
  var isWindowsDriveLetterString = function(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
  };
  var isNormalizedWindowsDriveLetterString = function(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
  };
  var containsForbiddenHostCodePoint = function(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
  };
  var containsForbiddenHostCodePointExcludingPercent = function(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
  };
  var isSpecialScheme = function(scheme) {
    return specialSchemes[scheme] !== undefined;
  };
  var isSpecial = function(url) {
    return isSpecialScheme(url.scheme);
  };
  var defaultPort = function(scheme) {
    return specialSchemes[scheme];
  };
  var percentEncode = function(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
      hex = "0" + hex;
    }
    return "%" + hex;
  };
  var utf8PercentEncode = function(c) {
    const buf = new Buffer(c);
    let str = "";
    for (let i = 0;i < buf.length; ++i) {
      str += percentEncode(buf[i]);
    }
    return str;
  };
  var utf8PercentDecode = function(str) {
    const input = new Buffer(str);
    const output = [];
    for (let i = 0;i < input.length; ++i) {
      if (input[i] !== 37) {
        output.push(input[i]);
      } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
        output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
        i += 2;
      } else {
        output.push(input[i]);
      }
    }
    return new Buffer(output).toString();
  };
  var isC0ControlPercentEncode = function(c) {
    return c <= 31 || c > 126;
  };
  var isPathPercentEncode = function(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  };
  var isUserinfoPercentEncode = function(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  };
  var percentEncodeChar = function(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    if (encodeSetPredicate(c)) {
      return utf8PercentEncode(cStr);
    }
    return cStr;
  };
  var parseIPv4Number = function(input) {
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R = 8;
    }
    if (input === "") {
      return 0;
    }
    const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
    if (regex.test(input)) {
      return failure;
    }
    return parseInt(input, R);
  };
  var parseIPv4 = function(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return input;
    }
    const numbers = [];
    for (const part of parts) {
      if (part === "") {
        return input;
      }
      const n = parseIPv4Number(part);
      if (n === failure) {
        return input;
      }
      numbers.push(n);
    }
    for (let i = 0;i < numbers.length - 1; ++i) {
      if (numbers[i] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers) {
      ipv4 += n * Math.pow(256, 3 - counter);
      ++counter;
    }
    return ipv4;
  };
  var serializeIPv4 = function(address) {
    let output = "";
    let n = address;
    for (let i = 1;i <= 4; ++i) {
      output = String(n % 256) + output;
      if (i !== 4) {
        output = "." + output;
      }
      n = Math.floor(n / 256);
    }
    return output;
  };
  var parseIPv6 = function(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = punycode.ucs2.decode(input);
    if (input[pointer] === 58) {
      if (input[pointer + 1] !== 58) {
        return failure;
      }
      pointer += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer] === 58) {
        if (compress !== null) {
          return failure;
        }
        ++pointer;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && isASCIIHex(input[pointer])) {
        value = value * 16 + parseInt(at(input, pointer), 16);
        ++pointer;
        ++length;
      }
      if (input[pointer] === 46) {
        if (length === 0) {
          return failure;
        }
        pointer -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer] !== undefined) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer] === 46 && numbersSeen < 4) {
              ++pointer;
            } else {
              return failure;
            }
          }
          if (!isASCIIDigit(input[pointer])) {
            return failure;
          }
          while (isASCIIDigit(input[pointer])) {
            const number = parseInt(at(input, pointer));
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer] === 58) {
        ++pointer;
        if (input[pointer] === undefined) {
          return failure;
        }
      } else if (input[pointer] !== undefined) {
        return failure;
      }
      address[pieceIndex] = value;
      ++pieceIndex;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  };
  var serializeIPv6 = function(address) {
    let output = "";
    const seqResult = findLongestZeroSequence(address);
    const compress = seqResult.idx;
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  };
  var parseHost = function(input, isSpecialArg) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (!isSpecialArg) {
      return parseOpaqueHost(input);
    }
    const domain = utf8PercentDecode(input);
    const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
    if (asciiDomain === null) {
      return failure;
    }
    if (containsForbiddenHostCodePoint(asciiDomain)) {
      return failure;
    }
    const ipv4Host = parseIPv4(asciiDomain);
    if (typeof ipv4Host === "number" || ipv4Host === failure) {
      return ipv4Host;
    }
    return asciiDomain;
  };
  var parseOpaqueHost = function(input) {
    if (containsForbiddenHostCodePointExcludingPercent(input)) {
      return failure;
    }
    let output = "";
    const decoded = punycode.ucs2.decode(input);
    for (let i = 0;i < decoded.length; ++i) {
      output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
    }
    return output;
  };
  var findLongestZeroSequence = function(arr) {
    let maxIdx = null;
    let maxLen = 1;
    let currStart = null;
    let currLen = 0;
    for (let i = 0;i < arr.length; ++i) {
      if (arr[i] !== 0) {
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        currStart = null;
        currLen = 0;
      } else {
        if (currStart === null) {
          currStart = i;
        }
        ++currLen;
      }
    }
    if (currLen > maxLen) {
      maxIdx = currStart;
      maxLen = currLen;
    }
    return {
      idx: maxIdx,
      len: maxLen
    };
  };
  var serializeHost = function(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return "[" + serializeIPv6(host) + "]";
    }
    return host;
  };
  var trimControlChars = function(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
  };
  var trimTabAndNewline = function(url) {
    return url.replace(/\u0009|\u000A|\u000D/g, "");
  };
  var shortenPath = function(url) {
    const path = url.path;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  };
  var includesCredentials = function(url) {
    return url.username !== "" || url.password !== "";
  };
  var cannotHaveAUsernamePasswordPort = function(url) {
    return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
  };
  var isNormalizedWindowsDriveLetter = function(string) {
    return /^[A-Za-z]:$/.test(string);
  };
  var URLStateMachine = function(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null,
        cannotBeABaseURL: false
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = punycode.ucs2.decode(this.input);
    for (;this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer];
      const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
      const ret = this["parse " + this.state](c, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  };
  var serializeURL = function(url, excludeFragment) {
    let output = url.scheme + ":";
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += ":" + url.password;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += ":" + url.port;
      }
    } else if (url.host === null && url.scheme === "file") {
      output += "//";
    }
    if (url.cannotBeABaseURL) {
      output += url.path[0];
    } else {
      for (const string of url.path) {
        output += "/" + string;
      }
    }
    if (url.query !== null) {
      output += "?" + url.query;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += "#" + url.fragment;
    }
    return output;
  };
  var serializeOrigin = function(tuple) {
    let result = tuple.scheme + "://";
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result += ":" + tuple.port;
    }
    return result;
  };
  var punycode = __require("punycode");
  var tr46 = require_tr46();
  var specialSchemes = {
    ftp: 21,
    file: null,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  var extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
  var extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (isASCIIAlpha(c)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
      this.buffer += cStr.toLowerCase();
    } else if (c === 58) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      this.buffer = "";
      if (this.stateOverride) {
        return false;
      }
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === 47) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.cannotBeABaseURL = true;
        this.url.path.push("");
        this.state = "cannot-be-a-base-URL path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
      return failure;
    } else if (this.base.cannotBeABaseURL && c === 35) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.url.cannotBeABaseURL = true;
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === 47) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (isNaN(c)) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    } else if (c === 47) {
      this.state = "relative slash";
    } else if (c === 63) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (isSpecial(this.url) && c === 92) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice(0, this.base.path.length - 1);
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === 47 || c === 92)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c === 47) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== 47 && c !== 92) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === 64) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = "%40" + this.buffer;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer = 0;pointer < len; ++pointer) {
        const codePoint = this.buffer.codePointAt(pointer);
        if (codePoint === 58 && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c === 58 && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
      if (this.stateOverride === "hostname") {
        return false;
      }
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c === 91) {
        this.arrFlag = true;
      } else if (c === 93) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (isASCIIDigit(c)) {
      this.buffer += cStr;
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > Math.pow(2, 16) - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);
  URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      if (isNaN(c)) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 63) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          shortenPath(this.url);
        } else {
          this.parseError = true;
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        } else {
          this.url.host = this.base.host;
        }
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "path";
      if (c !== 47 && c !== 92) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c !== undefined) {
      this.state = "path";
      if (c !== 47) {
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
      if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          if (this.url.host !== "" && this.url.host !== null) {
            this.parseError = true;
            this.url.host = "";
          }
          this.buffer = this.buffer[0] + ":";
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
        while (this.url.path.length > 1 && this.url.path[0] === "") {
          this.parseError = true;
          this.url.path.shift();
        }
      }
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      }
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += percentEncodeChar(c, isPathPercentEncode);
    }
    return true;
  };
  URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
    if (c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c) && c !== 37) {
        this.parseError = true;
      }
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c)) {
        this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (isNaN(c) || !this.stateOverride && c === 35) {
      if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
        this.encodingOverride = "utf-8";
      }
      const buffer = new Buffer(this.buffer);
      for (let i = 0;i < buffer.length; ++i) {
        if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
          this.url.query += percentEncode(buffer[i]);
        } else {
          this.url.query += String.fromCodePoint(buffer[i]);
        }
      }
      this.buffer = "";
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (isNaN(c)) {
    } else if (c === 0) {
      this.parseError = true;
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
    }
    return true;
  };
  exports.serializeURL = serializeURL;
  exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob":
        try {
          return exports.serializeURLOrigin(exports.parseURL(url.path[0]));
        } catch (e) {
          return "null";
        }
      case "ftp":
      case "gopher":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "file://";
      default:
        return "null";
    }
  };
  exports.basicURLParse = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
      return "failure";
    }
    return usm.url;
  };
  exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode.ucs2.decode(username);
    for (let i = 0;i < decoded.length; ++i) {
      url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
  };
  exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode.ucs2.decode(password);
    for (let i = 0;i < decoded.length; ++i) {
      url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
  };
  exports.serializeHost = serializeHost;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.serializeInteger = function(integer) {
    return String(integer);
  };
  exports.parseURL = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS((exports) => {
  var usm = require_url_state_machine();
  exports.implementation = class URLImpl {
    constructor(constructorArgs) {
      const url = constructorArgs[0];
      const base = constructorArgs[1];
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === "failure") {
          throw new TypeError("Invalid base URL");
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v) {
      const parsedURL = usm.basicURLParse(v);
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return this._url.scheme + ":";
    }
    set protocol(v) {
      usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v);
    }
    get password() {
      return this._url.password;
    }
    set password(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
    }
    set host(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      if (this._url.cannotBeABaseURL) {
        return this._url.path[0];
      }
      if (this._url.path.length === 0) {
        return "";
      }
      return "/" + this._url.path.join("/");
    }
    set pathname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return "?" + this._url.query;
    }
    set search(v) {
      const url = this._url;
      if (v === "") {
        url.query = null;
        return;
      }
      const input = v[0] === "?" ? v.substring(1) : v;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return "#" + this._url.fragment;
    }
    set hash(v) {
      if (v === "") {
        this._url.fragment = null;
        return;
      }
      const input = v[0] === "#" ? v.substring(1) : v;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
  };
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS((exports, module) => {
  var URL2 = function(url) {
    if (!this || this[impl] || !(this instanceof URL2)) {
      throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    }
    if (arguments.length < 1) {
      throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    }
    const args = [];
    for (let i = 0;i < arguments.length && i < 2; ++i) {
      args[i] = arguments[i];
    }
    args[0] = conversions["USVString"](args[0]);
    if (args[1] !== undefined) {
      args[1] = conversions["USVString"](args[1]);
    }
    exports.setup(this, args);
  };
  var conversions = require_lib3();
  var utils = require_utils3();
  var Impl = require_URL_impl();
  var impl = utils.implSymbol;
  URL2.prototype.toJSON = function toJSON() {
    if (!this || !exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    const args = [];
    for (let i = 0;i < arguments.length && i < 0; ++i) {
      args[i] = arguments[i];
    }
    return this[impl].toJSON.apply(this[impl], args);
  };
  Object.defineProperty(URL2.prototype, "href", {
    get() {
      return this[impl].href;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].href = V;
    },
    enumerable: true,
    configurable: true
  });
  URL2.prototype.toString = function() {
    if (!this || !exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    return this.href;
  };
  Object.defineProperty(URL2.prototype, "origin", {
    get() {
      return this[impl].origin;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "protocol", {
    get() {
      return this[impl].protocol;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].protocol = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "username", {
    get() {
      return this[impl].username;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].username = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "password", {
    get() {
      return this[impl].password;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].password = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "host", {
    get() {
      return this[impl].host;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].host = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "hostname", {
    get() {
      return this[impl].hostname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hostname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "port", {
    get() {
      return this[impl].port;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].port = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "pathname", {
    get() {
      return this[impl].pathname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].pathname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "search", {
    get() {
      return this[impl].search;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].search = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "hash", {
    get() {
      return this[impl].hash;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hash = V;
    },
    enumerable: true,
    configurable: true
  });
  module.exports = {
    is(obj) {
      return !!obj && obj[impl] instanceof Impl.implementation;
    },
    create(constructorArgs, privateData) {
      let obj = Object.create(URL2.prototype);
      this.setup(obj, constructorArgs, privateData);
      return obj;
    },
    setup(obj, constructorArgs, privateData) {
      if (!privateData)
        privateData = {};
      privateData.wrapper = obj;
      obj[impl] = new Impl.implementation(constructorArgs, privateData);
      obj[impl][utils.wrapperSymbol] = obj;
    },
    interface: URL2,
    expose: {
      Window: { URL: URL2 },
      Worker: { URL: URL2 }
    }
  };
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS((exports) => {
  exports.URL = require_URL().interface;
  exports.serializeURL = require_url_state_machine().serializeURL;
  exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
  exports.basicURLParse = require_url_state_machine().basicURLParse;
  exports.setTheUsername = require_url_state_machine().setTheUsername;
  exports.setThePassword = require_url_state_machine().setThePassword;
  exports.serializeHost = require_url_state_machine().serializeHost;
  exports.serializeInteger = require_url_state_machine().serializeInteger;
  exports.parseURL = require_url_state_machine().parseURL;
});

// node_modules/node-fetch/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  var _interopDefault = function(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  };
  var FetchError = function(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  };
  var Body = function(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  };
  var consumeBody = function() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  };
  var convertBody = function(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  };
  var isURLSearchParams = function(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  };
  var isBlob = function(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  };
  var clone = function(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough;
      p2 = new PassThrough;
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  };
  var extractContentType = function(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof Stream) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  };
  var getTotalBytes = function(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  };
  var writeToStream = function(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  };
  var validateName = function(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  };
  var validateValue = function(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  };
  var find = function(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return;
  };
  var getHeaders = function(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  };
  var createHeadersIterator = function(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  };
  var exportNodeCompatibleHeaders = function(headers) {
    const obj = Object.assign({ __proto__: null }, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== undefined) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  };
  var createHeadersLenient = function(obj) {
    const headers = new Headers;
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === undefined) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  };
  var parseURL = function(urlStr) {
    if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
      urlStr = new URL2(urlStr).toString();
    }
    return parse_url(urlStr);
  };
  var isRequest = function(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  };
  var isAbortSignal = function(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  };
  var getNodeRequestOptions = function(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  };
  var AbortError = function(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  };
  var fetch = function(url, opts) {
    if (!fetch.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch.Promise;
    return new fetch.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? https : http).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort() {
        let error = new AbortError("The user aborted a request.");
        reject(error);
        if (request.body && request.body instanceof Stream.Readable) {
          destroyStream(request.body, error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        if (response && response.body) {
          destroyStream(response.body, err);
        }
        finalize();
      });
      fixResponseChunkedTransferBadEnding(req, function(err) {
        if (signal && signal.aborted) {
          return;
        }
        if (response && response.body) {
          destroyStream(response.body, err);
        }
      });
      if (parseInt(process.version.substring(1)) < 14) {
        req.on("socket", function(s) {
          s.addListener("close", function(hadError) {
            const hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              response.body.emit("error", err);
            }
          });
        });
      }
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL$1(location, request.url).toString();
          } catch (err) {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOpts.headers.delete(name);
                }
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = undefined;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1);
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1);
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            response = new Response(body, response_options);
            resolve(response);
          });
          raw.on("end", function() {
            if (!response) {
              response = new Response(body, response_options);
              resolve(response);
            }
          });
          return;
        }
        if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
          body = body.pipe(zlib.createBrotliDecompress());
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        response = new Response(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  };
  var fixResponseChunkedTransferBadEnding = function(request, errorCallback) {
    let socket;
    request.on("socket", function(s) {
      socket = s;
    });
    request.on("response", function(response) {
      const headers = response.headers;
      if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
        response.once("close", function(hadError) {
          const hasDataListener = socket && socket.listenerCount("data") > 0;
          if (hasDataListener && !hadError) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            errorCallback(err);
          }
        });
      }
    });
  };
  var destroyStream = function(stream, err) {
    if (stream.destroy) {
      stream.destroy(err);
    } else {
      stream.emit("error", err);
      stream.end();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Stream = _interopDefault(__require("stream"));
  var http = _interopDefault(__require("http"));
  var Url = _interopDefault(__require("url"));
  var whatwgUrl = _interopDefault(require_public_api());
  var https = _interopDefault(__require("https"));
  var zlib = _interopDefault(__require("zlib"));
  var Readable = Stream.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");

  class Blob {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0;i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== undefined && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable;
      readable._read = function() {
      };
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === undefined) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === undefined) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob([], { type: arguments[2] });
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  }
  Object.defineProperties(Blob.prototype, {
    size: { enumerable: true },
    type: { enumerable: true },
    slice: { enumerable: true }
  });
  Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = (()=>{ throw new Error(`Cannot require module "encoding"`);})().convert;
  } catch (e) {
  }
  var INTERNALS = Symbol("Body internals");
  var PassThrough = Stream.PassThrough;
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: { enumerable: true },
    bodyUsed: { enumerable: true },
    arrayBuffer: { enumerable: true },
    blob: { enumerable: true },
    json: { enumerable: true },
    text: { enumerable: true }
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  var MAP = Symbol("map");

  class Headers {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this[MAP] = Object.create(null);
      if (init instanceof Headers) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === undefined) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let pairs = getHeaders(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== undefined ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== undefined) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== undefined;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== undefined) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  }
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: { enumerable: true },
    forEach: { enumerable: true },
    set: { enumerable: true },
    append: { enumerable: true },
    has: { enumerable: true },
    delete: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true }
  });
  var INTERNAL = Symbol("internal");
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const { target, kind, index } = _INTERNAL;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: undefined,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = http.STATUS_CODES;

  class Response {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  }
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: { enumerable: true },
    status: { enumerable: true },
    ok: { enumerable: true },
    redirected: { enumerable: true },
    statusText: { enumerable: true },
    headers: { enumerable: true },
    clone: { enumerable: true }
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var URL2 = Url.URL || whatwgUrl.URL;
  var parse_url = Url.parse;
  var format_url = Url.format;
  var streamDestructionSupported = "destroy" in Stream.Readable.prototype;

  class Request {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parseURL(input.href);
        } else {
          parsedURL = parseURL(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parseURL(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
      this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request(this);
    }
  }
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: { enumerable: true },
    url: { enumerable: true },
    headers: { enumerable: true },
    redirect: { enumerable: true },
    clone: { enumerable: true },
    signal: { enumerable: true }
  });
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var URL$1 = Url.URL || whatwgUrl.URL;
  var PassThrough$1 = Stream.PassThrough;
  var isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
  };
  var isSameProtocol = function isSameProtocol(destination, original) {
    const orig = new URL$1(original).protocol;
    const dest = new URL$1(destination).protocol;
    return orig === dest;
  };
  fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch.Promise = global.Promise;
  module.exports = exports = fetch;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = exports;
  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.FetchError = FetchError;
  exports.AbortError = AbortError;
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  };
  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS((exports, module) => {
  var _typeof = function(o) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
  };
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS((exports, module) => {
  var _regeneratorRuntime = function() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
      return e;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
      t2[e2] = r2.value;
    }, i = typeof Symbol == "function" ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
    function define2(t2, e2, r2) {
      return Object.defineProperty(t2, e2, {
        value: r2,
        enumerable: true,
        configurable: true,
        writable: true
      }), t2[e2];
    }
    try {
      define2({}, "");
    } catch (t2) {
      define2 = function define(t3, e2, r2) {
        return t3[e2] = r2;
      };
    }
    function wrap(t2, e2, r2, n2) {
      var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
      return o(a2, "_invoke", {
        value: makeInvokeMethod(t2, r2, c2)
      }), a2;
    }
    function tryCatch(t2, e2, r2) {
      try {
        return {
          type: "normal",
          arg: t2.call(e2, r2)
        };
      } catch (t3) {
        return {
          type: "throw",
          arg: t3
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var p = {};
    define2(p, a, function() {
      return this;
    });
    var d = Object.getPrototypeOf, v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t2) {
      ["next", "throw", "return"].forEach(function(e2) {
        define2(t2, e2, function(t3) {
          return this._invoke(e2, t3);
        });
      });
    }
    function AsyncIterator(t2, e2) {
      function invoke(r3, o2, i2, a2) {
        var c2 = tryCatch(t2[r3], t2, o2);
        if (c2.type !== "throw") {
          var u2 = c2.arg, h2 = u2.value;
          return h2 && _typeof(h2) == "object" && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
            invoke("next", t3, i2, a2);
          }, function(t3) {
            invoke("throw", t3, i2, a2);
          }) : e2.resolve(h2).then(function(t3) {
            u2.value = t3, i2(u2);
          }, function(t3) {
            return invoke("throw", t3, i2, a2);
          });
        }
        a2(c2.arg);
      }
      var r2;
      o(this, "_invoke", {
        value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e2, r2, n2) {
      var o2 = h;
      return function(i2, a2) {
        if (o2 === f)
          throw new Error("Generator is already running");
        if (o2 === s) {
          if (i2 === "throw")
            throw a2;
          return {
            value: t,
            done: true
          };
        }
        for (n2.method = i2, n2.arg = a2;; ) {
          var c2 = n2.delegate;
          if (c2) {
            var u2 = maybeInvokeDelegate(c2, n2);
            if (u2) {
              if (u2 === y)
                continue;
              return u2;
            }
          }
          if (n2.method === "next")
            n2.sent = n2._sent = n2.arg;
          else if (n2.method === "throw") {
            if (o2 === h)
              throw o2 = s, n2.arg;
            n2.dispatchException(n2.arg);
          } else
            n2.method === "return" && n2.abrupt("return", n2.arg);
          o2 = f;
          var p2 = tryCatch(e2, r2, n2);
          if (p2.type === "normal") {
            if (o2 = n2.done ? s : l, p2.arg === y)
              continue;
            return {
              value: p2.arg,
              done: n2.done
            };
          }
          p2.type === "throw" && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
        }
      };
    }
    function maybeInvokeDelegate(e2, r2) {
      var n2 = r2.method, o2 = e2.iterator[n2];
      if (o2 === t)
        return r2.delegate = null, n2 === "throw" && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), r2.method === "throw") || n2 !== "return" && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
      var i2 = tryCatch(o2, e2.iterator, r2.arg);
      if (i2.type === "throw")
        return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
      var a2 = i2.arg;
      return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, r2.method !== "return" && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
    }
    function pushTryEntry(t2) {
      var e2 = {
        tryLoc: t2[0]
      };
      1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
    }
    function resetTryEntry(t2) {
      var e2 = t2.completion || {};
      e2.type = "normal", delete e2.arg, t2.completion = e2;
    }
    function Context(t2) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t2.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(e2) {
      if (e2 || e2 === "") {
        var r2 = e2[a];
        if (r2)
          return r2.call(e2);
        if (typeof e2.next == "function")
          return e2;
        if (!isNaN(e2.length)) {
          var o2 = -1, i2 = function next() {
            for (;++o2 < e2.length; )
              if (n.call(e2, o2))
                return next.value = e2[o2], next.done = false, next;
            return next.value = t, next.done = true, next;
          };
          return i2.next = i2;
        }
      }
      throw new TypeError(_typeof(e2) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
      var e2 = typeof t2 == "function" && t2.constructor;
      return !!e2 && (e2 === GeneratorFunction || (e2.displayName || e2.name) === "GeneratorFunction");
    }, e.mark = function(t2) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
    }, e.awrap = function(t2) {
      return {
        __await: t2
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
      i2 === undefined && (i2 = Promise);
      var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
      return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
        return t3.done ? t3.value : a2.next();
      });
    }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
      return this;
    }), define2(g, "toString", function() {
      return "[object Generator]";
    }), e.keys = function(t2) {
      var e2 = Object(t2), r2 = [];
      for (var n2 in e2)
        r2.push(n2);
      return r2.reverse(), function next() {
        for (;r2.length; ) {
          var t3 = r2.pop();
          if (t3 in e2)
            return next.value = t3, next.done = false, next;
        }
        return next.done = true, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2)
          for (var r2 in this)
            r2.charAt(0) === "t" && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      },
      stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if (t2.type === "throw")
          throw t2.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e2) {
        if (this.done)
          throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1;o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if (i2.tryLoc === "root")
            return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc)
                return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc)
                return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc)
                return handle(i2.catchLoc, true);
            } else {
              if (!u2)
                throw new Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc)
                return handle(i2.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1;r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && (t2 === "break" || t2 === "continue") && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      },
      complete: function complete(t2, e2) {
        if (t2.type === "throw")
          throw t2.arg;
        return t2.type === "break" || t2.type === "continue" ? this.next = t2.arg : t2.type === "return" ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : t2.type === "normal" && e2 && (this.next = e2), y;
      },
      finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1;e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2)
            return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      },
      catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1;e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if (n2.type === "throw") {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = {
          iterator: values(e2),
          resultName: r2,
          nextLoc: n2
        }, this.method === "next" && (this.arg = t), y;
      }
    }, e;
  };
  var _typeof = require_typeof()["default"];
  module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS((exports, module) => {
  var runtime = require_regeneratorRuntime()();
  module.exports = runtime;
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
});

// node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS((exports, module) => {
  var asyncGeneratorStep = function(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  };
  var _asyncToGenerator = function(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  };
  module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS((exports, module) => {
  var _classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS((exports, module) => {
  var toPrimitive = function(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  };
  var _typeof = require_typeof()["default"];
  module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS((exports, module) => {
  var toPropertyKey = function(t) {
    var i = toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : String(i);
  };
  var _typeof = require_typeof()["default"];
  var toPrimitive = require_toPrimitive();
  module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS((exports, module) => {
  var _defineProperties = function(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  };
  var _createClass = function(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  };
  var toPropertyKey = require_toPropertyKey();
  module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS((exports, module) => {
  var _setPrototypeOf = function(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _setPrototypeOf(o, p);
  };
  module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS((exports, module) => {
  var _inherits = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass)
      setPrototypeOf(subClass, superClass);
  };
  var setPrototypeOf = require_setPrototypeOf();
  module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS((exports, module) => {
  var _assertThisInitialized = function(self2) {
    if (self2 === undefined) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  };
  module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS((exports, module) => {
  var _possibleConstructorReturn = function(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== undefined) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return assertThisInitialized(self2);
  };
  var _typeof = require_typeof()["default"];
  var assertThisInitialized = require_assertThisInitialized();
  module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS((exports, module) => {
  var _getPrototypeOf = function(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _getPrototypeOf(o);
  };
  module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  var Events = function() {
  };
  var EE = function(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  };
  var addListener = function(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  };
  var clearEvent = function(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  };
  var EventEmitter = function() {
    this._events = new Events;
    this._eventsCount = 0;
  };
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/rpc-websockets/dist/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  var createError = function(code, details) {
    var error = {
      code,
      message: errors.get(code) || "Internal Server Error"
    };
    if (details)
      error["data"] = details;
    return error;
  };
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DefaultDataPack = undefined;
  exports.createError = createError;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var errors = new Map([[-32000, "Event not provided"], [-32600, "Invalid Request"], [-32601, "Method not found"], [-32602, "Invalid params"], [-32603, "Internal error"], [-32604, "Params not found"], [-32605, "Method forbidden"], [-32606, "Event forbidden"], [-32700, "Parse error"]]);
  var DefaultDataPack = function() {
    function DefaultDataPack2() {
      (0, _classCallCheck2["default"])(this, DefaultDataPack2);
    }
    (0, _createClass2["default"])(DefaultDataPack2, [{
      key: "encode",
      value: function encode(value) {
        return JSON.stringify(value);
      }
    }, {
      key: "decode",
      value: function decode(value) {
        return JSON.parse(value);
      }
    }]);
    return DefaultDataPack2;
  }();
  exports.DefaultDataPack = DefaultDataPack;
});

// node_modules/rpc-websockets/dist/lib/client.js
var require_client = __commonJS((exports) => {
  var _createSuper = function(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = (0, _getPrototypeOf2["default"])(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn2["default"])(this, result);
    };
  };
  var _isNativeReflectConstruct = function() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  };
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regenerator = _interopRequireDefault(require_regenerator());
  var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
  var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
  var _eventemitter = require_eventemitter3();
  var _utils = require_utils4();
  var __rest = function(s, e) {
    var t = {};
    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    }
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var CommonClient = function(_EventEmitter) {
    (0, _inherits2["default"])(CommonClient2, _EventEmitter);
    var _super = _createSuper(CommonClient2);
    function CommonClient2(webSocketFactory) {
      var _this;
      var address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "ws://localhost:8080";
      var _a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var generate_request_id = arguments.length > 3 ? arguments[3] : undefined;
      var dataPack = arguments.length > 4 ? arguments[4] : undefined;
      (0, _classCallCheck2["default"])(this, CommonClient2);
      var _a$autoconnect = _a.autoconnect, autoconnect = _a$autoconnect === undefined ? true : _a$autoconnect, _a$reconnect = _a.reconnect, reconnect = _a$reconnect === undefined ? true : _a$reconnect, _a$reconnect_interval = _a.reconnect_interval, reconnect_interval = _a$reconnect_interval === undefined ? 1000 : _a$reconnect_interval, _a$max_reconnects = _a.max_reconnects, max_reconnects = _a$max_reconnects === undefined ? 5 : _a$max_reconnects, rest_options = __rest(_a, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
      _this = _super.call(this);
      _this.webSocketFactory = webSocketFactory;
      _this.queue = {};
      _this.rpc_id = 0;
      _this.address = address;
      _this.autoconnect = autoconnect;
      _this.ready = false;
      _this.reconnect = reconnect;
      _this.reconnect_timer_id = undefined;
      _this.reconnect_interval = reconnect_interval;
      _this.max_reconnects = max_reconnects;
      _this.rest_options = rest_options;
      _this.current_reconnects = 0;
      _this.generate_request_id = generate_request_id || function() {
        return ++_this.rpc_id;
      };
      if (!dataPack)
        _this.dataPack = new _utils.DefaultDataPack;
      else
        _this.dataPack = dataPack;
      if (_this.autoconnect)
        _this._connect(_this.address, Object.assign({
          autoconnect: _this.autoconnect,
          reconnect: _this.reconnect,
          reconnect_interval: _this.reconnect_interval,
          max_reconnects: _this.max_reconnects
        }, _this.rest_options));
      return _this;
    }
    (0, _createClass2["default"])(CommonClient2, [{
      key: "connect",
      value: function connect() {
        if (this.socket)
          return;
        this._connect(this.address, Object.assign({
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects
        }, this.rest_options));
      }
    }, {
      key: "call",
      value: function call(method, params, timeout, ws_opts) {
        var _this2 = this;
        if (!ws_opts && (0, _typeof2["default"])(timeout) === "object") {
          ws_opts = timeout;
          timeout = null;
        }
        return new Promise(function(resolve, reject) {
          if (!_this2.ready)
            return reject(new Error("socket not ready"));
          var rpc_id = _this2.generate_request_id(method, params);
          var message = {
            jsonrpc: "2.0",
            method,
            params: params || undefined,
            id: rpc_id
          };
          _this2.socket.send(_this2.dataPack.encode(message), ws_opts, function(error) {
            if (error)
              return reject(error);
            _this2.queue[rpc_id] = {
              promise: [resolve, reject]
            };
            if (timeout) {
              _this2.queue[rpc_id].timeout = setTimeout(function() {
                delete _this2.queue[rpc_id];
                reject(new Error("reply timeout"));
              }, timeout);
            }
          });
        });
      }
    }, {
      key: "login",
      value: function() {
        var _login = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(params) {
          var resp;
          return _regenerator["default"].wrap(function _callee$(_context) {
            while (true) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return this.call("rpc.login", params);
                case 2:
                  resp = _context.sent;
                  if (resp) {
                    _context.next = 5;
                    break;
                  }
                  throw new Error("authentication failed");
                case 5:
                  return _context.abrupt("return", resp);
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function login(_x) {
          return _login.apply(this, arguments);
        }
        return login;
      }()
    }, {
      key: "listMethods",
      value: function() {
        var _listMethods = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
          return _regenerator["default"].wrap(function _callee2$(_context2) {
            while (true) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.call("__listMethods");
                case 2:
                  return _context2.abrupt("return", _context2.sent);
                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));
        function listMethods() {
          return _listMethods.apply(this, arguments);
        }
        return listMethods;
      }()
    }, {
      key: "notify",
      value: function notify(method, params) {
        var _this3 = this;
        return new Promise(function(resolve, reject) {
          if (!_this3.ready)
            return reject(new Error("socket not ready"));
          var message = {
            jsonrpc: "2.0",
            method,
            params
          };
          _this3.socket.send(_this3.dataPack.encode(message), function(error) {
            if (error)
              return reject(error);
            resolve();
          });
        });
      }
    }, {
      key: "subscribe",
      value: function() {
        var _subscribe = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(event) {
          var result;
          return _regenerator["default"].wrap(function _callee3$(_context3) {
            while (true) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (typeof event === "string")
                    event = [event];
                  _context3.next = 3;
                  return this.call("rpc.on", event);
                case 3:
                  result = _context3.sent;
                  if (!(typeof event === "string" && result[event] !== "ok")) {
                    _context3.next = 6;
                    break;
                  }
                  throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
                case 6:
                  return _context3.abrupt("return", result);
                case 7:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));
        function subscribe(_x2) {
          return _subscribe.apply(this, arguments);
        }
        return subscribe;
      }()
    }, {
      key: "unsubscribe",
      value: function() {
        var _unsubscribe = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(event) {
          var result;
          return _regenerator["default"].wrap(function _callee4$(_context4) {
            while (true) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  if (typeof event === "string")
                    event = [event];
                  _context4.next = 3;
                  return this.call("rpc.off", event);
                case 3:
                  result = _context4.sent;
                  if (!(typeof event === "string" && result[event] !== "ok")) {
                    _context4.next = 6;
                    break;
                  }
                  throw new Error("Failed unsubscribing from an event with: " + result);
                case 6:
                  return _context4.abrupt("return", result);
                case 7:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));
        function unsubscribe(_x3) {
          return _unsubscribe.apply(this, arguments);
        }
        return unsubscribe;
      }()
    }, {
      key: "close",
      value: function close(code, data) {
        this.socket.close(code || 1000, data);
      }
    }, {
      key: "_connect",
      value: function _connect(address, options) {
        var _this4 = this;
        clearTimeout(this.reconnect_timer_id);
        this.socket = this.webSocketFactory(address, options);
        this.socket.addEventListener("open", function() {
          _this4.ready = true;
          _this4.emit("open");
          _this4.current_reconnects = 0;
        });
        this.socket.addEventListener("message", function(_ref) {
          var message = _ref.data;
          if (message instanceof ArrayBuffer)
            message = Buffer.from(message).toString();
          try {
            message = _this4.dataPack.decode(message);
          } catch (error) {
            return;
          }
          if (message.notification && _this4.listeners(message.notification).length) {
            if (!Object.keys(message.params).length)
              return _this4.emit(message.notification);
            var args = [message.notification];
            if (message.params.constructor === Object)
              args.push(message.params);
            else
              for (var i = 0;i < message.params.length; i++) {
                args.push(message.params[i]);
              }
            return Promise.resolve().then(function() {
              _this4.emit.apply(_this4, args);
            });
          }
          if (!_this4.queue[message.id]) {
            if (message.method) {
              return Promise.resolve().then(function() {
                _this4.emit(message.method, message === null || message === undefined ? undefined : message.params);
              });
            }
            return;
          }
          if ("error" in message === "result" in message)
            _this4.queue[message.id].promise[1](new Error("Server response malformed. Response must include either \"result\" or \"error\", but not both."));
          if (_this4.queue[message.id].timeout)
            clearTimeout(_this4.queue[message.id].timeout);
          if (message.error)
            _this4.queue[message.id].promise[1](message.error);
          else
            _this4.queue[message.id].promise[0](message.result);
          delete _this4.queue[message.id];
        });
        this.socket.addEventListener("error", function(error) {
          return _this4.emit("error", error);
        });
        this.socket.addEventListener("close", function(_ref2) {
          var { code, reason } = _ref2;
          if (_this4.ready)
            setTimeout(function() {
              return _this4.emit("close", code, reason);
            }, 0);
          _this4.ready = false;
          _this4.socket = undefined;
          if (code === 1000)
            return;
          _this4.current_reconnects++;
          if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0))
            _this4.reconnect_timer_id = setTimeout(function() {
              return _this4._connect(address, options);
            }, _this4.reconnect_interval);
        });
      }
    }]);
    return CommonClient2;
  }(_eventemitter.EventEmitter);
  exports.default = CommonClient;
});

// node_modules/rpc-websockets/node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {
    }
  };
});

// node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS((exports, module) => {
  var load = function(dir) {
    return runtimeRequire(load.resolve(dir));
  };
  var readdirSync = function(dir) {
    try {
      return fs.readdirSync(dir);
    } catch (err) {
      return [];
    }
  };
  var getFirst = function(dir, filter) {
    var files = readdirSync(dir).filter(filter);
    return files[0] && path.join(dir, files[0]);
  };
  var matchBuild = function(name) {
    return /\.node$/.test(name);
  };
  var parseTuple = function(name) {
    var arr = name.split("-");
    if (arr.length !== 2)
      return;
    var platform2 = arr[0];
    var architectures = arr[1].split("+");
    if (!platform2)
      return;
    if (!architectures.length)
      return;
    if (!architectures.every(Boolean))
      return;
    return { name, platform: platform2, architectures };
  };
  var matchTuple = function(platform2, arch2) {
    return function(tuple) {
      if (tuple == null)
        return false;
      if (tuple.platform !== platform2)
        return false;
      return tuple.architectures.includes(arch2);
    };
  };
  var compareTuples = function(a, b) {
    return a.architectures.length - b.architectures.length;
  };
  var parseTags = function(file) {
    var arr = file.split(".");
    var extension = arr.pop();
    var tags = { file, specificity: 0 };
    if (extension !== "node")
      return;
    for (var i = 0;i < arr.length; i++) {
      var tag = arr[i];
      if (tag === "node" || tag === "electron" || tag === "node-webkit") {
        tags.runtime = tag;
      } else if (tag === "napi") {
        tags.napi = true;
      } else if (tag.slice(0, 3) === "abi") {
        tags.abi = tag.slice(3);
      } else if (tag.slice(0, 2) === "uv") {
        tags.uv = tag.slice(2);
      } else if (tag.slice(0, 4) === "armv") {
        tags.armv = tag.slice(4);
      } else if (tag === "glibc" || tag === "musl") {
        tags.libc = tag;
      } else {
        continue;
      }
      tags.specificity++;
    }
    return tags;
  };
  var matchTags = function(runtime2, abi2) {
    return function(tags) {
      if (tags == null)
        return false;
      if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags))
        return false;
      if (tags.abi && tags.abi !== abi2 && !tags.napi)
        return false;
      if (tags.uv && tags.uv !== uv)
        return false;
      if (tags.armv && tags.armv !== armv)
        return false;
      if (tags.libc && tags.libc !== libc)
        return false;
      return true;
    };
  };
  var runtimeAgnostic = function(tags) {
    return tags.runtime === "node" && tags.napi;
  };
  var compareTags = function(runtime2) {
    return function(a, b) {
      if (a.runtime !== b.runtime) {
        return a.runtime === runtime2 ? -1 : 1;
      } else if (a.abi !== b.abi) {
        return a.abi ? -1 : 1;
      } else if (a.specificity !== b.specificity) {
        return a.specificity > b.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  };
  var isNwjs = function() {
    return !!(process.versions && process.versions.nw);
  };
  var isElectron = function() {
    if (process.versions && process.versions.electron)
      return true;
    if (process.env.ELECTRON_RUN_AS_NODE)
      return true;
    return typeof window !== "undefined" && window.process && window.process.type === "renderer";
  };
  var isAlpine = function(platform2) {
    return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
  };
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
  var vars = process.config && process.config.variables || {};
  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
  var abi = process.versions.modules;
  var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
  var arch = process.env.npm_config_arch || os.arch();
  var platform = process.env.npm_config_platform || os.platform();
  var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
  var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
  var uv = (process.versions.uv || "").split(".")[0];
  module.exports = load;
  load.resolve = load.path = function(dir) {
    dir = path.resolve(dir || ".");
    try {
      var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
      if (process.env[name + "_PREBUILD"])
        dir = process.env[name + "_PREBUILD"];
    } catch (err) {
    }
    if (!prebuildsOnly) {
      var release = getFirst(path.join(dir, "build/Release"), matchBuild);
      if (release)
        return release;
      var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
      if (debug)
        return debug;
    }
    var prebuild = resolve(dir);
    if (prebuild)
      return prebuild;
    var nearby = resolve(path.dirname(process.execPath));
    if (nearby)
      return nearby;
    var target = [
      "platform=" + platform,
      "arch=" + arch,
      "runtime=" + runtime,
      "abi=" + abi,
      "uv=" + uv,
      armv ? "armv=" + armv : "",
      "libc=" + libc,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ === "function" ? "webpack=true" : ""
    ].filter(Boolean).join(" ");
    throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
    function resolve(dir2) {
      var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
      var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
      if (!tuple)
        return;
      var prebuilds = path.join(dir2, "prebuilds", tuple.name);
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime, abi));
      var winner = candidates.sort(compareTags(runtime))[0];
      if (winner)
        return path.join(prebuilds, winner.file);
    }
  };
  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS((exports, module) => {
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
  if (typeof runtimeRequire.addon === "function") {
    module.exports = runtimeRequire.addon.bind(runtimeRequire);
  } else {
    module.exports = require_node_gyp_build();
  }
});

// node_modules/bufferutil/fallback.js
var require_fallback = __commonJS((exports, module) => {
  var mask = (source, mask2, output, offset, length) => {
    for (var i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask2[i & 3];
    }
  };
  var unmask = (buffer, mask2) => {
    const length = buffer.length;
    for (var i = 0;i < length; i++) {
      buffer[i] ^= mask2[i & 3];
    }
  };
  module.exports = { mask, unmask };
});

// node_modules/bufferutil/index.js
var require_bufferutil = __commonJS((exports, module) => {
  var __dirname = "/Users/ppegu/Projects/Raydium/RaydiumSwapBot/node_modules/bufferutil";
  try {
    module.exports = require_node_gyp_build2()(__dirname);
  } catch (e) {
    module.exports = require_fallback();
  }
});

// node_modules/rpc-websockets/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var concat = function(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  };
  var _mask = function(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  };
  var _unmask = function(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  };
  var toArrayBuffer = function(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  };
  var toBuffer = function(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  };
  var { EMPTY_BUFFER } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = require_bufferutil();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {
    }
  }
});

// node_modules/rpc-websockets/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/rpc-websockets/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var deflateOnData = function(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  };
  var inflateOnData = function(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  };
  var inflateOnError = function(err) {
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  };
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
});

// node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS((exports, module) => {
  var isValidUTF8 = function(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  };
  module.exports = isValidUTF8;
});

// node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS((exports, module) => {
  var __dirname = "/Users/ppegu/Projects/Raydium/RaydiumSwapBot/node_modules/utf-8-validate";
  try {
    module.exports = require_node_gyp_build2()(__dirname);
  } catch (e) {
    module.exports = require_fallback2();
  }
});

// node_modules/rpc-websockets/node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var isValidStatusCode = function(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  };
  var _isValidUTF8 = function(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  };
  var { isUtf8 } = __require("buffer");
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = require_utf_8_validate();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {
    }
  }
});

// node_modules/rpc-websockets/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var queueMicrotaskShim = function(cb) {
    promise.then(cb).catch(throwErrorNextTick);
  };
  var throwError = function(err) {
    throw err;
  };
  var throwErrorNextTick = function(err) {
    process.nextTick(throwError, err);
  };
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var promise = Promise.resolve();
  var queueTask = typeof queueMicrotask === "function" ? queueMicrotask : queueMicrotaskShim;
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._allowSynchronousEvents = !!options.allowSynchronousEvents;
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (!this._fragmented) {
          const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error);
          return;
        }
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
      } else {
        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error);
          return;
        }
      } else if (this._masked) {
        const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          queueTask(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          queueTask(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error);
            return;
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        queueTask(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  module.exports = Receiver;
});

// node_modules/rpc-websockets/node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER } = require_constants();
  var { isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          randomFillSync(mask, 0, 4);
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      if (perMessageDeflate) {
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }), cb);
      }
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          if (typeof cb === "function")
            cb(err);
          for (let i = 0;i < this._queue.length; i++) {
            const params = this._queue[i];
            const callback = params[params.length - 1];
            if (typeof callback === "function")
              callback(err);
          }
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._deflating = false;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (!this._deflating && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
});

// node_modules/rpc-websockets/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var callListener = function(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  };
  var { kForOnEventAttribute, kListener } = require_constants();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
});

// node_modules/rpc-websockets/node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var push = function(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  };
  var parse = function(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  };
  var format = function(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  };
  var { tokenChars } = require_validation();
  module.exports = { format, parse };
});

// node_modules/rpc-websockets/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var initAsClient = function(websocket, address, protocols, options) {
    const opts = {
      allowSynchronousEvents: false,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect : netConnect;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      if (res.headers.upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  };
  var emitErrorAndClose = function(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit("error", err);
    websocket.emitClose();
  };
  var netConnect = function(options) {
    options.path = options.socketPath;
    return net.connect(options);
  };
  var tlsConnect = function(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  };
  var abortHandshake = function(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  };
  var sendAfterClose = function(websocket, data, cb) {
    if (data) {
      const length = toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  };
  var receiverOnConclude = function(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  };
  var receiverOnDrain = function() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  };
  var receiverOnError = function(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    websocket.emit("error", err);
  };
  var receiverOnFinish = function() {
    this[kWebSocket].emitClose();
  };
  var receiverOnMessage = function(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  };
  var receiverOnPing = function(data) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong)
      websocket.pong(data, !this._isServer, NOOP);
    websocket.emit("ping", data);
  };
  var receiverOnPong = function(data) {
    this[kWebSocket].emit("pong", data);
  };
  var resume = function(stream) {
    stream.resume();
  };
  var socketOnClose = function() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  };
  var socketOnData = function(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  };
  var socketOnEnd = function() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  };
  var socketOnError = function() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  };
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._autoPong = options.autoPong;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        allowSynchronousEvents: options.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      this._sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket;
});

// node_modules/rpc-websockets/node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var emitClose = function(stream) {
    stream.emit("close");
  };
  var duplexOnEnd = function() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  };
  var duplexOnError = function(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  };
  var createWebSocketStream = function(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  };
  var { Duplex } = __require("stream");
  module.exports = createWebSocketStream;
});

// node_modules/rpc-websockets/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var parse = function(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  };
  var { tokenChars } = require_validation();
  module.exports = { parse };
});

// node_modules/rpc-websockets/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var addListeners = function(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  };
  var emitClose = function(server) {
    server._state = CLOSED;
    server.emit("close");
  };
  var socketOnError = function() {
    this.destroy();
  };
  var abortHandshake = function(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
  };
  var abortHandshakeOrEmitwsClientError = function(server, req, socket, code, message) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message);
    }
  };
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket();
  var { GUID, kWebSocket } = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        allowSynchronousEvents: false,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (req.headers.upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!key || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 8 && version !== 13) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat("\r\n").join("\r\n"));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
});

// node_modules/rpc-websockets/node_modules/ws/index.js
var require_ws = __commonJS((exports, module) => {
  var WebSocket = require_websocket();
  WebSocket.createWebSocketStream = require_stream();
  WebSocket.Server = require_websocket_server();
  WebSocket.Receiver = require_receiver();
  WebSocket.Sender = require_sender();
  WebSocket.WebSocket = WebSocket;
  WebSocket.WebSocketServer = WebSocket.Server;
  module.exports = WebSocket;
});

// node_modules/rpc-websockets/dist/lib/client/websocket.js
var require_websocket2 = __commonJS((exports) => {
  var _default = function(address, options) {
    return new _ws["default"](address, options);
  };
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  var _ws = _interopRequireDefault(require_ws());
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS((exports) => {
  var keccakP = function(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds;round < 24; round++) {
      for (let x = 0;x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0;x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0;y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0;t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0;y < 50; y += 10) {
        for (let x = 0;x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0;x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = undefined;
  var _assert_js_1 = require__assert();
  var _u64_js_1 = require__u64();
  var utils_js_1 = require_utils();
  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _7n = BigInt(7);
  var _256n = BigInt(256);
  var _0x71n = BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0;j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
  var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
  exports.keccakP = keccakP;

  class Keccak extends utils_js_1.Hash {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      (0, _assert_js_1.number)(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      (0, _assert_js_1.exists)(this);
      const { blockLen, state } = this;
      data = (0, utils_js_1.toBytes)(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0;i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      (0, _assert_js_1.exists)(this, false);
      (0, _assert_js_1.bytes)(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length;pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes) {
      (0, _assert_js_1.number)(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
      (0, _assert_js_1.output)(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  }
  exports.Keccak = Keccak;
  var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
  exports.sha3_224 = gen(6, 144, 224 / 8);
  exports.sha3_256 = gen(6, 136, 256 / 8);
  exports.sha3_384 = gen(6, 104, 384 / 8);
  exports.sha3_512 = gen(6, 72, 512 / 8);
  exports.keccak_224 = gen(1, 144, 224 / 8);
  exports.keccak_256 = gen(1, 136, 256 / 8);
  exports.keccak_384 = gen(1, 104, 384 / 8);
  exports.keccak_512 = gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
  exports.shake128 = genShake(31, 168, 128 / 8);
  exports.shake256 = genShake(31, 136, 256 / 8);
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS((exports) => {
  var validatePointOpts = function(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp, a } = opts;
    if (endo) {
      if (!Fp.eql(a, Fp.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  };
  var weierstrassPoints = function(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE;
    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
      const a = point.toAffine();
      return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes) => {
      const tail = bytes.subarray(1);
      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
      return { x, y };
    });
    function weierstrassEquation(x) {
      const { a, b } = CURVE;
      const x2 = Fp.sqr(x);
      const x3 = Fp.mul(x2, x);
      return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
    }
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return typeof num === "bigint" && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (ut.isBytes(key))
          key = ut.bytesToHex(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
      } catch (error) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod.mod(num, n);
      assertGE(num);
      return num;
    }
    const pointPrecomputes = new Map;
    function assertPrjPoint(other) {
      if (!(other instanceof Point))
        throw new Error("ProjectivePoint expected");
    }

    class Point {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp.isValid(pz))
          throw new Error("z required");
      }
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp.eql(i, Fp.ZERO);
        if (is0(x) && is0(y))
          return Point.ZERO;
        return new Point(x, y, Fp.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        const toInv = Fp.invertBatch(points.map((p) => p.pz));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      }
      static fromHex(hex) {
        const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = this.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        if (!Fp.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (Fp.isOdd)
          return !Fp.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
        const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
        return U1 && U2;
      }
      negate() {
        return new Point(this.px, Fp.neg(this.py), this.pz);
      }
      double() {
        const { a, b } = CURVE;
        const b3 = Fp.mul(b, _3n);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
        let t0 = Fp.mul(X1, X1);
        let t1 = Fp.mul(Y1, Y1);
        let t2 = Fp.mul(Z1, Z1);
        let t3 = Fp.mul(X1, Y1);
        t3 = Fp.add(t3, t3);
        Z3 = Fp.mul(X1, Z1);
        Z3 = Fp.add(Z3, Z3);
        X3 = Fp.mul(a, Z3);
        Y3 = Fp.mul(b3, t2);
        Y3 = Fp.add(X3, Y3);
        X3 = Fp.sub(t1, Y3);
        Y3 = Fp.add(t1, Y3);
        Y3 = Fp.mul(X3, Y3);
        X3 = Fp.mul(t3, X3);
        Z3 = Fp.mul(b3, Z3);
        t2 = Fp.mul(a, t2);
        t3 = Fp.sub(t0, t2);
        t3 = Fp.mul(a, t3);
        t3 = Fp.add(t3, Z3);
        Z3 = Fp.add(t0, t0);
        t0 = Fp.add(Z3, t0);
        t0 = Fp.add(t0, t2);
        t0 = Fp.mul(t0, t3);
        Y3 = Fp.add(Y3, t0);
        t2 = Fp.mul(Y1, Z1);
        t2 = Fp.add(t2, t2);
        t0 = Fp.mul(t2, t3);
        X3 = Fp.sub(X3, t0);
        Z3 = Fp.mul(t2, t1);
        Z3 = Fp.add(Z3, Z3);
        Z3 = Fp.add(Z3, Z3);
        return new Point(X3, Y3, Z3);
      }
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
        const a = CURVE.a;
        const b3 = Fp.mul(CURVE.b, _3n);
        let t0 = Fp.mul(X1, X2);
        let t1 = Fp.mul(Y1, Y2);
        let t2 = Fp.mul(Z1, Z2);
        let t3 = Fp.add(X1, Y1);
        let t4 = Fp.add(X2, Y2);
        t3 = Fp.mul(t3, t4);
        t4 = Fp.add(t0, t1);
        t3 = Fp.sub(t3, t4);
        t4 = Fp.add(X1, Z1);
        let t5 = Fp.add(X2, Z2);
        t4 = Fp.mul(t4, t5);
        t5 = Fp.add(t0, t2);
        t4 = Fp.sub(t4, t5);
        t5 = Fp.add(Y1, Z1);
        X3 = Fp.add(Y2, Z2);
        t5 = Fp.mul(t5, X3);
        X3 = Fp.add(t1, t2);
        t5 = Fp.sub(t5, X3);
        Z3 = Fp.mul(a, t4);
        X3 = Fp.mul(b3, t2);
        Z3 = Fp.add(X3, Z3);
        X3 = Fp.sub(t1, Z3);
        Z3 = Fp.add(t1, Z3);
        Y3 = Fp.mul(X3, Z3);
        t1 = Fp.add(t0, t0);
        t1 = Fp.add(t1, t0);
        t2 = Fp.mul(a, t2);
        t4 = Fp.mul(b3, t4);
        t1 = Fp.add(t1, t2);
        t2 = Fp.sub(t0, t2);
        t2 = Fp.mul(a, t2);
        t4 = Fp.add(t4, t2);
        t0 = Fp.mul(t1, t4);
        Y3 = Fp.add(Y3, t0);
        t0 = Fp.mul(t5, t4);
        X3 = Fp.mul(t3, X3);
        X3 = Fp.sub(X3, t0);
        t0 = Fp.mul(t3, t1);
        Z3 = Fp.mul(t5, Z3);
        Z3 = Fp.add(Z3, t0);
        return new Point(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
          const toInv = Fp.invertBatch(comp.map((p) => p.pz));
          return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        });
      }
      multiplyUnsafe(n) {
        const I = Point.ZERO;
        if (n === _0n)
          return I;
        assertGE(n);
        if (n === _1n)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n);
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = I;
        let k2p = I;
        let d = this;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n)
            k1p = k1p.add(d);
          if (k2 & _1n)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n;
          k2 >>= _1n;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      multiply(scalar) {
        assertGE(scalar);
        let n = scalar;
        let point, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f } = this.wNAF(n);
          point = p;
          fake = f;
        }
        return Point.normalizeZ([point, fake])[0];
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const G = Point.BASE;
        const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul(this, a).add(mul(Q, b));
        return sum.is0() ? undefined : sum;
      }
      toAffine(iz) {
        const { px: x, py: y, pz: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n)
          return this;
        if (clearCofactor)
          return clearCofactor(Point, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        this.assertValidity();
        return toBytes(Point, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return ut.bytesToHex(this.toRawBytes(isCompressed));
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  };
  var validateOpts = function(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  };
  var weierstrass = function(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1;
    const uncompressedLen = 2 * Fp.BYTES + 1;
    function isValidFieldElement(num) {
      return _0n < num && num < Fp.ORDER;
    }
    function modN(a) {
      return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return mod.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(_c, point, isCompressed) {
        const a = point.toAffine();
        const x = Fp.toBytes(a.x);
        const cat = ut.concatBytes;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
        }
      },
      fromBytes(bytes) {
        const len = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x = ut.bytesToNumberBE(tail);
          if (!isValidFieldElement(x))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y = Fp.sqrt(y2);
          const isYOdd = (y & _1n) === _1n;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp.neg(y);
          return { x, y };
        } else if (len === uncompressedLen && head === 4) {
          const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
          const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
          return { x, y };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
      const HALF = CURVE_ORDER >> _1n;
      return number > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));

    class Signature {
      constructor(r, s, recovery) {
        this.r = r;
        this.s = s;
        this.recovery = recovery;
        this.assertValidity();
      }
      static fromCompact(hex) {
        const l = CURVE.nByteLength;
        hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
        return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      static fromDER(hex) {
        const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
        return new Signature(r, s);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s, recovery: rec } = this;
        const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R = Point.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN(-h * ir);
        const u2 = modN(s * ir);
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return ut.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return exports.DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return ut.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      randomPrivateKey: () => {
        const length = mod.getMinHashLength(CURVE.n);
        return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
      },
      precompute(windowSize = 8, point = Point.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = ut.isBytes(item);
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b = Point.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes) {
      const num = ut.bytesToNumberBE(bytes);
      const delta = bytes.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
      return modN(bits2int(bytes));
    };
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => (k in opts)))
        throw new Error("sign() legacy options not supported");
      const { hash, randomBytes } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
      if (prehash)
        msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null) {
        const e = ent === true ? randomBytes(Fp.BYTES) : ent;
        seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
      }
      const seed = ut.concatBytes(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!isWithinCurveOrder(k))
          return;
        const ik = invN(k);
        const q = Point.BASE.multiply(k).toAffine();
        const r = modN(q.x);
        if (r === _0n)
          return;
        const s = modN(ik * modN(m + r * d));
        if (s === _0n)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE;
      const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
      publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = undefined;
      let P;
      try {
        if (typeof sg === "string" || ut.isBytes(sg)) {
          try {
            _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof exports.DER.Err))
              throw derError;
            _sig = Signature.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s2 } = sg;
          _sig = new Signature(r2, s2);
        } else {
          throw new Error("PARSE");
        }
        P = Point.fromHex(publicKey);
      } catch (error) {
        if (error.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is = invN(s);
      const u1 = modN(h * is);
      const u2 = modN(r * is);
      const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
      if (!R)
        return false;
      const v = modN(R.x);
      return v === r;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign,
      verify,
      ProjectivePoint: Point,
      Signature,
      utils
    };
  };
  var SWUFpSqrtRatio = function(Fp, Z) {
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n;o % _2n === _0n; o /= _2n)
      l += _1n;
    const c1 = l;
    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1;
    const c3 = (c2 - _1n) / _2n;
    const c4 = _2n_pow_c1 - _1n;
    const c5 = _2n_pow_c1_1;
    const c6 = Fp.pow(Z, c2);
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
    let sqrtRatio = (u, v) => {
      let tv1 = c6;
      let tv2 = Fp.pow(v, c4);
      let tv3 = Fp.sqr(tv2);
      tv3 = Fp.mul(tv3, v);
      let tv5 = Fp.mul(u, tv3);
      tv5 = Fp.pow(tv5, c3);
      tv5 = Fp.mul(tv5, tv2);
      tv2 = Fp.mul(tv5, v);
      tv3 = Fp.mul(tv5, u);
      let tv4 = Fp.mul(tv3, tv2);
      tv5 = Fp.pow(tv4, c5);
      let isQR = Fp.eql(tv5, Fp.ONE);
      tv2 = Fp.mul(tv3, c7);
      tv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, isQR);
      tv4 = Fp.cmov(tv5, tv4, isQR);
      for (let i = c1;i > _1n; i--) {
        let tv52 = i - _2n;
        tv52 = _2n << tv52 - _1n;
        let tvv5 = Fp.pow(tv4, tv52);
        const e1 = Fp.eql(tvv5, Fp.ONE);
        tv2 = Fp.mul(tv3, tv1);
        tv1 = Fp.mul(tv1, tv1);
        tvv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, e1);
        tv4 = Fp.cmov(tvv5, tv4, e1);
      }
      return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
      const c12 = (Fp.ORDER - _3n) / _4n;
      const c22 = Fp.sqrt(Fp.neg(Z));
      sqrtRatio = (u, v) => {
        let tv1 = Fp.sqr(v);
        const tv2 = Fp.mul(u, v);
        tv1 = Fp.mul(tv1, tv2);
        let y1 = Fp.pow(tv1, c12);
        y1 = Fp.mul(y1, tv2);
        const y2 = Fp.mul(y1, c22);
        const tv3 = Fp.mul(Fp.sqr(y1), v);
        const isQR = Fp.eql(tv3, u);
        let y = Fp.cmov(y2, y1, isQR);
        return { isValid: isQR, value: y };
      };
    }
    return sqrtRatio;
  };
  var mapToCurveSimpleSWU = function(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (u) => {
      let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
      tv1 = Fp.sqr(u);
      tv1 = Fp.mul(tv1, opts.Z);
      tv2 = Fp.sqr(tv1);
      tv2 = Fp.add(tv2, tv1);
      tv3 = Fp.add(tv2, Fp.ONE);
      tv3 = Fp.mul(tv3, opts.B);
      tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
      tv4 = Fp.mul(tv4, opts.A);
      tv2 = Fp.sqr(tv3);
      tv6 = Fp.sqr(tv4);
      tv5 = Fp.mul(tv6, opts.A);
      tv2 = Fp.add(tv2, tv5);
      tv2 = Fp.mul(tv2, tv3);
      tv6 = Fp.mul(tv6, tv4);
      tv5 = Fp.mul(tv6, opts.B);
      tv2 = Fp.add(tv2, tv5);
      x = Fp.mul(tv1, tv3);
      const { isValid, value } = sqrtRatio(tv2, tv6);
      y = Fp.mul(tv1, u);
      y = Fp.mul(y, value);
      x = Fp.cmov(x, tv3, isValid);
      y = Fp.cmov(y, value, isValid);
      const e1 = Fp.isOdd(u) === Fp.isOdd(y);
      y = Fp.cmov(Fp.neg(y), y, e1);
      x = Fp.div(x, tv4);
      return { x, y };
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var mod = require_modular();
  var ut = require_utils2();
  var utils_js_1 = require_utils2();
  var curve_js_1 = require_curve();
  var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
  exports.DER = {
    Err: class DERErr extends Error {
      constructor(m = "") {
        super(m);
      }
    },
    _parseInt(data) {
      const { Err: E } = exports.DER;
      if (data.length < 2 || data[0] !== 2)
        throw new E("Invalid signature integer tag");
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len)
        throw new E("Invalid signature integer: wrong length");
      if (res[0] & 128)
        throw new E("Invalid signature integer: negative");
      if (res[0] === 0 && !(res[1] & 128))
        throw new E("Invalid signature integer: unnecessary leading zero");
      return { d: b2n(res), l: data.subarray(len + 2) };
    },
    toSig(hex) {
      const { Err: E } = exports.DER;
      const data = typeof hex === "string" ? h2b(hex) : hex;
      if (!ut.isBytes(data))
        throw new Error("ui8a expected");
      let l = data.length;
      if (l < 2 || data[0] != 48)
        throw new E("Invalid signature tag");
      if (data[1] !== l - 2)
        throw new E("Invalid signature: incorrect length");
      const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
      const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
      if (rBytesLeft.length)
        throw new E("Invalid signature: left bytes after parsing");
      return { r, s };
    },
    hexFromSig(sig) {
      const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
      const h = (num) => {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      };
      const s = slice(h(sig.s));
      const r = slice(h(sig.r));
      const shl = s.length / 2;
      const rhl = r.length / 2;
      const sl = h(shl);
      const rl = h(rhl);
      return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    }
  };
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _3n = BigInt(3);
  var _4n = BigInt(4);
  exports.weierstrassPoints = weierstrassPoints;
  exports.weierstrass = weierstrass;
  exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
  exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmac = exports.HMAC = undefined;
  var _assert_js_1 = require__assert();
  var utils_js_1 = require_utils();

  class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      (0, _assert_js_1.hash)(hash);
      const key = (0, utils_js_1.toBytes)(_key);
      this.iHash = hash.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
      for (let i = 0;i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash.create();
      for (let i = 0;i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      (0, _assert_js_1.exists)(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      (0, _assert_js_1.exists)(this);
      (0, _assert_js_1.bytes)(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  }
  exports.HMAC = HMAC;
  var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
  exports.hmac = hmac;
  exports.hmac.create = (hash, key) => new HMAC(hash, key);
});

// node_modules/@noble/curves/_shortw_utils.js
var require__shortw_utils = __commonJS((exports) => {
  var getHash = function(hash) {
    return {
      hash,
      hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
      randomBytes: utils_1.randomBytes
    };
  };
  var createCurve = function(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
    return Object.freeze({ ...create(defHash), create });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createCurve = exports.getHash = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var hmac_1 = require_hmac();
  var utils_1 = require_utils();
  var weierstrass_js_1 = require_weierstrass();
  exports.getHash = getHash;
  exports.createCurve = createCurve;
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS((exports) => {
  var sqrtMod = function(y) {
    const P = secp256k1P;
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
    const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
    const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
    const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
    const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
    const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
    const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
    const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
    const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
    const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
    const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
    const root = (0, modular_js_1.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  };
  var taggedHash = function(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
      const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
  };
  var schnorrGetExtPubKey = function(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
    let p = Point.fromPrivateKey(d_);
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return { scalar, bytes: pointToBytes(p) };
  };
  var lift_x = function(x) {
    if (!fe(x))
      throw new Error("bad x: need 0 < x < p");
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7));
    let y = sqrtMod(c);
    if (y % _2n !== _0n)
      y = modP(-y);
    const p = new Point(x, y, _1n);
    p.assertValidity();
    return p;
  };
  var challenge = function(...args) {
    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
  };
  var schnorrGetPublicKey = function(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes;
  };
  var schnorrSign = function(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
    const m = (0, utils_js_1.ensureBytes)("message", message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
    const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
    const rand = taggedHash("BIP0340/nonce", t, px, m);
    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
    if (k_ === _0n)
      throw new Error("sign failed: k is zero");
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
    const e = challenge(rx, px, m);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    if (!schnorrVerify(sig, m, px))
      throw new Error("sign: Invalid signature produced");
    return sig;
  };
  var schnorrVerify = function(signature, message, publicKey) {
    const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
    const m = (0, utils_js_1.ensureBytes)("message", message);
    const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
    try {
      const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
      const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
      if (!fe(r))
        return false;
      const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
      if (!ge(s))
        return false;
      const e = challenge(numTo32b(r), pointToBytes(P), m);
      const R = GmulAdd(P, s, modN(-e));
      if (!R || !R.hasEvenY() || R.toAffine().x !== r)
        return false;
      return true;
    } catch (error) {
      return false;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var sha256_1 = require_sha256();
  var utils_1 = require_utils();
  var modular_js_1 = require_modular();
  var weierstrass_js_1 = require_weierstrass();
  var utils_js_1 = require_utils2();
  var hash_to_curve_js_1 = require_hash_to_curve();
  var _shortw_utils_js_1 = require__shortw_utils();
  var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var divNearest = (a, b) => (a + b / _2n) / b;
  var Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
  exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
        let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256_1.sha256);
  var _0n = BigInt(0);
  var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
  var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
  var TAGGED_HASH_PREFIXES = {};
  var pointToBytes = (point) => point.toRawBytes(true).slice(1);
  var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
  var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
  var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
  var Point = exports.secp256k1.ProjectivePoint;
  var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
  exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
      lift_x,
      pointToBytes,
      numberToBytesBE: utils_js_1.numberToBytesBE,
      bytesToNumberBE: utils_js_1.bytesToNumberBE,
      taggedHash,
      mod: modular_js_1.mod
    }
  }))();
  var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
  ].map((i) => i.map((j) => BigInt(j)))))();
  var mapSWU = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Fp.create(BigInt("-11"))
  }))();
  var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
    const { x, y } = mapSWU(Fp.create(scalars[0]));
    return isoMap(x, y);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha256_1.sha256
  }))();
  exports.hashToCurve = (() => htf.hashToCurve)();
  exports.encodeToCurve = (() => htf.encodeToCurve)();
});

// node_modules/base-x/src/index.js
var require_src3 = __commonJS((exports, module) => {
  var base = function(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode(source) {
      if (source instanceof Uint8Array) {
      } else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode(string) {
      var buffer2 = decodeUnsafe(string);
      if (buffer2) {
        return buffer2;
      }
      throw new Error("Non-base" + BASE + " character");
    }
    return {
      encode,
      decodeUnsafe,
      decode
    };
  };
  module.exports = base;
});

// node_modules/bs58/index.js
var require_bs583 = __commonJS((exports, module) => {
  var basex = require_src3();
  var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET);
});

// src/raydium-swap.js
import {createRequire as createImportMetaRequire} from "module";

// node_modules/@solana/web3.js/lib/index.cjs.js
var _interopDefaultCompat = function(e) {
  return e && typeof e === "object" && "default" in e ? e : { default: e };
};
var _interopNamespaceCompat = function(e) {
  if (e && typeof e === "object" && "default" in e)
    return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function(k) {
      if (k !== "default") {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
};
var isOnCurve = function(publicKey) {
  try {
    ed25519.ed25519.ExtendedPoint.fromHex(publicKey);
    return true;
  } catch {
    return false;
  }
};
var isPublicKeyData = function(value) {
  return value._bn !== undefined;
};
var getAlloc = function(type, fields) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    return 0;
  };
  let alloc = 0;
  type.layout.fields.forEach((item) => {
    alloc += getItemAlloc(item);
  });
  return alloc;
};
var decodeLength = function(bytes) {
  let len = 0;
  let size = 0;
  for (;; ) {
    let elem = bytes.shift();
    len |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len;
};
var encodeLength = function(bytes, len) {
  let rem_len = len;
  for (;; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 128;
      bytes.push(elem);
    }
  }
};
var assert = function(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
};
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      signature,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature
    }, options && options.commitment)).value;
  } else {
    if (options?.abortSignal != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  }
  if (status.err) {
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}
var sleep = function(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
};
var encodeData = function(type, fields) {
  const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
  const data = buffer.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type.index
  }, fields);
  type.layout.encode(layoutFields, data);
  return data;
};
var getDefaultExportFromCjs = function(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
};
var parse = function(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return;
  }
};
var fmtShort = function(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + "s";
  }
  return ms + "ms";
};
var fmtLong = function(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, "second");
  }
  return ms + " ms";
};
var plural = function(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
};
var deprecate = function(message) {
  console.log("[agentkeepalive:deprecated] %s", message);
};
var getSocketTimeout = function(socket) {
  return socket.timeout || socket._idleTimeout;
};
var installListeners = function(agent, socket, options) {
  debug("%s create, timeout %sms", socket[SOCKET_NAME], getSocketTimeout(socket));
  function onFree() {
    if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1)
      return;
    socket[SOCKET_REQUEST_FINISHED_COUNT]++;
    agent.requestCount++;
    debug("%s(requests: %s, finished: %s) free", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
    const name = agent.getName(options);
    if (socket.writable && agent.requests[name] && agent.requests[name].length) {
      socket[SOCKET_REQUEST_COUNT]++;
      debug("%s(requests: %s, finished: %s) will be reuse on agent free event", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
    }
  }
  socket.on("free", onFree);
  function onClose(isError) {
    debug("%s(requests: %s, finished: %s) close, isError: %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);
    agent.closeSocketCount++;
  }
  socket.on("close", onClose);
  function onTimeout() {
    const listenerCount = socket.listeners("timeout").length;
    const timeout = getSocketTimeout(socket);
    const req = socket._httpMessage;
    const reqTimeoutListenerCount = req && req.listeners("timeout").length || 0;
    debug("%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);
    if (debug.enabled) {
      debug("timeout listeners: %s", socket.listeners("timeout").map((f) => f.name).join(", "));
    }
    agent.timeoutSocketCount++;
    const name = agent.getName(options);
    if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {
      socket.destroy();
      agent.removeSocket(socket, options);
      debug("%s is free, destroy quietly", socket[SOCKET_NAME]);
    } else {
      if (reqTimeoutListenerCount === 0) {
        const error = new Error("Socket timeout");
        error.code = "ERR_SOCKET_TIMEOUT";
        error.timeout = timeout;
        socket.destroy(error);
        agent.removeSocket(socket, options);
        debug("%s destroy with timeout error", socket[SOCKET_NAME]);
      }
    }
  }
  socket.on("timeout", onTimeout);
  function onError(err) {
    const listenerCount = socket.listeners("error").length;
    debug("%s(requests: %s, finished: %s) error: %s, listenerCount: %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);
    agent.errorSocketCount++;
    if (listenerCount === 1) {
      debug("%s emit uncaught error event", socket[SOCKET_NAME]);
      socket.removeListener("error", onError);
      socket.emit("error", err);
    }
  }
  socket.on("error", onError);
  function onRemove() {
    debug("%s(requests: %s, finished: %s) agentRemove", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
    socket.removeListener("close", onClose);
    socket.removeListener("error", onError);
    socket.removeListener("free", onFree);
    socket.removeListener("timeout", onTimeout);
    socket.removeListener("agentRemove", onRemove);
  }
  socket.on("agentRemove", onRemove);
};
var inspect = function(obj) {
  const res = {};
  for (const key in obj) {
    res[key] = obj[key].length;
  }
  return res;
};
var stringify = function(val, isArrayProp) {
  var i, max, str, keys, key, propVal, toStr;
  if (val === true) {
    return "true";
  }
  if (val === false) {
    return "false";
  }
  switch (typeof val) {
    case "object":
      if (val === null) {
        return null;
      } else if (val.toJSON && typeof val.toJSON === "function") {
        return stringify(val.toJSON(), isArrayProp);
      } else {
        toStr = objToString.call(val);
        if (toStr === "[object Array]") {
          str = "[";
          max = val.length - 1;
          for (i = 0;i < max; i++) {
            str += stringify(val[i], true) + ",";
          }
          if (max > -1) {
            str += stringify(val[i], true);
          }
          return str + "]";
        } else if (toStr === "[object Object]") {
          keys = objKeys(val).sort();
          max = keys.length;
          str = "";
          i = 0;
          while (i < max) {
            key = keys[i];
            propVal = stringify(val[key], false);
            if (propVal !== undefined) {
              if (str) {
                str += ",";
              }
              str += JSON.stringify(key) + ":" + propVal;
            }
            i++;
          }
          return "{" + str + "}";
        } else {
          return JSON.stringify(val);
        }
      }
    case "function":
    case "undefined":
      return isArrayProp ? null : undefined;
    case "string":
      return JSON.stringify(val);
    default:
      return isFinite(val) ? val : null;
  }
};
var trailingZeros = function(n) {
  let trailingZeros2 = 0;
  while (n > 1) {
    n /= 2;
    trailingZeros2++;
  }
  return trailingZeros2;
};
var nextPowerOfTwo = function(n) {
  if (n === 0)
    return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  return n + 1;
};
var decodeData = function(type, data) {
  let decoded;
  try {
    decoded = type.layout.decode(data);
  } catch (err) {
    throw new Error("invalid instruction; " + err);
  }
  if (decoded.typeIndex !== type.index) {
    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);
  }
  return decoded;
};
var makeWebsocketUrl = function(endpoint) {
  const matches = endpoint.match(URL_RE);
  if (matches == null) {
    throw TypeError(`Failed to validate endpoint URL \`${endpoint}\``);
  }
  const [
    _,
    hostish,
    portWithColon,
    rest
  ] = matches;
  const protocol = endpoint.startsWith("https:") ? "wss:" : "ws:";
  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  const websocketPort = startPort == null ? "" : `:${startPort + 1}`;
  return `${protocol}//${hostish}${websocketPort}${rest}`;
};
var assertEndpointUrl = function(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  }
  return putativeUrl;
};
var extractCommitmentFromConfig = function(commitmentOrConfig) {
  let commitment;
  let config;
  if (typeof commitmentOrConfig === "string") {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    const {
      commitment: specifiedCommitment,
      ...specifiedConfig
    } = commitmentOrConfig;
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment,
    config
  };
};
var createRpcResult = function(result) {
  return superstruct.union([superstruct.type({
    jsonrpc: superstruct.literal("2.0"),
    id: superstruct.string(),
    result
  }), superstruct.type({
    jsonrpc: superstruct.literal("2.0"),
    id: superstruct.string(),
    error: superstruct.type({
      code: superstruct.unknown(),
      message: superstruct.string(),
      data: superstruct.optional(superstruct.any())
    })
  })]);
};
var jsonRpcResult = function(schema) {
  return superstruct.coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: superstruct.create(value.result, schema)
      };
    }
  });
};
var jsonRpcResultAndContext = function(value) {
  return jsonRpcResult(superstruct.type({
    context: superstruct.type({
      slot: superstruct.number()
    }),
    value
  }));
};
var notificationResultAndContext = function(value) {
  return superstruct.type({
    context: superstruct.type({
      slot: superstruct.number()
    }),
    value
  });
};
var versionedMessageFromResponse = function(version, response) {
  if (version === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey(accountKey)),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: bs58__default.default.decode(ix.data)
      })),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
};
var createRpcClient = function(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  const fetch = customFetch ? customFetch : fetchImpl;
  let agent;
  {
    if (httpAgent == null) {
      {
        const agentOptions = {
          freeSocketTimeout: 19000,
          keepAlive: true,
          maxSockets: 25
        };
        if (url.startsWith("https:")) {
          agent = new HttpsAgent2(agentOptions);
        } else {
          agent = new HttpKeepAliveAgent(agentOptions);
        }
      }
    } else {
      if (httpAgent !== false) {
        const isHttps = url.startsWith("https:");
        if (isHttps && !(httpAgent instanceof require$$0$2.Agent)) {
          throw new Error("The endpoint `" + url + "` can only be paired with an `https.Agent`. You have, instead, supplied an `http.Agent` through `httpAgent`.");
        } else if (!isHttps && httpAgent instanceof require$$0$2.Agent) {
          throw new Error("The endpoint `" + url + "` can only be paired with an `http.Agent`. You have, instead, supplied an `https.Agent` through `httpAgent`.");
        }
        agent = httpAgent;
      }
    }
  }
  let fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = async (info, init) => {
      const modifiedFetchArgs = await new Promise((resolve, reject) => {
        try {
          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
        } catch (error) {
          reject(error);
        }
      });
      return await fetch(...modifiedFetchArgs);
    };
  }
  const clientBrowser = new RpcClient__default.default(async (request, callback) => {
    const options = {
      method: "POST",
      body: request,
      agent,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, httpHeaders || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;
      for (;; ) {
        if (fetchWithMiddleware) {
          res = await fetchWithMiddleware(url, options);
        } else {
          res = await fetch(url, options);
        }
        if (res.status !== 429) {
          break;
        }
        if (disableRetryOnRateLimit === true) {
          break;
        }
        too_many_requests_retries -= 1;
        if (too_many_requests_retries === 0) {
          break;
        }
        console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep(waitTime);
        waitTime *= 2;
      }
      const text = await res.text();
      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err) {
      if (err instanceof Error)
        callback(err);
    }
  }, {});
  return clientBrowser;
};
var createRpcRequest = function(client) {
  return (method, args) => {
    return new Promise((resolve, reject) => {
      client.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
};
var createRpcBatchRequest = function(client) {
  return (requests) => {
    return new Promise((resolve, reject) => {
      if (requests.length === 0)
        resolve([]);
      const batch = requests.map((params) => {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
};
var clusterApiUrl = function(cluster, tls) {
  const key = tls === false ? "http" : "https";
  if (!cluster) {
    return endpoint[key]["devnet"];
  }
  const url = endpoint[key][cluster];
  if (!url) {
    throw new Error(`Unknown ${key} cluster: ${cluster}`);
  }
  return url;
};
var buffer = __require("buffer");
var ed25519 = require_ed25519();
var BN = require_bn();
var bs58 = require_bs58();
var sha256 = require_sha256();
var borsh = require_lib();
var BufferLayout = require_Layout();
var bigintBuffer = require_node();
var require$$0 = __require("util");
var require$$0$1 = __require("http");
var require$$0$2 = __require("https");
var superstruct = require_lib2();
var RpcClient = require_browser();
var nodeFetch = require_lib4();
var RpcWebSocketCommonClient = require_client();
var WebsocketFactory = require_websocket2();
var sha3 = require_sha3();
var secp256k1 = require_secp256k1();
var BN__default = _interopDefaultCompat(BN);
var bs58__default = _interopDefaultCompat(bs58);
var BufferLayout__namespace = _interopNamespaceCompat(BufferLayout);
var require$$0__default = _interopDefaultCompat(require$$0);
var require$$0__default$1 = _interopDefaultCompat(require$$0$1);
var require$$0__default$2 = _interopDefaultCompat(require$$0$2);
var RpcClient__default = _interopDefaultCompat(RpcClient);
var nodeFetch__namespace = _interopNamespaceCompat(nodeFetch);
var RpcWebSocketCommonClient__default = _interopDefaultCompat(RpcWebSocketCommonClient);
var WebsocketFactory__default = _interopDefaultCompat(WebsocketFactory);
var generatePrivateKey = ed25519.ed25519.utils.randomPrivateKey;
var generateKeypair = () => {
  const privateScalar = ed25519.ed25519.utils.randomPrivateKey();
  const publicKey = getPublicKey(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey, 32);
  return {
    publicKey,
    secretKey
  };
};
var getPublicKey = ed25519.ed25519.getPublicKey;
var sign = (message, secretKey) => ed25519.ed25519.sign(message, secretKey.slice(0, 32));
var verify = ed25519.ed25519.verify;
var toBuffer = (arr) => {
  if (buffer.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return buffer.Buffer.from(arr);
  }
};

class Struct {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return buffer.Buffer.from(borsh.serialize(SOLANA_SCHEMA, this));
  }
  static decode(data) {
    return borsh.deserialize(SOLANA_SCHEMA, this, data);
  }
  static decodeUnchecked(data) {
    return borsh.deserializeUnchecked(SOLANA_SCHEMA, this, data);
  }
}
var SOLANA_SCHEMA = new Map;
var _class;
var _Symbol$toStringTag;
var MAX_SEED_LENGTH = 32;
var PUBLIC_KEY_LENGTH = 32;
var uniquePublicKeyCounter = 1;
_Symbol$toStringTag = Symbol.toStringTag;

class PublicKey extends Struct {
  constructor(value) {
    super({});
    this._bn = undefined;
    if (isPublicKeyData(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = bs58__default.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new BN__default.default(decoded);
      } else {
        this._bn = new BN__default.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  static unique() {
    const key = new PublicKey(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new PublicKey(key.toBuffer());
  }
  equals(publicKey) {
    return this._bn.eq(publicKey._bn);
  }
  toBase58() {
    return bs58__default.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  toBuffer() {
    const b = this._bn.toArrayLike(buffer.Buffer);
    if (b.length === PUBLIC_KEY_LENGTH) {
      return b;
    }
    const zeroPad = buffer.Buffer.alloc(32);
    b.copy(zeroPad, 32 - b.length);
    return zeroPad;
  }
  get [_Symbol$toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha256.sha256(buffer$1);
    return new PublicKey(publicKeyBytes);
  }
  static createProgramAddressSync(seeds, programId) {
    let buffer$1 = buffer.Buffer.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer(seed)]);
    });
    buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha256.sha256(buffer$1);
    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey(publicKeyBytes);
  }
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }
}
_class = PublicKey;
PublicKey.default = new _class("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE = 1280 - 40 - 8;
var VERSION_PREFIX_MASK = 127;
var SIGNATURE_LENGTH_IN_BYTES = 64;

class TransactionExpiredBlockheightExceededError extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: block height exceeded.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});

class TransactionExpiredTimeoutError extends Error {
  constructor(signature, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + "unknown if it succeeded or failed. Check signature " + `${signature} using the Solana Explorer or CLI tools.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});

class TransactionExpiredNonceInvalidError extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: the nonce is no longer valid.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});

class MessageAccountKeys {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = undefined;
    this.accountKeysFromLookups = undefined;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = new Map;
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === undefined)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
}
var publicKey = (property = "publicKey") => {
  return BufferLayout__namespace.blob(32, property);
};
var rustString = (property = "string") => {
  const rsl = BufferLayout__namespace.struct([BufferLayout__namespace.u32("length"), BufferLayout__namespace.u32("lengthPadding"), BufferLayout__namespace.blob(BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b, offset) => {
    const data = _decode(b, offset);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b, offset) => {
    const data = {
      chars: buffer.Buffer.from(str, "utf8")
    };
    return _encode(data, b, offset);
  };
  rslShim.alloc = (str) => {
    return BufferLayout__namespace.u32().span + BufferLayout__namespace.u32().span + buffer.Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized = (property = "authorized") => {
  return BufferLayout__namespace.struct([publicKey("staker"), publicKey("withdrawer")], property);
};
var lockup = (property = "lockup") => {
  return BufferLayout__namespace.struct([BufferLayout__namespace.ns64("unixTimestamp"), BufferLayout__namespace.ns64("epoch"), publicKey("custodian")], property);
};
var voteInit = (property = "voteInit") => {
  return BufferLayout__namespace.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout__namespace.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout__namespace.struct([BufferLayout__namespace.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
};

class CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = undefined;
    this.keyMetaMap = undefined;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = new Map;
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === undefined) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner ||= accountMeta.isSigner;
        keyMeta.isWritable ||= accountMeta.isWritable;
      }
    }
    return new CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array;
    const drainedKeys = new Array;
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
}

class Message {
  constructor(args) {
    this.header = undefined;
    this.accountKeys = undefined;
    this.recentBlockhash = undefined;
    this.instructions = undefined;
    this.indexToProgramIds = new Map;
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: bs58__default.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: bs58__default.default.encode(ix.data)
    }));
    return new Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(bs58__default.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: buffer.Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: buffer.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);
    buffer.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("programIdIndex"), BufferLayout__namespace.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout__namespace.blob(instruction.dataLength.length, "dataLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(1, "numRequiredSignatures"), BufferLayout__namespace.blob(1, "numReadonlySignedAccounts"), BufferLayout__namespace.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout__namespace.blob(keyCount.length, "keyCount"), BufferLayout__namespace.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: buffer.Buffer.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
      recentBlockhash: bs58__default.default.decode(this.recentBlockhash)
    };
    let signData = buffer.Buffer.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  static from(buffer$1) {
    let byteArray = [...buffer$1];
    const numRequiredSignatures = byteArray.shift();
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = byteArray.shift();
    const numReadonlyUnsignedAccounts = byteArray.shift();
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];
    for (let i = 0;i < accountCount; i++) {
      const account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
      accountKeys.push(new PublicKey(buffer.Buffer.from(account)));
    }
    const recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
    byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];
    for (let i = 0;i < instructionCount; i++) {
      const programIdIndex = byteArray.shift();
      const accountCount2 = decodeLength(byteArray);
      const accounts = byteArray.slice(0, accountCount2);
      byteArray = byteArray.slice(accountCount2);
      const dataLength = decodeLength(byteArray);
      const dataSlice = byteArray.slice(0, dataLength);
      const data = bs58__default.default.encode(buffer.Buffer.from(dataSlice));
      byteArray = byteArray.slice(dataLength);
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: bs58__default.default.encode(buffer.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message(messageArgs);
  }
}

class MessageV0 {
  constructor(args) {
    this.header = undefined;
    this.staticAccountKeys = undefined;
    this.recentBlockhash = undefined;
    this.compiledInstructions = undefined;
    this.addressTableLookups = undefined;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let count = 0;
    for (const lookup of this.addressTableLookups) {
      count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
    }
    return count;
  }
  getAccountKeys(args) {
    let accountKeysFromLookups;
    if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      }
      accountKeysFromLookups = args.accountKeysFromLookups;
    } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
    } else if (this.addressTableLookups.length > 0) {
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    }
    return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    const numStaticAccountKeys = this.staticAccountKeys.length;
    if (index >= numStaticAccountKeys) {
      const lookupAccountKeysIndex = index - numStaticAccountKeys;
      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
      return lookupAccountKeysIndex < numWritableLookupAccountKeys;
    } else if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  resolveAddressTableLookups(addressLookupTableAccounts) {
    const accountKeysFromLookups = {
      writable: [],
      readonly: []
    };
    for (const tableLookup of this.addressTableLookups) {
      const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
      if (!tableAccount) {
        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
      }
      for (const index of tableLookup.writableIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
      for (const index of tableLookup.readonlyIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
    }
    return accountKeysFromLookups;
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const addressTableLookups = new Array;
    const accountKeysFromLookups = {
      writable: new Array,
      readonly: new Array
    };
    const lookupTableAccounts = args.addressLookupTableAccounts || [];
    for (const lookupTable of lookupTableAccounts) {
      const extractResult = compiledKeys.extractTableLookup(lookupTable);
      if (extractResult !== undefined) {
        const [addressTableLookup, {
          writable,
          readonly
        }] = extractResult;
        addressTableLookups.push(addressTableLookup);
        accountKeysFromLookups.writable.push(...writable);
        accountKeysFromLookups.readonly.push(...readonly);
      }
    }
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
    const compiledInstructions = accountKeys.compileInstructions(args.instructions);
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
  serialize() {
    const encodedStaticAccountKeysLength = Array();
    encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
    const serializedInstructions = this.serializeInstructions();
    const encodedInstructionsLength = Array();
    encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
    const serializedAddressTableLookups = this.serializeAddressTableLookups();
    const encodedAddressTableLookupsLength = Array();
    encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
    const messageLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("prefix"), BufferLayout__namespace.struct([BufferLayout__namespace.u8("numRequiredSignatures"), BufferLayout__namespace.u8("numReadonlySignedAccounts"), BufferLayout__namespace.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout__namespace.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout__namespace.seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), BufferLayout__namespace.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout__namespace.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout__namespace.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout__namespace.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
    const MESSAGE_VERSION_0_PREFIX = 1 << 7;
    const serializedMessageLength = messageLayout.encode({
      prefix: MESSAGE_VERSION_0_PREFIX,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
      staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
      recentBlockhash: bs58__default.default.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(encodedInstructionsLength),
      serializedInstructions,
      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
      serializedAddressTableLookups
    }, serializedMessage);
    return serializedMessage.slice(0, serializedMessageLength);
  }
  serializeInstructions() {
    let serializedLength = 0;
    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
    for (const instruction of this.compiledInstructions) {
      const encodedAccountKeyIndexesLength = Array();
      encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
      const encodedDataLength = Array();
      encodeLength(encodedDataLength, instruction.data.length);
      const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("programIdIndex"), BufferLayout__namespace.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout__namespace.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout__namespace.blob(instruction.data.length, "data")]);
      serializedLength += instructionLayout.encode({
        programIdIndex: instruction.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
        accountKeyIndexes: instruction.accountKeyIndexes,
        encodedDataLength: new Uint8Array(encodedDataLength),
        data: instruction.data
      }, serializedInstructions, serializedLength);
    }
    return serializedInstructions.slice(0, serializedLength);
  }
  serializeAddressTableLookups() {
    let serializedLength = 0;
    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
    for (const lookup of this.addressTableLookups) {
      const encodedWritableIndexesLength = Array();
      encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
      const encodedReadonlyIndexesLength = Array();
      encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
      const addressTableLookupLayout = BufferLayout__namespace.struct([publicKey("accountKey"), BufferLayout__namespace.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.writableIndexes.length, "writableIndexes"), BufferLayout__namespace.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.readonlyIndexes.length, "readonlyIndexes")]);
      serializedLength += addressTableLookupLayout.encode({
        accountKey: lookup.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
        writableIndexes: lookup.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
        readonlyIndexes: lookup.readonlyIndexes
      }, serializedAddressTableLookups, serializedLength);
    }
    return serializedAddressTableLookups.slice(0, serializedLength);
  }
  static deserialize(serializedMessage) {
    let byteArray = [...serializedMessage];
    const prefix = byteArray.shift();
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
    const version = maskedPrefix;
    assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);
    const header = {
      numRequiredSignatures: byteArray.shift(),
      numReadonlySignedAccounts: byteArray.shift(),
      numReadonlyUnsignedAccounts: byteArray.shift()
    };
    const staticAccountKeys = [];
    const staticAccountKeysLength = decodeLength(byteArray);
    for (let i = 0;i < staticAccountKeysLength; i++) {
      staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
    }
    const recentBlockhash = bs58__default.default.encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
    const instructionCount = decodeLength(byteArray);
    const compiledInstructions = [];
    for (let i = 0;i < instructionCount; i++) {
      const programIdIndex = byteArray.shift();
      const accountKeyIndexesLength = decodeLength(byteArray);
      const accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
      const dataLength = decodeLength(byteArray);
      const data = new Uint8Array(byteArray.splice(0, dataLength));
      compiledInstructions.push({
        programIdIndex,
        accountKeyIndexes,
        data
      });
    }
    const addressTableLookupsCount = decodeLength(byteArray);
    const addressTableLookups = [];
    for (let i = 0;i < addressTableLookupsCount; i++) {
      const accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
      const writableIndexesLength = decodeLength(byteArray);
      const writableIndexes = byteArray.splice(0, writableIndexesLength);
      const readonlyIndexesLength = decodeLength(byteArray);
      const readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
      addressTableLookups.push({
        accountKey,
        writableIndexes,
        readonlyIndexes
      });
    }
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
}
var TransactionStatus = function(TransactionStatus2) {
  TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus2;
}({});
var DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);

class TransactionInstruction {
  constructor(opts) {
    this.keys = undefined;
    this.programId = undefined;
    this.data = buffer.Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}

class Transaction {
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  constructor(opts) {
    this.signatures = [];
    this.feePayer = undefined;
    this.instructions = [];
    this.recentBlockhash = undefined;
    this.lastValidBlockHeight = undefined;
    this.nonceInfo = undefined;
    this.minNonceContextSlot = undefined;
    this._message = undefined;
    this._json = undefined;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey2
      }) => {
        return publicKey2.toJSON();
      })
    };
  }
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i = 0;i < instructions.length; i++) {
      if (instructions[i].programId === undefined) {
        throw new Error(`Transaction instruction index ${i} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x) => {
        return x.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x, y) {
      if (x.isSigner !== y.isSigner) {
        return x.isSigner ? -1 : 1;
      }
      if (x.isWritable !== y.isWritable) {
        return x.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x) => {
      return x.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x) => {
        return x.pubkey.equals(signature.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: bs58__default.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid)
        return message;
    }
    this.signatures = signedKeys.map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
    return message;
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    this.signatures = signers.filter((publicKey2) => {
      const key = publicKey2.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
  }
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature = sign(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer(signature));
    });
  }
  addSignature(pubkey, signature) {
    this._compile();
    this._addSignature(pubkey, signature);
  }
  _addSignature(pubkey, signature) {
    assert(signature.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = buffer.Buffer.from(signature);
  }
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature,
      publicKey: publicKey2
    } of this.signatures) {
      if (signature === null) {
        if (requireAllSignatures) {
          (errors.missing ||= []).push(publicKey2);
        }
      } else {
        if (!verify(signature, message, publicKey2.toBytes())) {
          (errors.invalid ||= []).push(publicKey2);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : undefined;
  }
  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `\nInvalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `\nMissing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = buffer.Buffer.alloc(transactionLength);
    assert(signatures.length < 256);
    buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature
    }, index) => {
      if (signature !== null) {
        assert(signature.length === 64, `signature has invalid length`);
        buffer.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  get keys() {
    assert(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  get programId() {
    assert(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  get data() {
    assert(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  static from(buffer$1) {
    let byteArray = [...buffer$1];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];
    for (let i = 0;i < signatureCount; i++) {
      const signature = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);
      byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
      signatures.push(bs58__default.default.encode(buffer.Buffer.from(signature)));
    }
    return Transaction.populate(Message.from(byteArray), signatures);
  }
  static populate(message, signatures = []) {
    const transaction = new Transaction;
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature, index) => {
      const sigPubkeyPair = {
        signature: signature == bs58__default.default.encode(DEFAULT_SIGNATURE) ? null : bs58__default.default.decode(signature),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: bs58__default.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
}

class TransactionMessage {
  constructor(args) {
    this.payerKey = undefined;
    this.instructions = undefined;
    this.recentBlockhash = undefined;
    this.payerKey = args.payerKey;
    this.instructions = args.instructions;
    this.recentBlockhash = args.recentBlockhash;
  }
  static decompile(message, args) {
    const {
      header,
      compiledInstructions,
      recentBlockhash
    } = message;
    const {
      numRequiredSignatures,
      numReadonlySignedAccounts,
      numReadonlyUnsignedAccounts
    } = header;
    const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
    assert(numWritableSignedAccounts > 0, "Message header is invalid");
    const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
    assert(numWritableUnsignedAccounts >= 0, "Message header is invalid");
    const accountKeys = message.getAccountKeys(args);
    const payerKey = accountKeys.get(0);
    if (payerKey === undefined) {
      throw new Error("Failed to decompile message because no account keys were found");
    }
    const instructions = [];
    for (const compiledIx of compiledInstructions) {
      const keys = [];
      for (const keyIndex of compiledIx.accountKeyIndexes) {
        const pubkey = accountKeys.get(keyIndex);
        if (pubkey === undefined) {
          throw new Error(`Failed to find key for account key index ${keyIndex}`);
        }
        const isSigner = keyIndex < numRequiredSignatures;
        let isWritable;
        if (isSigner) {
          isWritable = keyIndex < numWritableSignedAccounts;
        } else if (keyIndex < accountKeys.staticAccountKeys.length) {
          isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
        } else {
          isWritable = keyIndex - accountKeys.staticAccountKeys.length < accountKeys.accountKeysFromLookups.writable.length;
        }
        keys.push({
          pubkey,
          isSigner: keyIndex < header.numRequiredSignatures,
          isWritable
        });
      }
      const programId = accountKeys.get(compiledIx.programIdIndex);
      if (programId === undefined) {
        throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
      }
      instructions.push(new TransactionInstruction({
        programId,
        data: toBuffer(compiledIx.data),
        keys
      }));
    }
    return new TransactionMessage({
      payerKey,
      instructions,
      recentBlockhash
    });
  }
  compileToLegacyMessage() {
    return Message.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions
    });
  }
  compileToV0Message(addressLookupTableAccounts) {
    return MessageV0.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts
    });
  }
}
var NUM_TICKS_PER_SECOND = 160;
var DEFAULT_TICKS_PER_SLOT = 64;
var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
var MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;
var SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
var FeeCalculatorLayout = BufferLayout__namespace.nu64("lamportsPerSignature");
var NonceAccountLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32("version"), BufferLayout__namespace.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout__namespace.struct([FeeCalculatorLayout], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;

class NonceAccount {
  constructor(args) {
    this.authorizedPubkey = undefined;
    this.nonce = undefined;
    this.feeCalculator = undefined;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }
  static fromAccountData(buffer2) {
    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer2), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
      nonce: new PublicKey(nonceAccount.nonce).toString(),
      feeCalculator: nonceAccount.feeCalculator
    });
  }
}
var encodeDecode = (layout) => {
  const decode = layout.decode.bind(layout);
  const encode = layout.encode.bind(layout);
  return {
    decode,
    encode
  };
};
var bigInt = (length) => (property) => {
  const layout = BufferLayout.blob(length, property);
  const {
    encode,
    decode
  } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer$1, offset) => {
    const src = decode(buffer$1, offset);
    return bigintBuffer.toBigIntLE(buffer.Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt2, buffer2, offset) => {
    const src = bigintBuffer.toBufferLE(bigInt2, length);
    return encode(src, buffer2, offset);
  };
  return bigIntLayout;
};
var u64 = bigInt(8);
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports"), BufferLayout__namespace.ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u64("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout__namespace.ns64("lamports"), BufferLayout__namespace.ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout__namespace.ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
  }
});

class SystemProgram {
  constructor() {
  }
  static createAccount(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    const data = encodeData(type, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  static transfer(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      data = encodeData(type, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      data = encodeData(type, {
        lamports: BigInt(params.lamports)
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static assign(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      data = encodeData(type, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      data = encodeData(type, {
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static createAccountWithSeed(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    const data = encodeData(type, {
      base: toBuffer(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (params.basePubkey != params.fromPubkey) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static createNonceAccount(params) {
    const transaction = new Transaction;
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  static nonceInitialize(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    const data = encodeData(type, {
      authorized: toBuffer(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static nonceAdvance(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    const data = encodeData(type);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static nonceWithdraw(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    const data = encodeData(type, {
      lamports: params.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static nonceAuthorize(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    const data = encodeData(type, {
      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static allocate(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      data = encodeData(type, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      data = encodeData(type, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
}
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
var CHUNK_SIZE = PACKET_DATA_SIZE - 300;

class Loader {
  constructor() {
  }
  static getMinNumSignatures(dataLength) {
    return 2 * (Math.ceil(dataLength / Loader.chunkSize) + 1 + 1);
  }
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction;
          transaction.add(SystemProgram.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction;
          transaction.add(SystemProgram.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction;
          transaction.add(SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction().add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.u32("offset"), BufferLayout__namespace.u32("bytesLength"), BufferLayout__namespace.u32("bytesLengthPadding"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("byte"), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "bytes")]);
    const chunkSize = Loader.chunkSize;
    let offset = 0;
    let array = data;
    let transactions = [];
    while (array.length > 0) {
      const bytes = array.slice(0, chunkSize);
      const data2 = buffer.Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        offset,
        bytes,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep(1000 / REQUESTS_PER_SECOND);
      }
      offset += chunkSize;
      array = array.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")]);
      const data2 = buffer.Buffer.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
      }, data2);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {
        }
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
      }
    }
    return true;
  }
}
Loader.chunkSize = CHUNK_SIZE;
var BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
var agentkeepalive = { exports: {} };
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
var ms$2 = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === "string" && val.length > 0) {
    return parse(val);
  } else if (type === "number" && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
/*!
 * humanize-ms - index.js
 * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
 * MIT Licensed
 */
var util = require$$0__default.default;
var ms$1 = ms$2;
var humanizeMs = function(t) {
  if (typeof t === "number")
    return t;
  var r = ms$1(t);
  if (r === undefined) {
    var err = new Error(util.format("humanize-ms(%j) result undefined", t));
    console.warn(err.stack);
  }
  return r;
};
var constants = {
  CURRENT_ID: Symbol("agentkeepalive#currentId"),
  CREATE_ID: Symbol("agentkeepalive#createId"),
  INIT_SOCKET: Symbol("agentkeepalive#initSocket"),
  CREATE_HTTPS_CONNECTION: Symbol("agentkeepalive#createHttpsConnection"),
  SOCKET_CREATED_TIME: Symbol("agentkeepalive#socketCreatedTime"),
  SOCKET_NAME: Symbol("agentkeepalive#socketName"),
  SOCKET_REQUEST_COUNT: Symbol("agentkeepalive#socketRequestCount"),
  SOCKET_REQUEST_FINISHED_COUNT: Symbol("agentkeepalive#socketRequestFinishedCount")
};
var OriginalAgent = require$$0__default$1.default.Agent;
var ms = humanizeMs;
var debug = require$$0__default.default.debuglog("agentkeepalive");
var {
  INIT_SOCKET: INIT_SOCKET$1,
  CURRENT_ID,
  CREATE_ID,
  SOCKET_CREATED_TIME,
  SOCKET_NAME,
  SOCKET_REQUEST_COUNT,
  SOCKET_REQUEST_FINISHED_COUNT
} = constants;
var defaultTimeoutListenerCount = 1;
var majorVersion = parseInt(process.version.split(".", 1)[0].substring(1));
if (majorVersion >= 11 && majorVersion <= 12) {
  defaultTimeoutListenerCount = 2;
} else if (majorVersion >= 13) {
  defaultTimeoutListenerCount = 3;
}

class Agent extends OriginalAgent {
  constructor(options) {
    options = options || {};
    options.keepAlive = options.keepAlive !== false;
    if (options.freeSocketTimeout === undefined) {
      options.freeSocketTimeout = 4000;
    }
    if (options.keepAliveTimeout) {
      deprecate("options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
      options.freeSocketTimeout = options.keepAliveTimeout;
      delete options.keepAliveTimeout;
    }
    if (options.freeSocketKeepAliveTimeout) {
      deprecate("options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
      options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;
      delete options.freeSocketKeepAliveTimeout;
    }
    if (options.timeout === undefined) {
      options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);
    }
    options.timeout = ms(options.timeout);
    options.freeSocketTimeout = ms(options.freeSocketTimeout);
    options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;
    super(options);
    this[CURRENT_ID] = 0;
    this.createSocketCount = 0;
    this.createSocketCountLastCheck = 0;
    this.createSocketErrorCount = 0;
    this.createSocketErrorCountLastCheck = 0;
    this.closeSocketCount = 0;
    this.closeSocketCountLastCheck = 0;
    this.errorSocketCount = 0;
    this.errorSocketCountLastCheck = 0;
    this.requestCount = 0;
    this.requestCountLastCheck = 0;
    this.timeoutSocketCount = 0;
    this.timeoutSocketCountLastCheck = 0;
    this.on("free", (socket) => {
      const timeout = this.calcSocketTimeout(socket);
      if (timeout > 0 && socket.timeout !== timeout) {
        socket.setTimeout(timeout);
      }
    });
  }
  get freeSocketKeepAliveTimeout() {
    deprecate("agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead");
    return this.options.freeSocketTimeout;
  }
  get timeout() {
    deprecate("agent.timeout is deprecated, please use agent.options.timeout instead");
    return this.options.timeout;
  }
  get socketActiveTTL() {
    deprecate("agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead");
    return this.options.socketActiveTTL;
  }
  calcSocketTimeout(socket) {
    let freeSocketTimeout = this.options.freeSocketTimeout;
    const socketActiveTTL = this.options.socketActiveTTL;
    if (socketActiveTTL) {
      const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
      const diff = socketActiveTTL - aliveTime;
      if (diff <= 0) {
        return diff;
      }
      if (freeSocketTimeout && diff < freeSocketTimeout) {
        freeSocketTimeout = diff;
      }
    }
    if (freeSocketTimeout) {
      const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
      return customFreeSocketTimeout || freeSocketTimeout;
    }
  }
  keepSocketAlive(socket) {
    const result = super.keepSocketAlive(socket);
    if (!result)
      return result;
    const customTimeout = this.calcSocketTimeout(socket);
    if (typeof customTimeout === "undefined") {
      return true;
    }
    if (customTimeout <= 0) {
      debug("%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);
      return false;
    }
    if (socket.timeout !== customTimeout) {
      socket.setTimeout(customTimeout);
    }
    return true;
  }
  reuseSocket(...args) {
    super.reuseSocket(...args);
    const socket = args[0];
    const req = args[1];
    req.reusedSocket = true;
    const agentTimeout = this.options.timeout;
    if (getSocketTimeout(socket) !== agentTimeout) {
      socket.setTimeout(agentTimeout);
      debug("%s reset timeout to %sms", socket[SOCKET_NAME], agentTimeout);
    }
    socket[SOCKET_REQUEST_COUNT]++;
    debug("%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));
  }
  [CREATE_ID]() {
    const id = this[CURRENT_ID]++;
    if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER)
      this[CURRENT_ID] = 0;
    return id;
  }
  [INIT_SOCKET$1](socket, options) {
    if (options.timeout) {
      const timeout = getSocketTimeout(socket);
      if (!timeout) {
        socket.setTimeout(options.timeout);
      }
    }
    if (this.options.keepAlive) {
      socket.setNoDelay(true);
    }
    this.createSocketCount++;
    if (this.options.socketActiveTTL) {
      socket[SOCKET_CREATED_TIME] = Date.now();
    }
    socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split("-----BEGIN", 1)[0];
    socket[SOCKET_REQUEST_COUNT] = 1;
    socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
    installListeners(this, socket, options);
  }
  createConnection(options, oncreate) {
    let called = false;
    const onNewCreate = (err, socket) => {
      if (called)
        return;
      called = true;
      if (err) {
        this.createSocketErrorCount++;
        return oncreate(err);
      }
      this[INIT_SOCKET$1](socket, options);
      oncreate(err, socket);
    };
    const newSocket = super.createConnection(options, onNewCreate);
    if (newSocket)
      onNewCreate(null, newSocket);
    return newSocket;
  }
  get statusChanged() {
    const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;
    if (changed) {
      this.createSocketCountLastCheck = this.createSocketCount;
      this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
      this.closeSocketCountLastCheck = this.closeSocketCount;
      this.errorSocketCountLastCheck = this.errorSocketCount;
      this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
      this.requestCountLastCheck = this.requestCount;
    }
    return changed;
  }
  getCurrentStatus() {
    return {
      createSocketCount: this.createSocketCount,
      createSocketErrorCount: this.createSocketErrorCount,
      closeSocketCount: this.closeSocketCount,
      errorSocketCount: this.errorSocketCount,
      timeoutSocketCount: this.timeoutSocketCount,
      requestCount: this.requestCount,
      freeSockets: inspect(this.freeSockets),
      sockets: inspect(this.sockets),
      requests: inspect(this.requests)
    };
  }
}
var agent = Agent;
var OriginalHttpsAgent = require$$0__default$2.default.Agent;
var HttpAgent = agent;
var {
  INIT_SOCKET,
  CREATE_HTTPS_CONNECTION
} = constants;
var HttpsAgent$1 = class HttpsAgent extends HttpAgent {
  constructor(options) {
    super(options);
    this.defaultPort = 443;
    this.protocol = "https:";
    this.maxCachedSessions = this.options.maxCachedSessions;
    if (this.maxCachedSessions === undefined) {
      this.maxCachedSessions = 100;
    }
    this._sessionCache = {
      map: {},
      list: []
    };
  }
  createConnection(options, oncreate) {
    const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);
    this[INIT_SOCKET](socket, options);
    return socket;
  }
};
HttpsAgent$1.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;
[
  "getName",
  "_getSession",
  "_cacheSession",
  "_evictSession"
].forEach(function(method) {
  if (typeof OriginalHttpsAgent.prototype[method] === "function") {
    HttpsAgent$1.prototype[method] = OriginalHttpsAgent.prototype[method];
  }
});
var https_agent = HttpsAgent$1;
agentkeepalive.exports = agent;
var HttpsAgent2 = agentkeepalive.exports.HttpsAgent = https_agent;
agentkeepalive.exports.constants = constants;
var agentkeepaliveExports = agentkeepalive.exports;
var HttpKeepAliveAgent = getDefaultExportFromCjs(agentkeepaliveExports);
var objToString = Object.prototype.toString;
var objKeys = Object.keys || function(obj) {
  var keys = [];
  for (var name in obj) {
    keys.push(name);
  }
  return keys;
};
var fastStableStringify = function(val) {
  var returnVal = stringify(val, false);
  if (returnVal !== undefined) {
    return "" + returnVal;
  }
};
var fastStableStringify$1 = getDefaultExportFromCjs(fastStableStringify);
var MINIMUM_SLOT_PER_EPOCH = 32;

class EpochSchedule {
  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    this.slotsPerEpoch = undefined;
    this.leaderScheduleSlotOffset = undefined;
    this.warmup = undefined;
    this.firstNormalEpoch = undefined;
    this.firstNormalSlot = undefined;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  getEpoch(slot) {
    return this.getEpochAndSlotIndex(slot)[0];
  }
  getEpochAndSlotIndex(slot) {
    if (slot < this.firstNormalSlot) {
      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
      const epochLen = this.getSlotsInEpoch(epoch);
      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
      return [epoch, slotIndex];
    } else {
      const normalSlotIndex = slot - this.firstNormalSlot;
      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
      const epoch = this.firstNormalEpoch + normalEpochIndex;
      const slotIndex = normalSlotIndex % this.slotsPerEpoch;
      return [epoch, slotIndex];
    }
  }
  getFirstSlotInEpoch(epoch) {
    if (epoch <= this.firstNormalEpoch) {
      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
    } else {
      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
  }
  getLastSlotInEpoch(epoch) {
    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
  }
  getSlotsInEpoch(epoch) {
    if (epoch < this.firstNormalEpoch) {
      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
    } else {
      return this.slotsPerEpoch;
    }
  }
}

class SendTransactionError extends Error {
  constructor(message, logs) {
    super(message);
    this.logs = undefined;
    this.logs = logs;
  }
}
class SolanaJSONRPCError extends Error {
  constructor({
    code,
    message,
    data
  }, customMessage) {
    super(customMessage != null ? `${customMessage}: ${message}` : message);
    this.code = undefined;
    this.data = undefined;
    this.code = code;
    this.data = data;
    this.name = "SolanaJSONRPCError";
  }
}
var fetchImpl = typeof globalThis.fetch === "function" ? globalThis.fetch : async function(input, init) {
  const processedInput = typeof input === "string" && input.slice(0, 2) === "//" ? "https:" + input : input;
  return await nodeFetch__namespace.default(processedInput, init);
};

class RpcWebSocketClient extends RpcWebSocketCommonClient__default.default {
  constructor(address, options, generate_request_id) {
    const webSocketFactory = (url) => {
      const rpc = WebsocketFactory__default.default(url, {
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1000,
        ...options
      });
      if ("socket" in rpc) {
        this.underlyingSocket = rpc.socket;
      } else {
        this.underlyingSocket = rpc;
      }
      return rpc;
    };
    super(webSocketFactory, address, options, generate_request_id);
    this.underlyingSocket = undefined;
  }
  call(...args) {
    const readyState = this.underlyingSocket?.readyState;
    if (readyState === 1) {
      return super.call(...args);
    }
    return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
  notify(...args) {
    const readyState = this.underlyingSocket?.readyState;
    if (readyState === 1) {
      return super.notify(...args);
    }
    return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
}
var LOOKUP_TABLE_META_SIZE = 56;

class AddressLookupTableAccount {
  constructor(args) {
    this.key = undefined;
    this.state = undefined;
    this.key = args.key;
    this.state = args.state;
  }
  isActive() {
    const U64_MAX = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === U64_MAX;
  }
  static deserialize(accountData) {
    const meta = decodeData(LookupTableMetaLayout, accountData);
    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
    assert(serializedAddressesLen >= 0, "lookup table is invalid");
    assert(serializedAddressesLen % 32 === 0, "lookup table is invalid");
    const numSerializedAddresses = serializedAddressesLen / 32;
    const {
      addresses
    } = BufferLayout__namespace.struct([BufferLayout__namespace.seq(publicKey(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: meta.deactivationSlot,
      lastExtendedSlot: meta.lastExtendedSlot,
      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
      authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,
      addresses: addresses.map((address) => new PublicKey(address))
    };
  }
}
var LookupTableMetaLayout = {
  index: 1,
  layout: BufferLayout__namespace.struct([
    BufferLayout__namespace.u32("typeIndex"),
    u64("deactivationSlot"),
    BufferLayout__namespace.nu64("lastExtendedSlot"),
    BufferLayout__namespace.u8("lastExtendedStartIndex"),
    BufferLayout__namespace.u8(),
    BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u8(), -1), "authority")
  ])
};
var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
var PublicKeyFromString = superstruct.coerce(superstruct.instance(PublicKey), superstruct.string(), (value) => new PublicKey(value));
var RawAccountDataResult = superstruct.tuple([superstruct.string(), superstruct.literal("base64")]);
var BufferFromRawAccountData = superstruct.coerce(superstruct.instance(buffer.Buffer), RawAccountDataResult, (value) => buffer.Buffer.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;
var UnknownRpcResult = createRpcResult(superstruct.unknown());
var GetInflationGovernorResult = superstruct.type({
  foundation: superstruct.number(),
  foundationTerm: superstruct.number(),
  initial: superstruct.number(),
  taper: superstruct.number(),
  terminal: superstruct.number()
});
var GetInflationRewardResult = jsonRpcResult(superstruct.array(superstruct.nullable(superstruct.type({
  epoch: superstruct.number(),
  effectiveSlot: superstruct.number(),
  amount: superstruct.number(),
  postBalance: superstruct.number(),
  commission: superstruct.optional(superstruct.nullable(superstruct.number()))
}))));
var GetRecentPrioritizationFeesResult = superstruct.array(superstruct.type({
  slot: superstruct.number(),
  prioritizationFee: superstruct.number()
}));
var GetInflationRateResult = superstruct.type({
  total: superstruct.number(),
  validator: superstruct.number(),
  foundation: superstruct.number(),
  epoch: superstruct.number()
});
var GetEpochInfoResult = superstruct.type({
  epoch: superstruct.number(),
  slotIndex: superstruct.number(),
  slotsInEpoch: superstruct.number(),
  absoluteSlot: superstruct.number(),
  blockHeight: superstruct.optional(superstruct.number()),
  transactionCount: superstruct.optional(superstruct.number())
});
var GetEpochScheduleResult = superstruct.type({
  slotsPerEpoch: superstruct.number(),
  leaderScheduleSlotOffset: superstruct.number(),
  warmup: superstruct.boolean(),
  firstNormalEpoch: superstruct.number(),
  firstNormalSlot: superstruct.number()
});
var GetLeaderScheduleResult = superstruct.record(superstruct.string(), superstruct.array(superstruct.number()));
var TransactionErrorResult = superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()]));
var SignatureStatusResult = superstruct.type({
  err: TransactionErrorResult
});
var SignatureReceivedResult = superstruct.literal("receivedSignature");
var VersionResult = superstruct.type({
  "solana-core": superstruct.string(),
  "feature-set": superstruct.optional(superstruct.number())
});
var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(superstruct.type({
  err: superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()])),
  logs: superstruct.nullable(superstruct.array(superstruct.string())),
  accounts: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.nullable(superstruct.type({
    executable: superstruct.boolean(),
    owner: superstruct.string(),
    lamports: superstruct.number(),
    data: superstruct.array(superstruct.string()),
    rentEpoch: superstruct.optional(superstruct.number())
  }))))),
  unitsConsumed: superstruct.optional(superstruct.number()),
  returnData: superstruct.optional(superstruct.nullable(superstruct.type({
    programId: superstruct.string(),
    data: superstruct.tuple([superstruct.string(), superstruct.literal("base64")])
  })))
}));
var BlockProductionResponseStruct = jsonRpcResultAndContext(superstruct.type({
  byIdentity: superstruct.record(superstruct.string(), superstruct.array(superstruct.number())),
  range: superstruct.type({
    firstSlot: superstruct.number(),
    lastSlot: superstruct.number()
  })
}));
var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
var SlotRpcResult = jsonRpcResult(superstruct.number());
var GetSupplyRpcResult = jsonRpcResultAndContext(superstruct.type({
  total: superstruct.number(),
  circulating: superstruct.number(),
  nonCirculating: superstruct.number(),
  nonCirculatingAccounts: superstruct.array(PublicKeyFromString)
}));
var TokenAmountResult = superstruct.type({
  amount: superstruct.string(),
  uiAmount: superstruct.nullable(superstruct.number()),
  decimals: superstruct.number(),
  uiAmountString: superstruct.optional(superstruct.string())
});
var GetTokenLargestAccountsResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({
  address: PublicKeyFromString,
  amount: superstruct.string(),
  uiAmount: superstruct.nullable(superstruct.number()),
  decimals: superstruct.number(),
  uiAmountString: superstruct.optional(superstruct.string())
})));
var GetTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({
  pubkey: PublicKeyFromString,
  account: superstruct.type({
    executable: superstruct.boolean(),
    owner: PublicKeyFromString,
    lamports: superstruct.number(),
    data: BufferFromRawAccountData,
    rentEpoch: superstruct.number()
  })
})));
var ParsedAccountDataResult = superstruct.type({
  program: superstruct.string(),
  parsed: superstruct.unknown(),
  space: superstruct.number()
});
var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({
  pubkey: PublicKeyFromString,
  account: superstruct.type({
    executable: superstruct.boolean(),
    owner: PublicKeyFromString,
    lamports: superstruct.number(),
    data: ParsedAccountDataResult,
    rentEpoch: superstruct.number()
  })
})));
var GetLargestAccountsRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({
  lamports: superstruct.number(),
  address: PublicKeyFromString
})));
var AccountInfoResult = superstruct.type({
  executable: superstruct.boolean(),
  owner: PublicKeyFromString,
  lamports: superstruct.number(),
  data: BufferFromRawAccountData,
  rentEpoch: superstruct.number()
});
var KeyedAccountInfoResult = superstruct.type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ParsedOrRawAccountData = superstruct.coerce(superstruct.union([superstruct.instance(buffer.Buffer), ParsedAccountDataResult]), superstruct.union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
  if (Array.isArray(value)) {
    return superstruct.create(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult = superstruct.type({
  executable: superstruct.boolean(),
  owner: PublicKeyFromString,
  lamports: superstruct.number(),
  data: ParsedOrRawAccountData,
  rentEpoch: superstruct.number()
});
var KeyedParsedAccountInfoResult = superstruct.type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
var StakeActivationResult = superstruct.type({
  state: superstruct.union([superstruct.literal("active"), superstruct.literal("inactive"), superstruct.literal("activating"), superstruct.literal("deactivating")]),
  active: superstruct.number(),
  inactive: superstruct.number()
});
var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(superstruct.array(superstruct.type({
  signature: superstruct.string(),
  slot: superstruct.number(),
  err: TransactionErrorResult,
  memo: superstruct.nullable(superstruct.string()),
  blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
})));
var GetSignaturesForAddressRpcResult = jsonRpcResult(superstruct.array(superstruct.type({
  signature: superstruct.string(),
  slot: superstruct.number(),
  err: TransactionErrorResult,
  memo: superstruct.nullable(superstruct.string()),
  blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
})));
var AccountNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: notificationResultAndContext(AccountInfoResult)
});
var ProgramAccountInfoResult = superstruct.type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ProgramAccountNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
var SlotInfoResult = superstruct.type({
  parent: superstruct.number(),
  slot: superstruct.number(),
  root: superstruct.number()
});
var SlotNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: SlotInfoResult
});
var SlotUpdateResult = superstruct.union([superstruct.type({
  type: superstruct.union([superstruct.literal("firstShredReceived"), superstruct.literal("completed"), superstruct.literal("optimisticConfirmation"), superstruct.literal("root")]),
  slot: superstruct.number(),
  timestamp: superstruct.number()
}), superstruct.type({
  type: superstruct.literal("createdBank"),
  parent: superstruct.number(),
  slot: superstruct.number(),
  timestamp: superstruct.number()
}), superstruct.type({
  type: superstruct.literal("frozen"),
  slot: superstruct.number(),
  timestamp: superstruct.number(),
  stats: superstruct.type({
    numTransactionEntries: superstruct.number(),
    numSuccessfulTransactions: superstruct.number(),
    numFailedTransactions: superstruct.number(),
    maxTransactionsPerEntry: superstruct.number()
  })
}), superstruct.type({
  type: superstruct.literal("dead"),
  slot: superstruct.number(),
  timestamp: superstruct.number(),
  err: superstruct.string()
})]);
var SlotUpdateNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: SlotUpdateResult
});
var SignatureNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: notificationResultAndContext(superstruct.union([SignatureStatusResult, SignatureReceivedResult]))
});
var RootNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: superstruct.number()
});
var ContactInfoResult = superstruct.type({
  pubkey: superstruct.string(),
  gossip: superstruct.nullable(superstruct.string()),
  tpu: superstruct.nullable(superstruct.string()),
  rpc: superstruct.nullable(superstruct.string()),
  version: superstruct.nullable(superstruct.string())
});
var VoteAccountInfoResult = superstruct.type({
  votePubkey: superstruct.string(),
  nodePubkey: superstruct.string(),
  activatedStake: superstruct.number(),
  epochVoteAccount: superstruct.boolean(),
  epochCredits: superstruct.array(superstruct.tuple([superstruct.number(), superstruct.number(), superstruct.number()])),
  commission: superstruct.number(),
  lastVote: superstruct.number(),
  rootSlot: superstruct.nullable(superstruct.number())
});
var GetVoteAccounts = jsonRpcResult(superstruct.type({
  current: superstruct.array(VoteAccountInfoResult),
  delinquent: superstruct.array(VoteAccountInfoResult)
}));
var ConfirmationStatus = superstruct.union([superstruct.literal("processed"), superstruct.literal("confirmed"), superstruct.literal("finalized")]);
var SignatureStatusResponse = superstruct.type({
  slot: superstruct.number(),
  confirmations: superstruct.nullable(superstruct.number()),
  err: TransactionErrorResult,
  confirmationStatus: superstruct.optional(ConfirmationStatus)
});
var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.nullable(SignatureStatusResponse)));
var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(superstruct.number());
var AddressTableLookupStruct = superstruct.type({
  accountKey: PublicKeyFromString,
  writableIndexes: superstruct.array(superstruct.number()),
  readonlyIndexes: superstruct.array(superstruct.number())
});
var ConfirmedTransactionResult = superstruct.type({
  signatures: superstruct.array(superstruct.string()),
  message: superstruct.type({
    accountKeys: superstruct.array(superstruct.string()),
    header: superstruct.type({
      numRequiredSignatures: superstruct.number(),
      numReadonlySignedAccounts: superstruct.number(),
      numReadonlyUnsignedAccounts: superstruct.number()
    }),
    instructions: superstruct.array(superstruct.type({
      accounts: superstruct.array(superstruct.number()),
      data: superstruct.string(),
      programIdIndex: superstruct.number()
    })),
    recentBlockhash: superstruct.string(),
    addressTableLookups: superstruct.optional(superstruct.array(AddressTableLookupStruct))
  })
});
var AnnotatedAccountKey = superstruct.type({
  pubkey: PublicKeyFromString,
  signer: superstruct.boolean(),
  writable: superstruct.boolean(),
  source: superstruct.optional(superstruct.union([superstruct.literal("transaction"), superstruct.literal("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult = superstruct.type({
  accountKeys: superstruct.array(AnnotatedAccountKey),
  signatures: superstruct.array(superstruct.string())
});
var ParsedInstructionResult = superstruct.type({
  parsed: superstruct.unknown(),
  program: superstruct.string(),
  programId: PublicKeyFromString
});
var RawInstructionResult = superstruct.type({
  accounts: superstruct.array(PublicKeyFromString),
  data: superstruct.string(),
  programId: PublicKeyFromString
});
var InstructionResult = superstruct.union([RawInstructionResult, ParsedInstructionResult]);
var UnknownInstructionResult = superstruct.union([superstruct.type({
  parsed: superstruct.unknown(),
  program: superstruct.string(),
  programId: superstruct.string()
}), superstruct.type({
  accounts: superstruct.array(superstruct.string()),
  data: superstruct.string(),
  programId: superstruct.string()
})]);
var ParsedOrRawInstruction = superstruct.coerce(InstructionResult, UnknownInstructionResult, (value) => {
  if ("accounts" in value) {
    return superstruct.create(value, RawInstructionResult);
  } else {
    return superstruct.create(value, ParsedInstructionResult);
  }
});
var ParsedConfirmedTransactionResult = superstruct.type({
  signatures: superstruct.array(superstruct.string()),
  message: superstruct.type({
    accountKeys: superstruct.array(AnnotatedAccountKey),
    instructions: superstruct.array(ParsedOrRawInstruction),
    recentBlockhash: superstruct.string(),
    addressTableLookups: superstruct.optional(superstruct.nullable(superstruct.array(AddressTableLookupStruct)))
  })
});
var TokenBalanceResult = superstruct.type({
  accountIndex: superstruct.number(),
  mint: superstruct.string(),
  owner: superstruct.optional(superstruct.string()),
  uiTokenAmount: TokenAmountResult
});
var LoadedAddressesResult = superstruct.type({
  writable: superstruct.array(PublicKeyFromString),
  readonly: superstruct.array(PublicKeyFromString)
});
var ConfirmedTransactionMetaResult = superstruct.type({
  err: TransactionErrorResult,
  fee: superstruct.number(),
  innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
    index: superstruct.number(),
    instructions: superstruct.array(superstruct.type({
      accounts: superstruct.array(superstruct.number()),
      data: superstruct.string(),
      programIdIndex: superstruct.number()
    }))
  })))),
  preBalances: superstruct.array(superstruct.number()),
  postBalances: superstruct.array(superstruct.number()),
  logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
  preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
  postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
  loadedAddresses: superstruct.optional(LoadedAddressesResult),
  computeUnitsConsumed: superstruct.optional(superstruct.number())
});
var ParsedConfirmedTransactionMetaResult = superstruct.type({
  err: TransactionErrorResult,
  fee: superstruct.number(),
  innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
    index: superstruct.number(),
    instructions: superstruct.array(ParsedOrRawInstruction)
  })))),
  preBalances: superstruct.array(superstruct.number()),
  postBalances: superstruct.array(superstruct.number()),
  logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
  preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
  postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
  loadedAddresses: superstruct.optional(LoadedAddressesResult),
  computeUnitsConsumed: superstruct.optional(superstruct.number())
});
var TransactionVersionStruct = superstruct.union([superstruct.literal(0), superstruct.literal("legacy")]);
var RewardsResult = superstruct.type({
  pubkey: superstruct.string(),
  lamports: superstruct.number(),
  postBalance: superstruct.nullable(superstruct.number()),
  rewardType: superstruct.nullable(superstruct.string()),
  commission: superstruct.optional(superstruct.nullable(superstruct.number()))
});
var GetBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  transactions: superstruct.array(superstruct.type({
    transaction: ConfirmedTransactionResult,
    meta: superstruct.nullable(ConfirmedTransactionMetaResult),
    version: superstruct.optional(TransactionVersionStruct)
  })),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
var GetNoneModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
var GetAccountsModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  transactions: superstruct.array(superstruct.type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: superstruct.nullable(ConfirmedTransactionMetaResult),
    version: superstruct.optional(TransactionVersionStruct)
  })),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
var GetParsedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  transactions: superstruct.array(superstruct.type({
    transaction: ParsedConfirmedTransactionResult,
    meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
    version: superstruct.optional(TransactionVersionStruct)
  })),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  transactions: superstruct.array(superstruct.type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
    version: superstruct.optional(TransactionVersionStruct)
  })),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
var GetParsedNoneModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
var GetConfirmedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  transactions: superstruct.array(superstruct.type({
    transaction: ConfirmedTransactionResult,
    meta: superstruct.nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number())
})));
var GetBlockSignaturesRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  signatures: superstruct.array(superstruct.string()),
  blockTime: superstruct.nullable(superstruct.number())
})));
var GetTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  slot: superstruct.number(),
  meta: superstruct.nullable(ConfirmedTransactionMetaResult),
  blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
  transaction: ConfirmedTransactionResult,
  version: superstruct.optional(TransactionVersionStruct)
})));
var GetParsedTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  slot: superstruct.number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
  version: superstruct.optional(TransactionVersionStruct)
})));
var GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(superstruct.type({
  blockhash: superstruct.string(),
  feeCalculator: superstruct.type({
    lamportsPerSignature: superstruct.number()
  })
}));
var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(superstruct.type({
  blockhash: superstruct.string(),
  lastValidBlockHeight: superstruct.number()
}));
var IsBlockhashValidRpcResult = jsonRpcResultAndContext(superstruct.boolean());
var PerfSampleResult = superstruct.type({
  slot: superstruct.number(),
  numTransactions: superstruct.number(),
  numSlots: superstruct.number(),
  samplePeriodSecs: superstruct.number()
});
var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(superstruct.array(PerfSampleResult));
var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(superstruct.nullable(superstruct.type({
  feeCalculator: superstruct.type({
    lamportsPerSignature: superstruct.number()
  })
})));
var RequestAirdropRpcResult = jsonRpcResult(superstruct.string());
var SendTransactionRpcResult = jsonRpcResult(superstruct.string());
var LogsResult = superstruct.type({
  err: TransactionErrorResult,
  logs: superstruct.array(superstruct.string()),
  signature: superstruct.string()
});
var LogsNotificationResult = superstruct.type({
  result: notificationResultAndContext(LogsResult),
  subscription: superstruct.number()
});
var COMMON_HTTP_HEADERS = {
  "solana-client": `js/${"0.0.0-development"}`
};

class Connection {
  constructor(endpoint, _commitmentOrConfig) {
    this._commitment = undefined;
    this._confirmTransactionInitialTimeout = undefined;
    this._rpcEndpoint = undefined;
    this._rpcWsEndpoint = undefined;
    this._rpcClient = undefined;
    this._rpcRequest = undefined;
    this._rpcBatchRequest = undefined;
    this._rpcWebSocket = undefined;
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketHeartbeat = null;
    this._rpcWebSocketIdleTimeout = null;
    this._rpcWebSocketGeneration = 0;
    this._disableBlockhashCaching = false;
    this._pollingBlockhash = false;
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    this._nextClientSubscriptionId = 0;
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    this._subscriptionHashByClientSubscriptionId = {};
    this._subscriptionStateChangeCallbacksByHash = {};
    this._subscriptionCallbacksByServerSubscriptionId = {};
    this._subscriptionsByHash = {};
    this._subscriptionsAutoDisposedByRpc = new Set;
    this.getBlockHeight = (() => {
      const requestPromises = {};
      return async (commitmentOrConfig) => {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, undefined, config);
        const requestHash = fastStableStringify$1(args);
        requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
          try {
            const unsafeRes = await this._rpcRequest("getBlockHeight", args);
            const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));
            if ("error" in res) {
              throw new SolanaJSONRPCError(res.error, "failed to get block height information");
            }
            return res.result;
          } finally {
            delete requestPromises[requestHash];
          }
        })();
        return await requestPromises[requestHash];
      };
    })();
    let wsEndpoint;
    let httpHeaders;
    let fetch;
    let fetchMiddleware;
    let disableRetryOnRateLimit;
    let httpAgent;
    if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
      this._commitment = _commitmentOrConfig;
    } else if (_commitmentOrConfig) {
      this._commitment = _commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = _commitmentOrConfig.wsEndpoint;
      httpHeaders = _commitmentOrConfig.httpHeaders;
      fetch = _commitmentOrConfig.fetch;
      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = _commitmentOrConfig.httpAgent;
    }
    this._rpcEndpoint = assertEndpointUrl(endpoint);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
    this._rpcWebSocket.on("error", this._wsOnError.bind(this));
    this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
    this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  get commitment() {
    return this._commitment;
  }
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  async getBalanceAndContext(publicKey2, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, undefined, config);
    const unsafeRes = await this._rpcRequest("getBalance", args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  async getBalance(publicKey2, commitmentOrConfig) {
    return await this.getBalanceAndContext(publicKey2, commitmentOrConfig).then((x) => x.value).catch((e) => {
      throw new Error("failed to get balance of account " + publicKey2.toBase58() + ": " + e);
    });
  }
  async getBlockTime(slot) {
    const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.nullable(superstruct.number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
    }
    return res.result;
  }
  async getMinimumLedgerSlot() {
    const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
    }
    return res.result;
  }
  async getFirstAvailableBlock() {
    const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
    const res = superstruct.create(unsafeRes, SlotRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get first available block");
    }
    return res.result;
  }
  async getSupply(config) {
    let configArg = {};
    if (typeof config === "string") {
      configArg = {
        commitment: config
      };
    } else if (config) {
      configArg = {
        ...config,
        commitment: config && config.commitment || this.commitment
      };
    } else {
      configArg = {
        commitment: this.commitment
      };
    }
    const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
    const res = superstruct.create(unsafeRes, GetSupplyRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get supply");
    }
    return res.result;
  }
  async getTokenSupply(tokenMintAddress, commitment) {
    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenSupply", args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token supply");
    }
    return res.result;
  }
  async getTokenAccountBalance(tokenAddress, commitment) {
    const args = this._buildArgs([tokenAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
    }
    return res.result;
  }
  async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter) {
      _args.push({
        mint: filter.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = superstruct.create(unsafeRes, GetTokenAccountsByOwner);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }
  async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter) {
      _args.push({
        mint: filter.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = superstruct.create(unsafeRes, GetParsedTokenAccountsByOwner);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }
  async getLargestAccounts(config) {
    const arg = {
      ...config,
      commitment: config && config.commitment || this.commitment
    };
    const args = arg.filter || arg.commitment ? [arg] : [];
    const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
    const res = superstruct.create(unsafeRes, GetLargestAccountsRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
    }
    return res.result;
  }
  async getTokenLargestAccounts(mintAddress, commitment) {
    const args = this._buildArgs([mintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
    const res = superstruct.create(unsafeRes, GetTokenLargestAccountsResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
    }
    return res.result;
  }
  async getAccountInfoAndContext(publicKey2, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(AccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  async getParsedAccountInfo(publicKey2, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(ParsedAccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  async getAccountInfo(publicKey2, commitmentOrConfig) {
    try {
      const res = await this.getAccountInfoAndContext(publicKey2, commitmentOrConfig);
      return res.value;
    } catch (e) {
      throw new Error("failed to get info about account " + publicKey2.toBase58() + ": " + e);
    }
  }
  async getMultipleParsedAccounts(publicKeys, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const keys = publicKeys.map((key) => key.toBase58());
    const args = this._buildArgs([keys], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(ParsedAccountInfoResult))));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
    }
    return res.result;
  }
  async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const keys = publicKeys.map((key) => key.toBase58());
    const args = this._buildArgs([keys], commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(AccountInfoResult))));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
    }
    return res.result;
  }
  async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
    const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
    return res.value;
  }
  async getStakeActivation(publicKey2, commitmentOrConfig, epoch) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, undefined, {
      ...config,
      epoch: epoch != null ? epoch : config?.epoch
    });
    const unsafeRes = await this._rpcRequest("getStakeActivation", args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(StakeActivationResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  async getProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(configOrCommitment);
    const {
      encoding,
      ...configWithoutEncoding
    } = config || {};
    const args = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", configWithoutEncoding);
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const baseSchema = superstruct.array(KeyedAccountInfoResult);
    const res = configWithoutEncoding.withContext === true ? superstruct.create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : superstruct.create(unsafeRes, jsonRpcResult(baseSchema));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  async getParsedProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(configOrCommitment);
    const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(KeyedParsedAccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  async confirmTransaction(strategy, commitment) {
    let rawSignature;
    if (typeof strategy == "string") {
      rawSignature = strategy;
    } else {
      const config = strategy;
      if (config.abortSignal?.aborted) {
        return Promise.reject(config.abortSignal.reason);
      }
      rawSignature = config.signature;
    }
    let decodedSignature;
    try {
      decodedSignature = bs58__default.default.decode(rawSignature);
    } catch (err) {
      throw new Error("signature must be base58 encoded: " + rawSignature);
    }
    assert(decodedSignature.length === 64, "signature has invalid length");
    if (typeof strategy === "string") {
      return await this.confirmTransactionUsingLegacyTimeoutStrategy({
        commitment: commitment || this.commitment,
        signature: rawSignature
      });
    } else if ("lastValidBlockHeight" in strategy) {
      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    } else {
      return await this.confirmTransactionUsingDurableNonceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    }
  }
  getCancellationPromise(signal) {
    return new Promise((_, reject) => {
      if (signal == null) {
        return;
      }
      if (signal.aborted) {
        reject(signal.reason);
      } else {
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        });
      }
    });
  }
  getTransactionConfirmationPromise({
    commitment,
    signature
  }) {
    let signatureSubscriptionId;
    let disposeSignatureSubscriptionStateChangeObserver;
    let done = false;
    const confirmationPromise = new Promise((resolve, reject) => {
      try {
        signatureSubscriptionId = this.onSignature(signature, (result, context) => {
          signatureSubscriptionId = undefined;
          const response = {
            context,
            value: result
          };
          resolve({
            __type: TransactionStatus.PROCESSED,
            response
          });
        }, commitment);
        const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
          if (signatureSubscriptionId == null) {
            resolveSubscriptionSetup();
          } else {
            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
              if (nextState === "subscribed") {
                resolveSubscriptionSetup();
              }
            });
          }
        });
        (async () => {
          await subscriptionSetupPromise;
          if (done)
            return;
          const response = await this.getSignatureStatus(signature);
          if (done)
            return;
          if (response == null) {
            return;
          }
          const {
            context,
            value
          } = response;
          if (value == null) {
            return;
          }
          if (value?.err) {
            reject(value.err);
          } else {
            switch (commitment) {
              case "confirmed":
              case "single":
              case "singleGossip": {
                if (value.confirmationStatus === "processed") {
                  return;
                }
                break;
              }
              case "finalized":
              case "max":
              case "root": {
                if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                  return;
                }
                break;
              }
              case "processed":
              case "recent":
            }
            done = true;
            resolve({
              __type: TransactionStatus.PROCESSED,
              response: {
                context,
                value
              }
            });
          }
        })();
      } catch (err) {
        reject(err);
      }
    });
    const abortConfirmation = () => {
      if (disposeSignatureSubscriptionStateChangeObserver) {
        disposeSignatureSubscriptionStateChangeObserver();
        disposeSignatureSubscriptionStateChangeObserver = undefined;
      }
      if (signatureSubscriptionId != null) {
        this.removeSignatureListener(signatureSubscriptionId);
        signatureSubscriptionId = undefined;
      }
    };
    return {
      abortConfirmation,
      confirmationPromise
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment,
    strategy: {
      abortSignal,
      lastValidBlockHeight,
      signature
    }
  }) {
    let done = false;
    const expiryPromise = new Promise((resolve) => {
      const checkBlockHeight = async () => {
        try {
          const blockHeight = await this.getBlockHeight(commitment);
          return blockHeight;
        } catch (_e) {
          return -1;
        }
      };
      (async () => {
        let currentBlockHeight = await checkBlockHeight();
        if (done)
          return;
        while (currentBlockHeight <= lastValidBlockHeight) {
          await sleep(1000);
          if (done)
            return;
          currentBlockHeight = await checkBlockHeight();
          if (done)
            return;
        }
        resolve({
          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
        });
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredBlockheightExceededError(signature);
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment,
    strategy: {
      abortSignal,
      minContextSlot,
      nonceAccountPubkey,
      nonceValue,
      signature
    }
  }) {
    let done = false;
    const expiryPromise = new Promise((resolve) => {
      let currentNonceValue = nonceValue;
      let lastCheckedSlot = null;
      const getCurrentNonceValue = async () => {
        try {
          const {
            context,
            value: nonceAccount
          } = await this.getNonceAndContext(nonceAccountPubkey, {
            commitment,
            minContextSlot
          });
          lastCheckedSlot = context.slot;
          return nonceAccount?.nonce;
        } catch (e) {
          return currentNonceValue;
        }
      };
      (async () => {
        currentNonceValue = await getCurrentNonceValue();
        if (done)
          return;
        while (true) {
          if (nonceValue !== currentNonceValue) {
            resolve({
              __type: TransactionStatus.NONCE_INVALID,
              slotInWhichNonceDidAdvance: lastCheckedSlot
            });
            return;
          }
          await sleep(2000);
          if (done)
            return;
          currentNonceValue = await getCurrentNonceValue();
          if (done)
            return;
        }
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        let signatureStatus;
        while (true) {
          const status = await this.getSignatureStatus(signature);
          if (status == null) {
            break;
          }
          if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
            await sleep(400);
            continue;
          }
          signatureStatus = status;
          break;
        }
        if (signatureStatus?.value) {
          const commitmentForStatus = commitment || "finalized";
          const {
            confirmationStatus
          } = signatureStatus.value;
          switch (commitmentForStatus) {
            case "processed":
            case "recent":
              if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature);
              }
              break;
            case "confirmed":
            case "single":
            case "singleGossip":
              if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature);
              }
              break;
            case "finalized":
            case "max":
            case "root":
              if (confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature);
              }
              break;
            default:
              ((_) => {
              })(commitmentForStatus);
          }
          result = {
            context: signatureStatus.context,
            value: {
              err: signatureStatus.value.err
            }
          };
        } else {
          throw new TransactionExpiredNonceInvalidError(signature);
        }
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment,
    signature
  }) {
    let timeoutId;
    const expiryPromise = new Promise((resolve) => {
      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;
      switch (commitment) {
        case "processed":
        case "recent":
        case "single":
        case "confirmed":
        case "singleGossip": {
          timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;
          break;
        }
      }
      timeoutId = setTimeout(() => resolve({
        __type: TransactionStatus.TIMED_OUT,
        timeoutMs
      }), timeoutMs);
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature
    });
    let result;
    try {
      const outcome = await Promise.race([confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);
      }
    } finally {
      clearTimeout(timeoutId);
      abortConfirmation();
    }
    return result;
  }
  async getClusterNodes() {
    const unsafeRes = await this._rpcRequest("getClusterNodes", []);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(ContactInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
    }
    return res.result;
  }
  async getVoteAccounts(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
    const res = superstruct.create(unsafeRes, GetVoteAccounts);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
    }
    return res.result;
  }
  async getSlot(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, undefined, config);
    const unsafeRes = await this._rpcRequest("getSlot", args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot");
    }
    return res.result;
  }
  async getSlotLeader(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, undefined, config);
    const unsafeRes = await this._rpcRequest("getSlotLeader", args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
    }
    return res.result;
  }
  async getSlotLeaders(startSlot, limit) {
    const args = [startSlot, limit];
    const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(PublicKeyFromString)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
    }
    return res.result;
  }
  async getSignatureStatus(signature, config) {
    const {
      context,
      value: values
    } = await this.getSignatureStatuses([signature], config);
    assert(values.length === 1);
    const value = values[0];
    return {
      context,
      value
    };
  }
  async getSignatureStatuses(signatures, config) {
    const params = [signatures];
    if (config) {
      params.push(config);
    }
    const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
    const res = superstruct.create(unsafeRes, GetSignatureStatusesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get signature status");
    }
    return res.result;
  }
  async getTransactionCount(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, undefined, config);
    const unsafeRes = await this._rpcRequest("getTransactionCount", args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
    }
    return res.result;
  }
  async getTotalSupply(commitment) {
    const result = await this.getSupply({
      commitment,
      excludeNonCirculatingAccountsList: true
    });
    return result.value.total;
  }
  async getInflationGovernor(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
    const res = superstruct.create(unsafeRes, GetInflationGovernorRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation");
    }
    return res.result;
  }
  async getInflationReward(addresses, epoch, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, undefined, {
      ...config,
      epoch: epoch != null ? epoch : config?.epoch
    });
    const unsafeRes = await this._rpcRequest("getInflationReward", args);
    const res = superstruct.create(unsafeRes, GetInflationRewardResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
    }
    return res.result;
  }
  async getInflationRate() {
    const unsafeRes = await this._rpcRequest("getInflationRate", []);
    const res = superstruct.create(unsafeRes, GetInflationRateRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
    }
    return res.result;
  }
  async getEpochInfo(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, undefined, config);
    const unsafeRes = await this._rpcRequest("getEpochInfo", args);
    const res = superstruct.create(unsafeRes, GetEpochInfoRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
    }
    return res.result;
  }
  async getEpochSchedule() {
    const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
    const res = superstruct.create(unsafeRes, GetEpochScheduleRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
    }
    const epochSchedule = res.result;
    return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
  }
  async getLeaderSchedule() {
    const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
    const res = superstruct.create(unsafeRes, GetLeaderScheduleRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
    }
    return res.result;
  }
  async getMinimumBalanceForRentExemption(dataLength, commitment) {
    const args = this._buildArgs([dataLength], commitment);
    const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
    const res = superstruct.create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
    if ("error" in res) {
      console.warn("Unable to fetch minimum balance for rent exemption");
      return 0;
    }
    return res.result;
  }
  async getRecentBlockhashAndContext(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getRecentBlockhash", args);
    const res = superstruct.create(unsafeRes, GetRecentBlockhashAndContextRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get recent blockhash");
    }
    return res.result;
  }
  async getRecentPerformanceSamples(limit) {
    const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
    const res = superstruct.create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
    }
    return res.result;
  }
  async getFeeCalculatorForBlockhash(blockhash, commitment) {
    const args = this._buildArgs([blockhash], commitment);
    const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
    const res = superstruct.create(unsafeRes, GetFeeCalculatorRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
    }
    const {
      context,
      value
    } = res.result;
    return {
      context,
      value: value !== null ? value.feeCalculator : null
    };
  }
  async getFeeForMessage(message, commitment) {
    const wireMessage = toBuffer(message.serialize()).toString("base64");
    const args = this._buildArgs([wireMessage], commitment);
    const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(superstruct.number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
    }
    if (res.result === null) {
      throw new Error("invalid blockhash");
    }
    return res.result;
  }
  async getRecentPrioritizationFees(config) {
    const accounts = config?.lockedWritableAccounts?.map((key) => key.toBase58());
    const args = accounts?.length ? [accounts] : [];
    const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
    const res = superstruct.create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
    }
    return res.result;
  }
  async getRecentBlockhash(commitment) {
    try {
      const res = await this.getRecentBlockhashAndContext(commitment);
      return res.value;
    } catch (e) {
      throw new Error("failed to get recent blockhash: " + e);
    }
  }
  async getLatestBlockhash(commitmentOrConfig) {
    try {
      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
      return res.value;
    } catch (e) {
      throw new Error("failed to get recent blockhash: " + e);
    }
  }
  async getLatestBlockhashAndContext(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, undefined, config);
    const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
    const res = superstruct.create(unsafeRes, GetLatestBlockhashRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
    }
    return res.result;
  }
  async isBlockhashValid(blockhash, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgs([blockhash], commitment, undefined, config);
    const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
    const res = superstruct.create(unsafeRes, IsBlockhashValidRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
    }
    return res.result;
  }
  async getVersion() {
    const unsafeRes = await this._rpcRequest("getVersion", []);
    const res = superstruct.create(unsafeRes, jsonRpcResult(VersionResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get version");
    }
    return res.result;
  }
  async getGenesisHash() {
    const unsafeRes = await this._rpcRequest("getGenesisHash", []);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
    }
    return res.result;
  }
  async getBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, config);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    try {
      switch (config?.transactionDetails) {
        case "accounts": {
          const res = superstruct.create(unsafeRes, GetAccountsModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        case "none": {
          const res = superstruct.create(unsafeRes, GetNoneModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        default: {
          const res = superstruct.create(unsafeRes, GetBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          const {
            result
          } = res;
          return result ? {
            ...result,
            transactions: result.transactions.map(({
              transaction,
              meta,
              version
            }) => ({
              meta,
              transaction: {
                ...transaction,
                message: versionedMessageFromResponse(version, transaction.message)
              },
              version
            }))
          } : null;
        }
      }
    } catch (e) {
      throw new SolanaJSONRPCError(e, "failed to get confirmed block");
    }
  }
  async getParsedBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    try {
      switch (config?.transactionDetails) {
        case "accounts": {
          const res = superstruct.create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        case "none": {
          const res = superstruct.create(unsafeRes, GetParsedNoneModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        default: {
          const res = superstruct.create(unsafeRes, GetParsedBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
      }
    } catch (e) {
      throw new SolanaJSONRPCError(e, "failed to get block");
    }
  }
  async getBlockProduction(configOrCommitment) {
    let extra;
    let commitment;
    if (typeof configOrCommitment === "string") {
      commitment = configOrCommitment;
    } else if (configOrCommitment) {
      const {
        commitment: c,
        ...rest
      } = configOrCommitment;
      commitment = c;
      extra = rest;
    }
    const args = this._buildArgs([], commitment, "base64", extra);
    const unsafeRes = await this._rpcRequest("getBlockProduction", args);
    const res = superstruct.create(unsafeRes, BlockProductionResponseStruct);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get block production information");
    }
    return res.result;
  }
  async getTransaction(signature, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined, config);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = superstruct.create(unsafeRes, GetTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    const result = res.result;
    if (!result)
      return result;
    return {
      ...result,
      transaction: {
        ...result.transaction,
        message: versionedMessageFromResponse(result.version, result.transaction.message)
      }
    };
  }
  async getParsedTransaction(signature, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgsAtLeastConfirmed([signature], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    return res.result;
  }
  async getParsedTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map((signature) => {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, "jsonParsed", config);
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = superstruct.create(unsafeRes2, GetParsedTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
      }
      return res2.result;
    });
    return res;
  }
  async getTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map((signature) => {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined, config);
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = superstruct.create(unsafeRes2, GetTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
      }
      const result = res2.result;
      if (!result)
        return result;
      return {
        ...result,
        transaction: {
          ...result.transaction,
          message: versionedMessageFromResponse(result.version, result.transaction.message)
        }
      };
    });
    return res;
  }
  async getConfirmedBlock(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment);
    const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
    const res = superstruct.create(unsafeRes, GetConfirmedBlockRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    const block = {
      ...result,
      transactions: result.transactions.map(({
        transaction,
        meta
      }) => {
        const message = new Message(transaction.message);
        return {
          meta,
          transaction: {
            ...transaction,
            message
          }
        };
      })
    };
    return {
      ...block,
      transactions: block.transactions.map(({
        transaction,
        meta
      }) => {
        return {
          meta,
          transaction: Transaction.populate(transaction.message, transaction.signatures)
        };
      })
    };
  }
  async getBlocks(startSlot, endSlot, commitment) {
    const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);
    const unsafeRes = await this._rpcRequest("getBlocks", args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(superstruct.number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get blocks");
    }
    return res.result;
  }
  async getBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Block " + slot + " not found");
    }
    return result;
  }
  async getConfirmedBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
    const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    return result;
  }
  async getConfirmedTransaction(signature, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature], commitment);
    const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
    const res = superstruct.create(unsafeRes, GetTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    const result = res.result;
    if (!result)
      return result;
    const message = new Message(result.transaction.message);
    const signatures = result.transaction.signatures;
    return {
      ...result,
      transaction: Transaction.populate(message, signatures)
    };
  }
  async getParsedConfirmedTransaction(signature, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature], commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
    const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
    }
    return res.result;
  }
  async getParsedConfirmedTransactions(signatures, commitment) {
    const batch = signatures.map((signature) => {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, "jsonParsed");
      return {
        methodName: "getConfirmedTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = superstruct.create(unsafeRes2, GetParsedTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
      }
      return res2.result;
    });
    return res;
  }
  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
    let options = {};
    let firstAvailableBlock = await this.getFirstAvailableBlock();
    while (!("until" in options)) {
      startSlot--;
      if (startSlot <= 0 || startSlot < firstAvailableBlock) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
        if (block.signatures.length > 0) {
          options.until = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    let highestConfirmedRoot = await this.getSlot("finalized");
    while (!("before" in options)) {
      endSlot++;
      if (endSlot > highestConfirmedRoot) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(endSlot);
        if (block.signatures.length > 0) {
          options.before = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
    return confirmedSignatureInfo.map((info) => info.signature);
  }
  async getConfirmedSignaturesForAddress2(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
    const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
    const res = superstruct.create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
    }
    return res.result;
  }
  async getSignaturesForAddress(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
    const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
    const res = superstruct.create(unsafeRes, GetSignaturesForAddressRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
    }
    return res.result;
  }
  async getAddressLookupTable(accountKey, config) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(accountKey, config);
    let value = null;
    if (accountInfo !== null) {
      value = new AddressLookupTableAccount({
        key: accountKey,
        state: AddressLookupTableAccount.deserialize(accountInfo.data)
      });
    }
    return {
      context,
      value
    };
  }
  async getNonceAndContext(nonceAccount, commitmentOrConfig) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
    let value = null;
    if (accountInfo !== null) {
      value = NonceAccount.fromAccountData(accountInfo.data);
    }
    return {
      context,
      value
    };
  }
  async getNonce(nonceAccount, commitmentOrConfig) {
    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x) => x.value).catch((e) => {
      throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
    });
  }
  async requestAirdrop(to, lamports) {
    const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
    const res = superstruct.create(unsafeRes, RequestAirdropRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
    }
    return res.result;
  }
  async _blockhashWithExpiryBlockHeight(disableCache) {
    if (!disableCache) {
      while (this._pollingBlockhash) {
        await sleep(100);
      }
      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
      if (this._blockhashInfo.latestBlockhash !== null && !expired) {
        return this._blockhashInfo.latestBlockhash;
      }
    }
    return await this._pollNewBlockhash();
  }
  async _pollNewBlockhash() {
    this._pollingBlockhash = true;
    try {
      const startTime = Date.now();
      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
      const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
      for (let i = 0;i < 50; i++) {
        const latestBlockhash = await this.getLatestBlockhash("finalized");
        if (cachedBlockhash !== latestBlockhash.blockhash) {
          this._blockhashInfo = {
            latestBlockhash,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          };
          return latestBlockhash;
        }
        await sleep(MS_PER_SLOT / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
    } finally {
      this._pollingBlockhash = false;
    }
  }
  async getStakeMinimumDelegation(config) {
    const {
      commitment,
      config: configArg
    } = extractCommitmentFromConfig(config);
    const args = this._buildArgs([], commitment, "base64", configArg);
    const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
    }
    return res.result;
  }
  async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
    if ("message" in transactionOrMessage) {
      const versionedTx = transactionOrMessage;
      const wireTransaction2 = versionedTx.serialize();
      const encodedTransaction2 = buffer.Buffer.from(wireTransaction2).toString("base64");
      if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {
        throw new Error("Invalid arguments");
      }
      const config2 = configOrSigners || {};
      config2.encoding = "base64";
      if (!("commitment" in config2)) {
        config2.commitment = this.commitment;
      }
      const args2 = [encodedTransaction2, config2];
      const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
      const res2 = superstruct.create(unsafeRes2, SimulatedTransactionResponseStruct);
      if ("error" in res2) {
        throw new Error("failed to simulate transaction: " + res2.error.message);
      }
      return res2.result;
    }
    let transaction;
    if (transactionOrMessage instanceof Transaction) {
      let originalTx = transactionOrMessage;
      transaction = new Transaction;
      transaction.feePayer = originalTx.feePayer;
      transaction.instructions = transactionOrMessage.instructions;
      transaction.nonceInfo = originalTx.nonceInfo;
      transaction.signatures = originalTx.signatures;
    } else {
      transaction = Transaction.populate(transactionOrMessage);
      transaction._message = transaction._json = undefined;
    }
    if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {
      throw new Error("Invalid arguments");
    }
    const signers = configOrSigners;
    if (transaction.nonceInfo && signers) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (;; ) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        if (!signers)
          break;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error("!signature");
        }
        const signature = transaction.signature.toString("base64");
        if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {
          this._blockhashInfo.simulatedSignatures.push(signature);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const message = transaction._compile();
    const signData = message.serialize();
    const wireTransaction = transaction._serialize(signData);
    const encodedTransaction = wireTransaction.toString("base64");
    const config = {
      encoding: "base64",
      commitment: this.commitment
    };
    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
      config["accounts"] = {
        encoding: "base64",
        addresses
      };
    }
    if (signers) {
      config.sigVerify = true;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest("simulateTransaction", args);
    const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = res.error.data.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = "\n    ";
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
    }
    return res.result;
  }
  async sendTransaction(transaction, signersOrOptions, options) {
    if ("version" in transaction) {
      if (signersOrOptions && Array.isArray(signersOrOptions)) {
        throw new Error("Invalid arguments");
      }
      const wireTransaction2 = transaction.serialize();
      return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
    }
    if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {
      throw new Error("Invalid arguments");
    }
    const signers = signersOrOptions;
    if (transaction.nonceInfo) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (;; ) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error("!signature");
        }
        const signature = transaction.signature.toString("base64");
        if (!this._blockhashInfo.transactionSignatures.includes(signature)) {
          this._blockhashInfo.transactionSignatures.push(signature);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const wireTransaction = transaction.serialize();
    return await this.sendRawTransaction(wireTransaction, options);
  }
  async sendRawTransaction(rawTransaction, options) {
    const encodedTransaction = toBuffer(rawTransaction).toString("base64");
    const result = await this.sendEncodedTransaction(encodedTransaction, options);
    return result;
  }
  async sendEncodedTransaction(encodedTransaction, options) {
    const config = {
      encoding: "base64"
    };
    const skipPreflight = options && options.skipPreflight;
    const preflightCommitment = options && options.preflightCommitment || this.commitment;
    if (options && options.maxRetries != null) {
      config.maxRetries = options.maxRetries;
    }
    if (options && options.minContextSlot != null) {
      config.minContextSlot = options.minContextSlot;
    }
    if (skipPreflight) {
      config.skipPreflight = skipPreflight;
    }
    if (preflightCommitment) {
      config.preflightCommitment = preflightCommitment;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest("sendTransaction", args);
    const res = superstruct.create(unsafeRes, SendTransactionRpcResult);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = res.error.data.logs;
      }
      throw new SendTransactionError("failed to send transaction: " + res.error.message, logs);
    }
    return res.result;
  }
  _wsOnOpen() {
    this._rpcWebSocketConnected = true;
    this._rpcWebSocketHeartbeat = setInterval(() => {
      (async () => {
        try {
          await this._rpcWebSocket.notify("ping");
        } catch {
        }
      })();
    }, 5000);
    this._updateSubscriptions();
  }
  _wsOnError(err) {
    this._rpcWebSocketConnected = false;
    console.error("ws error:", err.message);
  }
  _wsOnClose(code) {
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
    if (this._rpcWebSocketIdleTimeout) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
    }
    if (this._rpcWebSocketHeartbeat) {
      clearInterval(this._rpcWebSocketHeartbeat);
      this._rpcWebSocketHeartbeat = null;
    }
    if (code === 1000) {
      this._updateSubscriptions();
      return;
    }
    this._subscriptionCallbacksByServerSubscriptionId = {};
    Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {
      this._setSubscription(hash, {
        ...subscription,
        state: "pending"
      });
    });
  }
  _setSubscription(hash, nextSubscription) {
    const prevState = this._subscriptionsByHash[hash]?.state;
    this._subscriptionsByHash[hash] = nextSubscription;
    if (prevState !== nextSubscription.state) {
      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];
      if (stateChangeCallbacks) {
        stateChangeCallbacks.forEach((cb) => {
          try {
            cb(nextSubscription.state);
          } catch {
          }
        });
      }
    }
  }
  _onSubscriptionStateChange(clientSubscriptionId, callback) {
    const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
    if (hash == null) {
      return () => {
      };
    }
    const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set;
    stateChangeCallbacks.add(callback);
    return () => {
      stateChangeCallbacks.delete(callback);
      if (stateChangeCallbacks.size === 0) {
        delete this._subscriptionStateChangeCallbacksByHash[hash];
      }
    };
  }
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      if (this._rpcWebSocketConnected) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (err) {
            if (err instanceof Error) {
              console.log(`Error when closing socket connection: ${err.message}`);
            }
          }
        }, 500);
      }
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketConnected = true;
    }
    if (!this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    const activeWebSocketGeneration = this._rpcWebSocketGeneration;
    const isCurrentConnectionStillActive = () => {
      return activeWebSocketGeneration === this._rpcWebSocketGeneration;
    };
    await Promise.all(Object.keys(this._subscriptionsByHash).map(async (hash) => {
      const subscription = this._subscriptionsByHash[hash];
      if (subscription === undefined) {
        return;
      }
      switch (subscription.state) {
        case "pending":
        case "unsubscribed":
          if (subscription.callbacks.size === 0) {
            delete this._subscriptionsByHash[hash];
            if (subscription.state === "unsubscribed") {
              delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
            }
            await this._updateSubscriptions();
            return;
          }
          await (async () => {
            const {
              args,
              method
            } = subscription;
            try {
              this._setSubscription(hash, {
                ...subscription,
                state: "subscribing"
              });
              const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
              this._setSubscription(hash, {
                ...subscription,
                serverSubscriptionId,
                state: "subscribed"
              });
              this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
              await this._updateSubscriptions();
            } catch (e) {
              if (e instanceof Error) {
                console.error(`${method} error for argument`, args, e.message);
              }
              if (!isCurrentConnectionStillActive()) {
                return;
              }
              this._setSubscription(hash, {
                ...subscription,
                state: "pending"
              });
              await this._updateSubscriptions();
            }
          })();
          break;
        case "subscribed":
          if (subscription.callbacks.size === 0) {
            await (async () => {
              const {
                serverSubscriptionId,
                unsubscribeMethod
              } = subscription;
              if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
              } else {
                this._setSubscription(hash, {
                  ...subscription,
                  state: "unsubscribing"
                });
                this._setSubscription(hash, {
                  ...subscription,
                  state: "unsubscribing"
                });
                try {
                  await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                } catch (e) {
                  if (e instanceof Error) {
                    console.error(`${unsubscribeMethod} error:`, e.message);
                  }
                  if (!isCurrentConnectionStillActive()) {
                    return;
                  }
                  this._setSubscription(hash, {
                    ...subscription,
                    state: "subscribed"
                  });
                  await this._updateSubscriptions();
                  return;
                }
              }
              this._setSubscription(hash, {
                ...subscription,
                state: "unsubscribed"
              });
              await this._updateSubscriptions();
            })();
          }
          break;
      }
    }));
  }
  _handleServerNotification(serverSubscriptionId, callbackArgs) {
    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
    if (callbacks === undefined) {
      return;
    }
    callbacks.forEach((cb) => {
      try {
        cb(...callbackArgs);
      } catch (e) {
        console.error(e);
      }
    });
  }
  _wsOnAccountNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, AccountNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  _makeSubscription(subscriptionConfig, args) {
    const clientSubscriptionId = this._nextClientSubscriptionId++;
    const hash = fastStableStringify$1([subscriptionConfig.method, args], true);
    const existingSubscription = this._subscriptionsByHash[hash];
    if (existingSubscription === undefined) {
      this._subscriptionsByHash[hash] = {
        ...subscriptionConfig,
        args,
        callbacks: new Set([subscriptionConfig.callback]),
        state: "pending"
      };
    } else {
      existingSubscription.callbacks.add(subscriptionConfig.callback);
    }
    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      const subscription = this._subscriptionsByHash[hash];
      assert(subscription !== undefined, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
      subscription.callbacks.delete(subscriptionConfig.callback);
      await this._updateSubscriptions();
    };
    this._updateSubscriptions();
    return clientSubscriptionId;
  }
  onAccountChange(publicKey2, callback, commitment) {
    const args = this._buildArgs([publicKey2.toBase58()], commitment || this._commitment || "finalized", "base64");
    return this._makeSubscription({
      callback,
      method: "accountSubscribe",
      unsubscribeMethod: "accountUnsubscribe"
    }, args);
  }
  async removeAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
  }
  _wsOnProgramAccountNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, ProgramAccountNotificationResult);
    this._handleServerNotification(subscription, [{
      accountId: result.value.pubkey,
      accountInfo: result.value.account
    }, result.context]);
  }
  onProgramAccountChange(programId, callback, commitment, filters) {
    const args = this._buildArgs([programId.toBase58()], commitment || this._commitment || "finalized", "base64", filters ? {
      filters
    } : undefined);
    return this._makeSubscription({
      callback,
      method: "programSubscribe",
      unsubscribeMethod: "programUnsubscribe"
    }, args);
  }
  async removeProgramAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
  }
  onLogs(filter, callback, commitment) {
    const args = this._buildArgs([typeof filter === "object" ? {
      mentions: [filter.toString()]
    } : filter], commitment || this._commitment || "finalized");
    return this._makeSubscription({
      callback,
      method: "logsSubscribe",
      unsubscribeMethod: "logsUnsubscribe"
    }, args);
  }
  async removeOnLogsListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
  }
  _wsOnLogsNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, LogsNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  _wsOnSlotNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, SlotNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  onSlotChange(callback) {
    return this._makeSubscription({
      callback,
      method: "slotSubscribe",
      unsubscribeMethod: "slotUnsubscribe"
    }, []);
  }
  async removeSlotChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
  }
  _wsOnSlotUpdatesNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, SlotUpdateNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  onSlotUpdate(callback) {
    return this._makeSubscription({
      callback,
      method: "slotsUpdatesSubscribe",
      unsubscribeMethod: "slotsUpdatesUnsubscribe"
    }, []);
  }
  async removeSlotUpdateListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
  }
  async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
    const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
    if (dispose) {
      await dispose();
    } else {
      console.warn("Ignored unsubscribe request because an active subscription with id " + `\`${clientSubscriptionId}\` for '${subscriptionName}' events ` + "could not be found.");
    }
  }
  _buildArgs(args, override, encoding, extra) {
    const commitment = override || this._commitment;
    if (commitment || encoding || extra) {
      let options = {};
      if (encoding) {
        options.encoding = encoding;
      }
      if (commitment) {
        options.commitment = commitment;
      }
      if (extra) {
        options = Object.assign(options, extra);
      }
      args.push(options);
    }
    return args;
  }
  _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
    const commitment = override || this._commitment;
    if (commitment && !["confirmed", "finalized"].includes(commitment)) {
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    }
    return this._buildArgs(args, override, encoding, extra);
  }
  _wsOnSignatureNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, SignatureNotificationResult);
    if (result.value !== "receivedSignature") {
      this._subscriptionsAutoDisposedByRpc.add(subscription);
    }
    this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
      type: "received"
    }, result.context] : [{
      type: "status",
      result: result.value
    }, result.context]);
  }
  onSignature(signature, callback, commitment) {
    const args = this._buildArgs([signature], commitment || this._commitment || "finalized");
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        if (notification.type === "status") {
          callback(notification.result, context);
          try {
            this.removeSignatureListener(clientSubscriptionId);
          } catch (_err) {
          }
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args);
    return clientSubscriptionId;
  }
  onSignatureWithOptions(signature, callback, options) {
    const {
      commitment,
      ...extra
    } = {
      ...options,
      commitment: options && options.commitment || this._commitment || "finalized"
    };
    const args = this._buildArgs([signature], commitment, undefined, extra);
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        callback(notification, context);
        try {
          this.removeSignatureListener(clientSubscriptionId);
        } catch (_err) {
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args);
    return clientSubscriptionId;
  }
  async removeSignatureListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
  }
  _wsOnRootNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, RootNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  onRootChange(callback) {
    return this._makeSubscription({
      callback,
      method: "rootSubscribe",
      unsubscribeMethod: "rootUnsubscribe"
    }, []);
  }
  async removeRootChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
  }
}

class Keypair {
  constructor(keypair) {
    this._keypair = undefined;
    this._keypair = keypair ?? generateKeypair();
  }
  static generate() {
    return new Keypair(generateKeypair());
  }
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey2 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey(privateScalar);
      for (let ii = 0;ii < 32; ii++) {
        if (publicKey2[ii] !== computedPublicKey[ii]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new Keypair({
      publicKey: publicKey2,
      secretKey
    });
  }
  static fromSeed(seed) {
    const publicKey2 = getPublicKey(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey2, 32);
    return new Keypair({
      publicKey: publicKey2,
      secretKey
    });
  }
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u64("recentSlot"), BufferLayout__namespace.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u64(), BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
  }
});
class AddressLookupTableProgram {
  constructor() {
  }
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), bigintBuffer.toBufferLE(BigInt(params.recentSlot), 8)], this.programId);
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
    const data = encodeData(type, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
    const data = encodeData(type);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static extendLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
    const data = encodeData(type, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
    const data = encodeData(type);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static closeLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
    const data = encodeData(type);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
}
AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("units"), BufferLayout__namespace.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), u64("microLamports")])
  }
});

class ComputeBudgetProgram {
  constructor() {
  }
  static requestUnits(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
    const data = encodeData(type, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
    const data = encodeData(type, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
    const data = encodeData(type, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
    const data = encodeData(type, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
}
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$1 = 64;
var PUBLIC_KEY_BYTES$1 = 32;
var SIGNATURE_BYTES = 64;
var ED25519_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8("numSignatures"), BufferLayout__namespace.u8("padding"), BufferLayout__namespace.u16("signatureOffset"), BufferLayout__namespace.u16("signatureInstructionIndex"), BufferLayout__namespace.u16("publicKeyOffset"), BufferLayout__namespace.u16("publicKeyInstructionIndex"), BufferLayout__namespace.u16("messageDataOffset"), BufferLayout__namespace.u16("messageDataSize"), BufferLayout__namespace.u16("messageInstructionIndex")]);

class Ed25519Program {
  constructor() {
  }
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey2,
      message,
      signature,
      instructionIndex
    } = params;
    assert(publicKey2.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey2.length} bytes`);
    assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
    const signatureOffset = publicKeyOffset + publicKey2.length;
    const messageDataOffset = signatureOffset + signature.length;
    const numSignatures = 1;
    const instructionData = buffer.Buffer.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey2, publicKeyOffset);
    instructionData.fill(signature, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction({
      keys: [],
      programId: Ed25519Program.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair.fromSecretKey(privateKey);
      const publicKey2 = keypair.publicKey.toBytes();
      const signature = sign(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey2,
        message,
        signature,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign = (msgHash, privKey) => {
  const signature = secp256k1.secp256k1.sign(msgHash, privKey);
  return [signature.toCompactRawBytes(), signature.recovery];
};
secp256k1.secp256k1.utils.isValidPrivateKey;
var publicKeyCreate = secp256k1.secp256k1.getPublicKey;
var PRIVATE_KEY_BYTES = 32;
var ETHEREUM_ADDRESS_BYTES = 20;
var PUBLIC_KEY_BYTES = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8("numSignatures"), BufferLayout__namespace.u16("signatureOffset"), BufferLayout__namespace.u8("signatureInstructionIndex"), BufferLayout__namespace.u16("ethAddressOffset"), BufferLayout__namespace.u8("ethAddressInstructionIndex"), BufferLayout__namespace.u16("messageDataOffset"), BufferLayout__namespace.u16("messageDataSize"), BufferLayout__namespace.u8("messageInstructionIndex"), BufferLayout__namespace.blob(20, "ethAddress"), BufferLayout__namespace.blob(64, "signature"), BufferLayout__namespace.u8("recoveryId")]);

class Secp256k1Program {
  constructor() {
  }
  static publicKeyToEthAddress(publicKey2) {
    assert(publicKey2.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey2.length} bytes`);
    try {
      return buffer.Buffer.from(sha3.keccak_256(toBuffer(publicKey2))).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey2,
      message,
      signature,
      recoveryId,
      instructionIndex
    } = params;
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey2),
      message,
      signature,
      recoveryId,
      instructionIndex
    });
  }
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress = buffer.Buffer.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress = buffer.Buffer.from(rawAddress, "hex");
      }
    } else {
      ethAddress = rawAddress;
    }
    assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer(signature),
      ethAddress: toBuffer(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new TransactionInstruction({
      keys: [],
      programId: Secp256k1Program.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer(pkey);
      const publicKey2 = publicKeyCreate(privateKey, false).slice(1);
      const messageHash = buffer.Buffer.from(sha3.keccak_256(toBuffer(message)));
      const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey2,
        message,
        signature,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _class2;
var STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
class Lockup {
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = undefined;
    this.epoch = undefined;
    this.custodian = undefined;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
}
_class2 = Lockup;
Lockup.default = new _class2(0, 0, PublicKey.default);
var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey("newAuthorized"), BufferLayout__namespace.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey("newAuthorized"), BufferLayout__namespace.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
var StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class StakeProgram {
  constructor() {
  }
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: maybeLockup
    } = params;
    const lockup2 = maybeLockup || Lockup.default;
    const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    const data = encodeData(type, {
      authorized: {
        staker: toBuffer(authorized2.staker.toBuffer()),
        withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup2.unixTimestamp,
        epoch: lockup2.epoch,
        custodian: toBuffer(lockup2.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static createAccountWithSeed(params) {
    const transaction = new Transaction;
    transaction.add(SystemProgram.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  static createAccount(params) {
    const transaction = new Transaction;
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Split;
    const data = encodeData(type, {
      lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static split(params) {
    const transaction = new Transaction;
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: 0,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  static splitWithSeed(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction;
    transaction.add(SystemProgram.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Merge;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
}
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey("newAuthorized"), BufferLayout__namespace.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
var VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class VoteProgram {
  constructor() {
  }
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit2
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
    const data = encodeData(type, {
      voteInit: {
        nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
        commission: voteInit2.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static createAccount(params) {
    const transaction = new Transaction;
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insuffcient funds.");
    }
    return VoteProgram.withdraw(params);
  }
}
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3731;
var VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
var InfoString = superstruct.type({
  name: superstruct.string(),
  website: superstruct.optional(superstruct.string()),
  details: superstruct.optional(superstruct.string()),
  keybaseUsername: superstruct.optional(superstruct.string())
});
var VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
var VoteAccountLayout = BufferLayout__namespace.struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  BufferLayout__namespace.u8("commission"),
  BufferLayout__namespace.nu64(),
  BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("slot"), BufferLayout__namespace.u32("confirmationCount")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "votes"),
  BufferLayout__namespace.u8("rootSlotValid"),
  BufferLayout__namespace.nu64("rootSlot"),
  BufferLayout__namespace.nu64(),
  BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "authorizedVoters"),
  BufferLayout__namespace.struct([BufferLayout__namespace.seq(BufferLayout__namespace.struct([publicKey("authorizedPubkey"), BufferLayout__namespace.nu64("epochOfLastAuthorizedSwitch"), BufferLayout__namespace.nu64("targetEpoch")]), 32, "buf"), BufferLayout__namespace.nu64("idx"), BufferLayout__namespace.u8("isEmpty")], "priorVoters"),
  BufferLayout__namespace.nu64(),
  BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("epoch"), BufferLayout__namespace.nu64("credits"), BufferLayout__namespace.nu64("prevCredits")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "epochCredits"),
  BufferLayout__namespace.struct([BufferLayout__namespace.nu64("slot"), BufferLayout__namespace.nu64("timestamp")], "lastTimestamp")
]);
var endpoint = {
  http: {
    devnet: "http://api.devnet.solana.com",
    testnet: "http://api.testnet.solana.com",
    "mainnet-beta": "http://api.mainnet-beta.solana.com/"
  },
  https: {
    devnet: "https://api.devnet.solana.com",
    testnet: "https://api.testnet.solana.com",
    "mainnet-beta": "https://api.mainnet-beta.solana.com/"
  }
};
var $AddressLookupTableAccount = AddressLookupTableAccount;
var $ComputeBudgetProgram = ComputeBudgetProgram;
var $Connection = Connection;
var $Keypair = Keypair;
var $PublicKey = PublicKey;
var $SYSVAR_CLOCK_PUBKEY = SYSVAR_CLOCK_PUBKEY;
var $SYSVAR_RENT_PUBKEY = SYSVAR_RENT_PUBKEY;
var $SystemProgram = SystemProgram;
var $Transaction = Transaction;
var $TransactionInstruction = TransactionInstruction;
var $TransactionMessage = TransactionMessage;
var $clusterApiUrl = clusterApiUrl;

// src/raydium-swap.js
var OH = function(J, $, H) {
  if (H.length) {
    J.push({ pubkey: $, isSigner: false, isWritable: false });
    for (let Q of H)
      J.push({ pubkey: Q instanceof $PublicKey ? Q : Q.publicKey, isSigner: true, isWritable: false });
  } else
    J.push({ pubkey: $, isSigner: true, isWritable: false });
  return J;
};
var _Q = function(J, $, H, Q = [], W = m2) {
  const Z = OH([{ pubkey: J, isSigner: false, isWritable: true }, { pubkey: $, isSigner: false, isWritable: true }], H, Q), Y = Buffer.alloc(kW.span);
  return kW.encode({ instruction: rJ.CloseAccount }, Y), new $TransactionInstruction({ keys: Z, programId: W, data: Y });
};
async function xW(J, $, H, Q = m2) {
  const W = await J.getAccountInfo($, H);
  return I4($, W, Q);
}
var I4 = function(J, $, H = m2) {
  if (!$)
    throw new HH;
  if (!$.owner.equals(H))
    throw new QH;
  if ($.data.length < b$)
    throw new y$;
  const Q = _$.decode($.data.slice(0, b$));
  let W = Buffer.alloc(0);
  if ($.data.length > b$) {
    if ($.data.length === NQ)
      throw new y$;
    if ($.data[b$] != LH.Account)
      throw new Z6;
    W = $.data.slice(b$ + PQ);
  }
  return { address: J, mint: Q.mint, owner: Q.owner, amount: Q.amount, delegate: Q.delegateOption ? Q.delegate : null, delegatedAmount: Q.delegatedAmount, isInitialized: Q.state !== gQ.Uninitialized, isFrozen: Q.state === gQ.Frozen, isNative: !!Q.isNativeOption, rentExemptReserve: Q.isNativeOption ? Q.isNative : null, closeAuthority: Q.closeAuthorityOption ? Q.closeAuthority : null, tlvData: W };
};
var fW = function(J, $, H = m2) {
  if (!$)
    throw new HH;
  if (!$.owner.equals(H))
    throw new QH;
  if ($.data.length < j6)
    throw new y$;
  const Q = TW.decode($.data.slice(0, j6));
  let W = Buffer.alloc(0);
  if ($.data.length > j6) {
    if ($.data.length <= b$)
      throw new y$;
    if ($.data.length === NQ)
      throw new y$;
    if ($.data[b$] != LH.Mint)
      throw new Y6;
    W = $.data.slice(b$ + PQ);
  }
  return { address: J, mintAuthority: Q.mintAuthorityOption ? Q.mintAuthority : null, supply: Q.supply, decimals: Q.decimals, isInitialized: Q.isInitialized, freezeAuthority: Q.freezeAuthorityOption ? Q.freezeAuthority : null, tlvData: W };
};
var kQ = function(J, $, H = false, Q = m2, W = tJ) {
  if (!H && !$PublicKey.isOnCurve($.toBuffer()))
    throw new z6;
  const [Z] = $PublicKey.findProgramAddressSync([$.toBuffer(), Q.toBuffer(), J.toBuffer()], W);
  return Z;
};
var yW = function(J) {
  return KH.struct([lJ("epoch"), lJ("maximumFee"), KH.u16("transferFeeBasisPoints")], J);
};
var mW = function(J) {
  const $ = dW(xQ.TransferFeeConfig, J.tlvData);
  if ($ !== null)
    return IW.decode($);
  else
    return null;
};
var dW = function(J, $) {
  let H = 0;
  while (pW(H) <= $.length) {
    const Q = $.readUInt16LE(H), W = $.readUInt16LE(H + lW), Z = pW(H);
    if (Q == J)
      return $.slice(Z, Z + W);
    H = Z + W;
  }
  return null;
};
var cW = function(J, $, H, Q = m2) {
  const W = [{ pubkey: J, isSigner: false, isWritable: true }, { pubkey: $, isSigner: false, isWritable: false }, { pubkey: H, isSigner: false, isWritable: false }, { pubkey: $SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }], Z = Buffer.alloc(uW.span);
  return uW.encode({ instruction: rJ.InitializeAccount }, Z), new $TransactionInstruction({ keys: W, programId: Q, data: Z });
};
var TQ = function(J, $, H, Q, W = m2, Z = tJ) {
  return a4(J, $, H, Q, Buffer.alloc(0), W, Z);
};
var aW = function(J, $ = m2) {
  const H = [{ pubkey: J, isSigner: false, isWritable: true }], Q = Buffer.alloc(sW.span);
  return sW.encode({ instruction: rJ.SyncNative }, Q), new $TransactionInstruction({ keys: H, programId: $, data: Q });
};
var rW = function(J, $, H, Q, W = [], Z = m2) {
  const Y = OH([{ pubkey: J, isSigner: false, isWritable: true }, { pubkey: $, isSigner: false, isWritable: true }], H, W), z = Buffer.alloc(iW.span);
  return iW.encode({ instruction: rJ.MintTo, amount: BigInt(Q) }, z), new $TransactionInstruction({ keys: Y, programId: Z, data: z });
};
var eW = function(J, $, H, Q, W = [], Z = m2) {
  const Y = OH([{ pubkey: J, isSigner: false, isWritable: true }, { pubkey: $, isSigner: false, isWritable: true }], H, W), z = Buffer.alloc(nW.span);
  return nW.encode({ instruction: rJ.Transfer, amount: BigInt(Q) }, z), new $TransactionInstruction({ keys: Y, programId: Z, data: z });
};
var oW = function(J, $, H, Q, W = m2) {
  const Z = [{ pubkey: J, isSigner: false, isWritable: true }, { pubkey: $SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }], Y = Buffer.alloc(tW.span);
  return tW.encode({ instruction: rJ.InitializeMint, decimals: $, mintAuthority: H, freezeAuthorityOption: Q ? 1 : 0, freezeAuthority: Q || new $PublicKey(0) }, Y), new $TransactionInstruction({ keys: Z, programId: W, data: Y });
};
var Wz = function(J) {
  if (typeof J !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof J}`);
  return new Uint8Array(new TextEncoder().encode(J));
};
var G6 = function(J) {
  if (typeof J === "string")
    J = Wz(J);
  if (!Hz(J))
    throw new Error(`expected Uint8Array, got ${typeof J}`);
  return J;
};
var $Z = function(J) {
  const $ = (Q) => J().update(G6(Q)).digest(), H = J();
  return $.outputLen = H.outputLen, $.blockLen = H.blockLen, $.create = () => J(), $;
};
var VH = function(J) {
  if (J instanceof $PublicKey)
    return J;
  if (typeof J === "string")
    try {
      return new $PublicKey(J);
    } catch {
      return DZ.throwArgumentError("invalid public key", "publicKey", J);
    }
  return DZ.throwArgumentError("invalid public key", "publicKey", J);
};
var h0 = function(J, $) {
  const [H, Q] = $PublicKey.findProgramAddressSync(J, $);
  return { publicKey: H, nonce: Q };
};
var y2 = function(J, $) {
  return { pubkey: J, isWritable: true, isSigner: $ };
};
var d2 = function(J, $) {
  return { pubkey: J, isWritable: false, isSigner: $ };
};
var wH = function(J) {
  return typeof J === "string" ? VH(J) : Array.isArray(J) ? J.map(($) => wH($)) : Lz(J) ? Object.fromEntries(Object.entries(J).map(([$, H]) => [$, wH(H)])) : J;
};
var R6 = function(J, $ = 1, H = []) {
  const Q = [...J];
  if ($ <= 0)
    return H;
  while (Q.length)
    H.push(Q.splice(0, $));
  return H;
};
var CZ = function(J) {
  const $ = [], H = [];
  if (J.microLamports)
    $.push($ComputeBudgetProgram.setComputeUnitPrice({ microLamports: J.microLamports })), H.push($0.setComputeUnitPrice);
  if (J.units)
    $.push($ComputeBudgetProgram.setComputeUnitLimit({ units: J.units })), H.push($0.setComputeUnitLimit);
  return { address: {}, innerTransaction: { instructions: $, signers: [], instructionTypes: H } };
};
async function J$(J, $, H) {
  const { batchRequest: Q, commitment: W } = { ...{ batchRequest: false }, ...H }, Z = R6($, 100);
  let Y = new Array(Z.length).fill([]);
  if (Q) {
    const z = Z.map((U) => {
      return { methodName: "getMultipleAccounts", args: J._buildArgs([U.map((q) => q.toBase58())], W, "base64") };
    }), j = R6(z, 10);
    Y = (await (await Promise.all(j.map(async (U) => await J._rpcBatchRequest(U)))).flat()).map((U) => {
      if (U.error)
        return z$.throwError("failed to get info for multiple accounts", U0.errors.RPC_ERROR, { message: U.error.message });
      return U.result.value.map((C) => {
        if (C) {
          const { data: q, executable: K, lamports: w2, owner: O, rentEpoch: h2 } = C;
          if (q.length !== 2 && q[1] !== "base64")
            return z$.throwError("info must be base64 encoded", U0.errors.RPC_ERROR);
          return { data: Buffer.from(q[0], "base64"), executable: K, lamports: w2, owner: new $PublicKey(O), rentEpoch: h2 };
        } else
          return null;
      });
    });
  } else
    try {
      Y = await Promise.all(Z.map((z) => J.getMultipleAccountsInfo(z, W)));
    } catch (z) {
      if (z instanceof Error)
        return z$.throwError("failed to get info for multiple accounts", U0.errors.RPC_ERROR, { message: z.message });
    }
  return Y.flat();
}
async function FH(J, $, H) {
  const Q = await J$(J, $.map((W) => W.pubkey), H);
  return $.map((W, Z) => ({ ...W, accountInfo: Q[Z] }));
}
var BZ = function(J, $) {
  if (J.length < 1)
    return z$.throwArgumentError("no instructions provided", "instructions", J);
  if ($.length < 1)
    return z$.throwArgumentError("no signers provided", "signers", $);
  const H = new $Transaction({ recentBlockhash: "11111111111111111111111111111111", feePayer: $[0] });
  H.add(...J);
  try {
    return Buffer.from(H.serialize({ verifySignatures: false })).toString("base64").length < MZ;
  } catch (Q) {
    return false;
  }
};
async function M6(J, $, H, Q = true) {
  const W = new $PublicKey("RaydiumSimuLateTransaction11111111111111111"), Z = [];
  let Y = new $Transaction;
  Y.feePayer = W;
  for (let V of $) {
    if (!BZ([...Y.instructions, V], [W]))
      Z.push(Y), Y = new $Transaction, Y.feePayer = W;
    Y.add(V);
  }
  if (Y.instructions.length > 0)
    Z.push(Y);
  let z = [];
  try {
    if (z = await Sz(J, Z, Q), z.find((V) => V.err !== null))
      throw Error("rpc simulateTransaction error");
  } catch (V) {
    if (V instanceof Error)
      return z$.throwError("failed to simulate for instructions", U0.errors.RPC_ERROR, { message: V.message });
  }
  const j = [];
  for (let V of z)
    if (z$.debug("simulate result:", V), V.logs) {
      const U = V.logs.filter((C) => C && C.includes(H));
      z$.debug("filteredLog:", j), z$.assertArgument(U.length !== 0, "simulate log not match keyword", "keyword", H), j.push(...U);
    }
  return j;
}
var O6 = function(J, $) {
  const H = J.match(/{["\w:,]+}/g);
  if (!H || H.length !== 1)
    return z$.throwArgumentError("simulate log fail to match json", "keyword", $);
  return H[0];
};
var C$ = function(J, $) {
  const Q = new RegExp(`"${$}":(\\d+)`, "g").exec(J);
  if (!Q || Q.length !== 2)
    return z$.throwArgumentError("simulate log fail to match key", "key", $);
  return Q[1];
};
async function Sz(J, $, H) {
  let Q = [];
  if (H) {
    const W = await J.getLatestBlockhash(), Z = [];
    for (let V of $) {
      V.recentBlockhash = W.blockhash, V.lastValidBlockHeight = W.lastValidBlockHeight;
      const C = V._compile().serialize(), K = V._serialize(C).toString("base64");
      Z.push(K);
    }
    const Y = Z.map((V) => {
      return { methodName: "simulateTransaction", args: J._buildArgs([V], undefined, "base64") };
    }), z = [], j = 20;
    for (let V = 0;V < Math.ceil(Y.length / j); V++)
      z.push(Y.slice(V * j, (V + 1) * j));
    Q = await (await Promise.all(z.map(async (V) => {
      return (await J._rpcBatchRequest(V)).map((C) => C.result.value);
    }))).flat();
  } else
    try {
      Q = await Promise.all($.map(async (W) => await (await J.simulateTransaction(W)).value));
    } catch (W) {
      if (W instanceof Error)
        return z$.throwError("failed to get info for multiple accounts", U0.errors.RPC_ERROR, { message: W.message });
    }
  return Q;
}
async function L0({ connection: J, makeTxVersion: $, innerTransaction: H, lookupTableCache: Q, computeBudgetConfig: W, payer: Z }) {
  const Y = Q ?? {}, z = [...new Set(H.map((K) => (K.lookupTableAddress ?? []).map((w2) => w2.toString())).flat())], j = [];
  for (let K of z)
    if (Y[K] === undefined)
      j.push(new $PublicKey(K));
  const V = await OZ({ connection: J, address: j });
  for (let [K, w2] of Object.entries(V))
    Y[K] = w2;
  const U = W ? CZ(W).innerTransaction : undefined, C = [];
  let q = [];
  for (let K of H) {
    if (K.instructions.length === 0)
      continue;
    const w2 = [...q, K], O = U ? [U, ...w2] : w2;
    if (q.length < 12 && (cQ({ makeTxVersion: $, innerIns: O, payer: Z, lookupTableAddressAccount: Y }) || cQ({ makeTxVersion: $, innerIns: w2, payer: Z, lookupTableAddressAccount: Y })))
      q.push(K);
    else {
      if (q.length === 0)
        throw Error(" item ins too big ");
      let h2 = undefined;
      if ($ === GH.V0) {
        h2 = {};
        for (let b of [...new Set(q.map((N) => N.lookupTableAddress ?? []).flat().map((N) => N.toString()))])
          if (Y[b] !== undefined)
            h2[b] = Y[b];
      }
      if (cQ({ makeTxVersion: $, innerIns: U ? [U, ...q] : q, payer: Z, lookupTableAddressAccount: Y })) {
        const b = U ? [U, ...q] : q;
        C.push({ instructionTypes: b.map((N) => N.instructionTypes).flat(), instructions: b.map((N) => N.instructions).flat(), signers: q.map((N) => N.signers).flat(), lookupTableAddress: h2 });
      } else
        C.push({ instructionTypes: q.map((b) => b.instructionTypes).flat(), instructions: q.map((b) => b.instructions).flat(), signers: q.map((b) => b.signers).flat(), lookupTableAddress: h2 });
      q = [K];
    }
  }
  if (q.length > 0) {
    let K = undefined;
    if ($ === GH.V0) {
      K = {};
      for (let w2 of [...new Set(q.map((O) => O.lookupTableAddress ?? []).flat().map((O) => O.toString()))])
        if (Y[w2] !== undefined)
          K[w2] = Y[w2];
    }
    if (cQ({ makeTxVersion: $, innerIns: U ? [U, ...q] : q, payer: Z, lookupTableAddressAccount: Y })) {
      const w2 = U ? [U, ...q] : q;
      C.push({ instructionTypes: w2.map((O) => O.instructionTypes).flat(), instructions: w2.map((O) => O.instructions).flat(), signers: q.map((O) => O.signers).flat(), lookupTableAddress: K });
    } else
      C.push({ instructionTypes: q.map((w2) => w2.instructionTypes).flat(), instructions: q.map((w2) => w2.instructions).flat(), signers: q.map((w2) => w2.signers).flat(), lookupTableAddress: K });
  }
  return C;
}
async function OZ({ connection: J, address: $ }) {
  const H = await J$(J, [...new Set($.map((W) => W.toString()))].map((W) => new $PublicKey(W))), Q = {};
  for (let W = 0;W < $.length; W++) {
    const Z = H[W], Y = $[W];
    if (!Z)
      continue;
    Q[Y.toString()] = new $AddressLookupTableAccount({ key: Y, state: $AddressLookupTableAccount.deserialize(Z.data) });
  }
  return Q;
}
var H0 = function(J) {
  if (J instanceof iH.default)
    return J;
  if (typeof J === "string") {
    if (J.match(/^-?[0-9]+$/))
      return new iH.default(J);
    return sQ.throwArgumentError("invalid BigNumberish string", "value", J);
  }
  if (typeof J === "number") {
    if (J % 1)
      return sQ.throwArgumentError("BigNumberish number underflow", "value", J);
    if (J >= KZ || J <= -KZ)
      return sQ.throwArgumentError("BigNumberish number overflow", "value", J);
    return new iH.default(String(J));
  }
  if (typeof J === "bigint")
    return new iH.default(J.toString());
  return sQ.throwArgumentError("invalid BigNumberish value", "value", J);
};
var L6 = function(J) {
  return XH.pow(H0(J));
};
var aQ = function(J, $) {
  const H = J.divmod($);
  if (H.mod.isZero())
    return H.div;
  return H.div.isNeg() ? H.div.isubn(1) : H.div.iaddn(1);
};
var N$ = function(J, $) {
  if (J instanceof r && $ instanceof r)
    return J.equals($);
  else if (J instanceof r || $ instanceof r)
    return false;
  else
    return J === $;
};
var kz = function(J, $) {
  let H = "0", Q = "0";
  if (J.includes(".")) {
    const W = J.split(".");
    if (W.length === 2)
      [H, Q] = W, Q = Q.padEnd($, "0");
    else
      return p$.throwArgumentError("invalid number string", "num", J);
  } else
    H = J;
  return [H, Q.slice(0, $) || Q];
};
var o = function(J) {
  return new K6(1, J);
};
var yJ = function(J) {
  return new K6(4, J);
};
var P = function(J) {
  return new NH(8, false, J);
};
var G0 = function(J) {
  return new NH(16, false, J);
};
var xZ = function(J) {
  return new NH(1, true, J);
};
var tQ = function(J) {
  return new NH(8, true, J);
};
var AZ = function(J) {
  return new NH(16, true, J);
};
var c = function(J) {
  return new w6(p0(32), ($) => new $PublicKey($), ($) => $.toBuffer(), J);
};
var cJ = function(J) {
  return new w6(gZ(), Tz, fz, J);
};
var Tz = function(J) {
  if (J === 0)
    return false;
  else if (J === 1)
    return true;
  throw new Error("Invalid bool: " + J);
};
var fz = function(J) {
  return J ? 1 : 0;
};
var e = function(J, $, H) {
  return new TZ(J, $, H);
};
var z0 = function(J, $, H) {
  let Q;
  const W = typeof $ === "number" ? $ : PH.isBN($) ? $.toNumber() : new Proxy($, { get(Z, Y) {
    if (!Q) {
      const z = Reflect.get(Z, "count");
      Q = PH.isBN(z) ? z.toNumber() : z, Reflect.set(Z, "count", Q);
    }
    return Reflect.get(Z, Y);
  }, set(Z, Y, z) {
    if (Y === "count")
      Q = z;
    return Reflect.set(Z, Y, z);
  } });
  return kZ(J, W, H);
};
var n0 = function(J, $, H) {
  return h0([J.toBuffer(), H.toBuffer(), $.toBuffer()], new $PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"));
};
var g$ = function({ fromPublicKey: J, programId: $ = m2 }) {
  const H = $Keypair.generate().publicKey.toBase58().slice(0, 32);
  return { publicKey: uz(J, H, $), seed: H };
};
var sJ = function(J, $, H, Q) {
  if ($ === undefined)
    return { amount: J, fee: undefined, expirationTime: undefined };
  const W = H.epoch < $.newerTransferFee.epoch ? $.olderTransferFee : $.newerTransferFee, Z = new B$.default(W.maximumFee.toString()), Y = H.epoch < $.newerTransferFee.epoch ? (Number($.newerTransferFee.epoch) * H.slotsInEpoch - H.absoluteSlot) * 400 / 1000 : undefined;
  if (Q)
    if (W.transferFeeBasisPoints === tH) {
      const z = new B$.default(W.maximumFee.toString());
      return { amount: J.add(z), fee: z, expirationTime: Y };
    } else {
      const z = oH(J.mul(new B$.default(tH)), new B$.default(tH - W.transferFeeBasisPoints)), j = new B$.default(W.maximumFee.toString()), V = z.sub(J).gt(j) ? J.add(j) : z, U = oH(V.mul(new B$.default(W.transferFeeBasisPoints)), new B$.default(tH)), C = U.gt(Z) ? Z : U;
      return { amount: V, fee: C, expirationTime: Y };
    }
  else {
    const z = oH(J.mul(new B$.default(W.transferFeeBasisPoints)), new B$.default(tH)), j = z.gt(Z) ? Z : z;
    return { amount: J, fee: j, expirationTime: Y };
  }
};
var JQ = function(J, $) {
  if (J === undefined)
    return $;
  if ($ === undefined)
    return J;
  return Math.min(J, $);
};
async function b6({ connection: J, mints: $ }) {
  if ($.length === 0)
    return {};
  const H = await FH(J, $.map((W) => ({ pubkey: W }))), Q = {};
  for (let W of H) {
    const Z = fW(W.pubkey, W.accountInfo, W.accountInfo?.owner);
    Q[W.pubkey.toString()] = { ...Z, feeConfig: mW(Z) ?? undefined };
  }
  return Q;
}
var oH = function(J, $) {
  const { div: H, mod: Q } = J.divmod($);
  if (Q.gt(J0))
    return H.add(k0);
  else
    return H;
};
var IZ = function(J, $, H, Q, W, Z) {
  const Y = e([o("ins")]), z = [d2($, false), d2(H, false), y2(Z, false), d2(Q, false), y2(W, true), d2(t0, false)], j = Buffer.alloc(Y.span);
  return Y.encode({ ins: 23 }, j), new $TransactionInstruction({ keys: z, programId: J, data: j });
};
var mZ = function(J, $, H, Q, W, Z, Y, z) {
  const j = e([o("voterBump"), o("voterWeightRecordBump")]), V = [d2($, false), y2(H, false), d2(W, true), y2(Q, false), y2(Z, true), d2(t0, false), d2(v$, false), d2(uQ, false)], U = Buffer.alloc(j.span);
  j.encode({ voterBump: Y, voterWeightRecordBump: z }, U);
  const C = Buffer.from([...$Q.voterStakeRegistryCreateVoter, ...U]);
  return new $TransactionInstruction({ keys: V, programId: J, data: C });
};
var dZ = function(J, $, H, Q, W, Z, Y, z, j, V, U, C) {
  const q = e([o("depositEntryIndex"), o("kind"), o("option"), P("startTs"), yJ("periods"), cJ("allowClawback")]), K = [d2($, false), y2(H, false), y2(Q, false), d2(W, true), y2(Z, true), d2(Y, false), d2(t0, false), d2(m2, false), d2(tJ, false), d2(v$, false)], w2 = Buffer.alloc(q.span);
  q.encode({ depositEntryIndex: z, kind: j, option: V === undefined ? 0 : 1, startTs: V ?? J0, periods: U, allowClawback: C }, w2);
  const O = Buffer.from([...$Q.voterStakeRegistryCreateDepositEntry, ...w2]);
  return new $TransactionInstruction({ keys: K, programId: J, data: O });
};
var pZ = function(J, $, H, Q, W, Z, Y, z, j, V, U, C, q) {
  const K = e([o("depositEntryIndex"), P("amount")]), w2 = [d2($, false), y2(H, false), y2(Q, false), y2(W, false), d2(Z, true), d2(m2, false), y2(Y, false), d2(z, false), y2(j, false), d2(V, false), d2(U, false), d2(uQ, false)], O = Buffer.alloc(K.span);
  K.encode({ depositEntryIndex: C, amount: q }, O);
  const h2 = Buffer.from([...$Q.voterStakeRegistryDeposit, ...O]);
  return new $TransactionInstruction({ keys: w2, programId: J, data: h2 });
};
var lZ = function(J, $, H, Q) {
  const W = e([]), Z = [d2($, false), d2(H, false), y2(Q, false), d2(t0, false)], Y = Buffer.alloc(W.span);
  W.encode({}, Y);
  const z = Buffer.from([...$Q.voterStakeRegistryUpdateVoterWeightRecord, ...Y]);
  return new $TransactionInstruction({ keys: Z, programId: J, data: z });
};
var uZ = function(J, $, H, Q, W, Z, Y, z, j, V, U, C, q, K, w2) {
  const O = e([o("depositEntryIndex"), P("amount")]), h2 = [d2($, false), y2(H, false), d2(Q, true), d2(W, false), y2(Z, false), y2(Y, false), y2(z, false), d2(m2, false), y2(j, false), d2(V, false), y2(U, false), d2(C, false), d2(q, false), d2(uQ, false)], b = Buffer.alloc(O.span);
  O.encode({ depositEntryIndex: K, amount: w2 }, b);
  const N = Buffer.from([...$Q.voterStakeRegistryWithdraw, ...b]);
  return new $TransactionInstruction({ keys: h2, programId: J, data: N });
};
var x6 = function(J, $, H) {
  return h0([$.toBuffer(), Buffer.from("registrar", "utf8"), H.toBuffer()], J);
};
var A6 = function(J, $) {
  return h0([$.toBuffer(), Buffer.from("voting_mint_seed", "utf8")], J);
};
var T6 = function(J, $) {
  return h0([$.toBuffer()], J);
};
var f6 = function(J, $, H) {
  return h0([$.toBuffer(), Buffer.from("voter", "utf8"), H.toBuffer()], J);
};
var y6 = function(J, $, H) {
  return h0([$.toBuffer(), Buffer.from("voter-weight-record", "utf8"), H.toBuffer()], J);
};
var I6 = function(J, $, H, Q) {
  return h0([Buffer.from("governance", "utf8"), $.toBuffer(), H.toBuffer(), Q.toBuffer()], J);
};
async function nZ(J, $, H, Q) {
  const W = await J.getAccountInfo($);
  if (W === null)
    throw Error("registrar info check error");
  const Y = aZ.decode(W.data).votingMints.findIndex((U) => U.mint.equals(Q));
  if (Y === -1)
    throw Error("find voter mint error");
  const z = await J.getAccountInfo(H);
  if (z === null)
    return { index: Y, isInit: false };
  const V = iZ.decode(z.data).deposits.findIndex((U) => U.isUsed && U.votingMintConfigIdx === Y);
  if (V === -1)
    return { index: Y, isInit: false };
  else
    return { index: V, isInit: true };
}
var FY = function(J, $, H, Q, W, Z, Y, z, j, V, U, C, q, K) {
  const w2 = e([G0("sqrtPriceX64"), P("startTime")]), O = [{ pubkey: H, isSigner: true, isWritable: true }, { pubkey: Q, isSigner: false, isWritable: false }, { pubkey: $, isSigner: false, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: false }, { pubkey: j, isSigner: false, isWritable: false }, { pubkey: Y, isSigner: false, isWritable: true }, { pubkey: V, isSigner: false, isWritable: true }, { pubkey: W, isSigner: false, isWritable: false }, { pubkey: C, isSigner: false, isWritable: true }, { pubkey: z, isSigner: false, isWritable: false }, { pubkey: U, isSigner: false, isWritable: false }, { pubkey: t0, isSigner: false, isWritable: false }, { pubkey: v$, isSigner: false, isWritable: false }], h2 = Buffer.alloc(w2.span);
  w2.encode({ sqrtPriceX64: q, startTime: K }, h2);
  const b = Buffer.from([...U$.createPool, ...h2]);
  return new $TransactionInstruction({ keys: O, programId: J, data: b });
};
var XY = function(J, $, H, Q, W, Z, Y, z, j, V, U, C, q, K, w2, O, h2, b, N, x, k, g, A, I, T, u) {
  const a = e([kJ("tickLowerIndex"), kJ("tickUpperIndex"), kJ("tickArrayLowerStartIndex"), kJ("tickArrayUpperStartIndex"), G0("liquidity"), P("amountMaxA"), P("amountMaxB"), cJ("withMetadata"), o("optionBaseFlag"), cJ("baseFlag")]), n = [...u ? [{ pubkey: u, isSigner: false, isWritable: true }] : []], Z0 = [{ pubkey: $, isSigner: true, isWritable: true }, { pubkey: Q, isSigner: false, isWritable: false }, { pubkey: W, isSigner: true, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: true }, { pubkey: Y, isSigner: false, isWritable: true }, { pubkey: H, isSigner: false, isWritable: true }, { pubkey: z, isSigner: false, isWritable: true }, { pubkey: j, isSigner: false, isWritable: true }, { pubkey: V, isSigner: false, isWritable: true }, { pubkey: U, isSigner: false, isWritable: true }, { pubkey: C, isSigner: false, isWritable: true }, { pubkey: q, isSigner: false, isWritable: true }, { pubkey: K, isSigner: false, isWritable: true }, { pubkey: w2, isSigner: false, isWritable: true }, { pubkey: v$, isSigner: false, isWritable: false }, { pubkey: t0, isSigner: false, isWritable: false }, { pubkey: m2, isSigner: false, isWritable: false }, { pubkey: tJ, isSigner: false, isWritable: false }, { pubkey: SH, isSigner: false, isWritable: false }, { pubkey: W$, isSigner: false, isWritable: false }, { pubkey: O, isSigner: false, isWritable: false }, { pubkey: h2, isSigner: false, isWritable: false }, ...n], _ = Buffer.alloc(a.span);
  a.encode({ tickLowerIndex: b, tickUpperIndex: N, tickArrayLowerStartIndex: x, tickArrayUpperStartIndex: k, liquidity: g, amountMaxA: A, amountMaxB: I, withMetadata: T === "create", baseFlag: false, optionBaseFlag: 0 }, _);
  const G = Buffer.from([...U$.openPosition, ..._]);
  return new $TransactionInstruction({ keys: Z0, programId: J, data: G });
};
var UY = function(J, $, H, Q, W, Z, Y, z, j, V, U, C, q, K, w2, O, h2, b, N, x, k, g, A, I, T, u) {
  const a = e([kJ("tickLowerIndex"), kJ("tickUpperIndex"), kJ("tickArrayLowerStartIndex"), kJ("tickArrayUpperStartIndex"), G0("liquidity"), P("amountMaxA"), P("amountMaxB"), cJ("withMetadata"), o("optionBaseFlag"), cJ("baseFlag")]), n = [...u ? [{ pubkey: u, isSigner: false, isWritable: true }] : []], Z0 = [{ pubkey: $, isSigner: true, isWritable: true }, { pubkey: Q, isSigner: false, isWritable: false }, { pubkey: W, isSigner: true, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: true }, { pubkey: Y, isSigner: false, isWritable: true }, { pubkey: H, isSigner: false, isWritable: true }, { pubkey: z, isSigner: false, isWritable: true }, { pubkey: j, isSigner: false, isWritable: true }, { pubkey: V, isSigner: false, isWritable: true }, { pubkey: U, isSigner: false, isWritable: true }, { pubkey: C, isSigner: false, isWritable: true }, { pubkey: q, isSigner: false, isWritable: true }, { pubkey: K, isSigner: false, isWritable: true }, { pubkey: w2, isSigner: false, isWritable: true }, { pubkey: v$, isSigner: false, isWritable: false }, { pubkey: t0, isSigner: false, isWritable: false }, { pubkey: m2, isSigner: false, isWritable: false }, { pubkey: tJ, isSigner: false, isWritable: false }, { pubkey: SH, isSigner: false, isWritable: false }, { pubkey: W$, isSigner: false, isWritable: false }, { pubkey: O, isSigner: false, isWritable: false }, { pubkey: h2, isSigner: false, isWritable: false }, ...n], _ = Buffer.alloc(a.span);
  a.encode({ tickLowerIndex: b, tickUpperIndex: N, tickArrayLowerStartIndex: x, tickArrayUpperStartIndex: k, liquidity: J0, amountMaxA: A === "MintA" ? I : T, amountMaxB: A === "MintA" ? T : I, withMetadata: g === "create", baseFlag: A === "MintA", optionBaseFlag: 1 }, _);
  const G = Buffer.from([...U$.openPosition, ..._]);
  return new $TransactionInstruction({ keys: Z0, programId: J, data: G });
};
var DY = function(J, $, H, Q, W) {
  const Z = e([]), Y = [{ pubkey: $, isSigner: true, isWritable: true }, { pubkey: H, isSigner: false, isWritable: true }, { pubkey: Q, isSigner: false, isWritable: true }, { pubkey: W, isSigner: false, isWritable: true }, { pubkey: t0, isSigner: false, isWritable: false }, { pubkey: m2, isSigner: false, isWritable: false }], z = Buffer.alloc(Z.span);
  Z.encode({}, z);
  const j = Buffer.from([...U$.closePosition, ...z]);
  return new $TransactionInstruction({ keys: Y, programId: J, data: j });
};
var qY = function(J, $, H, Q, W, Z, Y, z, j, V, U, C, q, K, w2, O, h2, b) {
  const N = e([G0("liquidity"), P("amountMaxA"), P("amountMaxB"), o("optionBaseFlag"), cJ("baseFlag")]), x = [...b ? [{ pubkey: b, isSigner: false, isWritable: true }] : []], k = [{ pubkey: $, isSigner: true, isWritable: false }, { pubkey: H, isSigner: false, isWritable: false }, { pubkey: W, isSigner: false, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: true }, { pubkey: Q, isSigner: false, isWritable: true }, { pubkey: Y, isSigner: false, isWritable: true }, { pubkey: z, isSigner: false, isWritable: true }, { pubkey: j, isSigner: false, isWritable: true }, { pubkey: V, isSigner: false, isWritable: true }, { pubkey: U, isSigner: false, isWritable: true }, { pubkey: C, isSigner: false, isWritable: true }, { pubkey: m2, isSigner: false, isWritable: false }, { pubkey: W$, isSigner: false, isWritable: false }, { pubkey: q, isSigner: false, isWritable: false }, { pubkey: K, isSigner: false, isWritable: false }, ...x], g = Buffer.alloc(N.span);
  N.encode({ liquidity: w2, amountMaxA: O, amountMaxB: h2, optionBaseFlag: 0, baseFlag: false }, g);
  const A = Buffer.from([...U$.increaseLiquidity, ...g]);
  return new $TransactionInstruction({ keys: k, programId: J, data: A });
};
var vY = function(J, $, H, Q, W, Z, Y, z, j, V, U, C, q, K, w2, O, h2, b) {
  const N = e([G0("liquidity"), P("amountMaxA"), P("amountMaxB"), o("optionBaseFlag"), cJ("baseFlag")]), x = [...b ? [{ pubkey: b, isSigner: false, isWritable: true }] : []], k = [{ pubkey: $, isSigner: true, isWritable: false }, { pubkey: H, isSigner: false, isWritable: false }, { pubkey: W, isSigner: false, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: true }, { pubkey: Q, isSigner: false, isWritable: true }, { pubkey: Y, isSigner: false, isWritable: true }, { pubkey: z, isSigner: false, isWritable: true }, { pubkey: j, isSigner: false, isWritable: true }, { pubkey: V, isSigner: false, isWritable: true }, { pubkey: U, isSigner: false, isWritable: true }, { pubkey: C, isSigner: false, isWritable: true }, { pubkey: m2, isSigner: false, isWritable: false }, { pubkey: W$, isSigner: false, isWritable: false }, { pubkey: q, isSigner: false, isWritable: false }, { pubkey: K, isSigner: false, isWritable: false }, ...x], g = Buffer.alloc(N.span);
  N.encode({ liquidity: J0, amountMaxA: w2 === "MintA" ? O : h2, amountMaxB: w2 === "MintA" ? h2 : O, baseFlag: w2 === "MintA", optionBaseFlag: 1 }, g);
  const A = Buffer.from([...U$.increaseLiquidity, ...g]);
  return new $TransactionInstruction({ keys: k, programId: J, data: A });
};
var CY = function(J, $, H, Q, W, Z, Y, z, j, V, U, C, q, K, w2, O, h2, b, N) {
  const x = e([G0("liquidity"), P("amountMinA"), P("amountMinB")]), k = [...N ? [{ pubkey: N, isSigner: false, isWritable: true }] : [], ...w2.map((T) => [{ pubkey: T.poolRewardVault, isSigner: false, isWritable: true }, { pubkey: T.ownerRewardVault, isSigner: false, isWritable: true }, { pubkey: T.rewardMint, isSigner: false, isWritable: false }]).flat()], g = [{ pubkey: $, isSigner: true, isWritable: false }, { pubkey: H, isSigner: false, isWritable: false }, { pubkey: Q, isSigner: false, isWritable: true }, { pubkey: W, isSigner: false, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: true }, { pubkey: U, isSigner: false, isWritable: true }, { pubkey: C, isSigner: false, isWritable: true }, { pubkey: Y, isSigner: false, isWritable: true }, { pubkey: z, isSigner: false, isWritable: true }, { pubkey: j, isSigner: false, isWritable: true }, { pubkey: V, isSigner: false, isWritable: true }, { pubkey: m2, isSigner: false, isWritable: false }, { pubkey: W$, isSigner: false, isWritable: false }, { pubkey: cH, isSigner: false, isWritable: false }, { pubkey: q, isSigner: false, isWritable: false }, { pubkey: K, isSigner: false, isWritable: false }, ...k], A = Buffer.alloc(x.span);
  x.encode({ liquidity: O, amountMinA: h2, amountMinB: b }, A);
  const I = Buffer.from([...U$.decreaseLiquidity, ...A]);
  return new $TransactionInstruction({ keys: g, programId: J, data: I });
};
var a6 = function(J, $, H, Q, W, Z, Y, z, j, V, U, C, q, K, w2, O, h2) {
  const b = e([P("amount"), P("otherAmountThreshold"), G0("sqrtPriceLimitX64"), cJ("isBaseInput")]), N = [...h2 ? [{ pubkey: h2, isSigner: false, isWritable: true }] : [], ...U.map((A) => ({ pubkey: A, isSigner: false, isWritable: true }))], x = [{ pubkey: $, isSigner: true, isWritable: false }, { pubkey: Q, isSigner: false, isWritable: false }, { pubkey: H, isSigner: false, isWritable: true }, { pubkey: W, isSigner: false, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: true }, { pubkey: Y, isSigner: false, isWritable: true }, { pubkey: z, isSigner: false, isWritable: true }, { pubkey: C, isSigner: false, isWritable: true }, { pubkey: m2, isSigner: false, isWritable: false }, { pubkey: W$, isSigner: false, isWritable: false }, { pubkey: cH, isSigner: false, isWritable: false }, { pubkey: j, isSigner: false, isWritable: false }, { pubkey: V, isSigner: false, isWritable: false }, ...N], k = Buffer.alloc(b.span);
  b.encode({ amount: q, otherAmountThreshold: K, sqrtPriceLimitX64: w2, isBaseInput: O }, k);
  const g = Buffer.from([...U$.swap, ...k]);
  return new $TransactionInstruction({ keys: x, programId: J, data: g });
};
var RY = function(J, $, H, Q, W, Z, Y, z, j, V, U, C) {
  const q = e([P("openTime"), P("endTime"), G0("emissionsPerSecondX64")]), K = [{ pubkey: $, isSigner: true, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: true }, { pubkey: W, isSigner: false, isWritable: false }, { pubkey: H, isSigner: false, isWritable: true }, { pubkey: Q, isSigner: false, isWritable: true }, { pubkey: z, isSigner: false, isWritable: false }, { pubkey: j, isSigner: false, isWritable: true }, { pubkey: Y, isSigner: false, isWritable: false }, { pubkey: t0, isSigner: false, isWritable: false }, { pubkey: v$, isSigner: false, isWritable: false }], w2 = Buffer.alloc(q.span);
  q.encode({ openTime: H0(V), endTime: H0(U), emissionsPerSecondX64: C }, w2);
  const O = Buffer.from([...U$.initReward, ...w2]);
  return new $TransactionInstruction({ keys: K, programId: J, data: O });
};
var BY = function(J, $, H, Q, W, Z, Y, z, j, V, U, C) {
  const q = e([o("rewardIndex"), G0("emissionsPerSecondX64"), P("openTime"), P("endTime")]), K = [{ pubkey: $, isSigner: true, isWritable: true }, { pubkey: W, isSigner: false, isWritable: false }, { pubkey: H, isSigner: false, isWritable: true }, { pubkey: Q, isSigner: false, isWritable: true }, { pubkey: m2, isSigner: false, isWritable: false }, { pubkey: W$, isSigner: false, isWritable: false }, { pubkey: Y, isSigner: false, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: true }, { pubkey: z, isSigner: false, isWritable: true }], w2 = Buffer.alloc(q.span);
  q.encode({ rewardIndex: j, emissionsPerSecondX64: C, openTime: H0(V), endTime: H0(U) }, w2);
  const O = Buffer.from([...U$.setRewardEmissions, ...w2]);
  return new $TransactionInstruction({ keys: K, programId: J, data: O });
};
var MY = function(J, $, H, Q, W, Z, Y) {
  const z = e([o("rewardIndex")]), j = [{ pubkey: $, isSigner: true, isWritable: true }, { pubkey: Q, isSigner: false, isWritable: true }, { pubkey: H, isSigner: false, isWritable: true }, { pubkey: W, isSigner: false, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: false }, { pubkey: m2, isSigner: false, isWritable: false }, { pubkey: W$, isSigner: false, isWritable: false }, { pubkey: cH, isSigner: false, isWritable: false }], V = Buffer.alloc(z.span);
  z.encode({ rewardIndex: Y }, V);
  const U = Buffer.from([...U$.collectReward, ...V]);
  return new $TransactionInstruction({ keys: j, programId: J, data: U });
};
var V8 = function(J) {
  const $ = new ArrayBuffer(4);
  return new DataView($).setInt32(0, J, false), new Uint8Array($);
};
var r6 = function(J, $) {
  let H = 0;
  for (let Q = J - 1;Q >= 0; Q--)
    if (!$.testn(Q))
      H++;
    else
      break;
  return H;
};
var n6 = function(J, $) {
  let H = 0;
  for (let Q = 0;Q < J; Q++)
    if (!$.testn(Q))
      H++;
    else
      break;
  return H;
};
var zQ = function(J, $) {
  for (let H = 0;H < J; H++)
    if ($.testn(H))
      return false;
  return true;
};
var SY = function(J, $) {
  if (zQ(J, $))
    return null;
  else
    return r6(J, $);
};
var wY = function(J, $) {
  if (zQ(J, $))
    return null;
  else
    return n6(J, $);
};
var _Y = function(J, $, H, Q) {
  return h0([r9, $.toBuffer(), H.toBuffer(), Q.toBuffer()], J);
};
var e6 = function(J, $, H) {
  return h0([n9, $.toBuffer(), H.toBuffer()], J);
};
var PY = function(J, $, H) {
  return h0([e9, $.toBuffer(), H.toBuffer()], J);
};
var m0 = function(J, $, H) {
  return h0([t9, $.toBuffer(), V8(H)], J);
};
var TH = function(J, $, H, Q) {
  return h0([bY, $.toBuffer(), V8(H), V8(Q)], J);
};
var a$ = function(J, $) {
  return h0([bY, $.toBuffer()], J);
};
var t6 = function(J) {
  return h0([Buffer.from("metadata", "utf8"), SH.toBuffer(), J.toBuffer()], SH);
};
var G8 = function(J) {
  return h0([o9], J);
};
var D$ = function(J, $) {
  return h0([Jj, $.toBuffer()], J);
};
var cY = function(J, $, H, Q) {
  const W = HW(J, $, H), Z = CH(J, $, W), Y = CH(J, H, W), z = CH(J, Q, W), [V, U, C, q] = uY(J, Z, z, true);
  if (!q)
    return 0;
  if (C)
    return Q * J.multiplier / V;
  else {
    const K = Y - U;
    return lY(J, K, W);
  }
};
var sY = function(J, $, H, Q) {
  const W = HW(J, $, H), Z = CH(J, $, W), Y = CH(J, H, W), z = CH(J, Q, W), [V, U, C, q] = Mj(J, Y, z, false);
  if (!q)
    return 0;
  if (C)
    return Q * V / J.multiplier;
  else {
    const K = Z - U;
    return lY(J, K, W);
  }
};
var aY = function(J) {
  const $ = Uj.decode(J);
  return { accountType: $.accountType.toNumber(), status: $.status.toNumber(), multiplier: $.multiplier.toNumber(), validDataCount: $.validDataCount.toNumber(), DataElement: $.DataElement.map((H) => ({ x: H.x.toNumber(), y: H.y.toNumber(), price: H.price.toNumber() })) };
};
var iY = function(J, $, H, Q) {
  const W = Oj(J, CH(J, $, HW(J, $, H))) / J.multiplier;
  return Q ? W : 1 / W;
};
async function rY(J) {
  if (FQ.validDataCount === 0) {
    if (J) {
      const $ = await J.getAccountInfo(yH);
      if ($)
        FQ = aY($?.data);
    }
  }
}
var C8 = function(J, $) {
  let { quoteMint: H, baseMint: Q, quoteDecimals: W, baseDecimals: Z } = J;
  if ($ === "out")
    H = J.baseMint, Q = J.quoteMint, W = J.baseDecimals, Z = J.quoteDecimals;
  let Y = new r(J.marketProgramId, H, W), z = new r(J.marketProgramId, Q, Z);
  return { currencyIn: Y, currencyOut: z, currencyInDecimals: W, currencyOutDecimals: Z, currencyInMint: H, currencyOutMint: Q };
};
var bj = function(J, $, H, Q) {
  const { currencyIn: W, currencyOut: Z, currencyInDecimals: Y } = C8($, "out");
  let z = new O0(W, 1, false);
  const j = new uJ(0, 100), { amountOut: V } = S$.computeAmountOut({ poolKeys: $, poolInfo: H, amountIn: z, currencyOut: Z, slippage: j }), U = Q * Math.pow(10, Y + 1) / V.numerator.toNumber();
  return console.log("actualRawAmount", U), U;
};
async function tY(J, $, H, Q) {
  const W = await S$.fetchInfo({ connection: J, poolKeys: $ });
  let Z = H;
  if (Q === "out")
    Z = bj(J, $, W, H);
  const { currencyIn: Y, currencyOut: z } = C8($, Q);
  let j = new O0(Y, Z, false);
  const V = new uJ(0, 100), { amountOut: U } = S$.computeAmountOut({ poolKeys: $, poolInfo: W, amountIn: j, currencyOut: z, slippage: V });
  return { amountIn: j, amountOut: U };
}
async function oY(J, $, H) {
  const Q = kQ($, H);
  let W;
  try {
    await xW(J, Q);
  } catch (Z) {
    if (Z instanceof HH || Z instanceof QH)
      W = TQ(H, Q, H, $);
    else
      throw Z;
  }
  return W;
}
async function x7(J, $, H, Q) {
  try {
    const W = new $Transaction, Z = await J.getLatestBlockhash();
    W.recentBlockhash = Z.blockhash, W.lastValidBlockHeight = Z.lastValidBlockHeight;
    const { currencyInMint: Y, currencyOutMint: z, currencyInDecimals: j, currencyOutDecimals: V } = C8(XQ, Q), U = await oY(J, Y, $.publicKey);
    if (U)
      W.add(U);
    const C = await oY(J, z, $.publicKey);
    if (C)
      W.add(C);
    const q = new r(XQ.marketProgramId, Y, j), K = new r(XQ.marketProgramId, z, V), { amountIn: w2, amountOut: O } = await tY(J, XQ, H, Q), h2 = kQ(Y, $.publicKey), b = kQ(z, $.publicKey);
    if (Q === "in") {
      const k = $SystemProgram.transfer({ fromPubkey: $.publicKey, toPubkey: h2, lamports: w2.numerator.toNumber() });
      W.add(k);
      const g = aW(h2);
      W.add(g);
    }
    const N = await S$.makeSwapInstruction({ poolKeys: XQ, amountIn: w2.numerator.toNumber(), amountOut: O.numerator.toNumber(), userKeys: { owner: $.publicKey, tokenAccountIn: h2, tokenAccountOut: b }, fixedSide: "in" });
    W.add(...N.innerTransaction.instructions);
    const x = _Q(Q === "in" ? h2 : b, $.publicKey, $.publicKey);
    if (W.add(x), W.instructions.length === 0) {
      console.log("no instruction");
      return;
    }
    return console.log("Sending..."), J.sendTransaction(W, [$]);
  } catch (W) {
    const Z = W.logs?.filter((Y) => Y.includes("Error:"))[0];
    console.error("error:", Z || W.message);
  }
}
import.meta.require ||= (id) => createImportMetaRequire(import.meta.url)(id);
var J1 = Object.create;
var { defineProperty: BW, getPrototypeOf: $1, getOwnPropertyNames: H1 } = Object;
var Q1 = Object.prototype.hasOwnProperty;
var E0 = (J, $, H) => {
  H = J != null ? J1($1(J)) : {};
  const Q = $ || !J || !J.__esModule ? BW(H, "default", { value: J, enumerable: true }) : H;
  for (let W of H1(J))
    if (!Q1.call(Q, W))
      BW(Q, W, { get: () => J[W], enumerable: true });
  return Q;
};
var t$ = (J, $) => () => ($ || J(($ = { exports: {} }).exports, $), $.exports);
var mH = (J) => {
  return import.meta.require(J);
};
var pJ = t$((MW) => {
  var MH = function(J) {
    if (!(J instanceof Uint8Array))
      throw new TypeError("b must be a Uint8Array");
  }, w0 = function(J) {
    return MH(J), y8.Buffer.from(J.buffer, J.byteOffset, J.length);
  }, I8 = function(J, $) {
    if ($.property)
      return J + "[" + $.property + "]";
    return J;
  }, W1 = function(J, $) {
    if (typeof J !== "function")
      throw new TypeError("Class must be constructor");
    if (Object.prototype.hasOwnProperty.call(J, "layout_"))
      throw new Error("Class is already bound to a layout");
    if (!($ && $ instanceof g0))
      throw new TypeError("layout must be a Layout");
    if (Object.prototype.hasOwnProperty.call($, "boundConstructor_"))
      throw new Error("layout is already bound to a constructor");
    J.layout_ = $, $.boundConstructor_ = J, $.makeDestinationObject = () => new J, Object.defineProperty(J.prototype, "encode", { value(H, Q) {
      return $.encode(this, H, Q);
    }, writable: true }), Object.defineProperty(J, "decode", { value(H, Q) {
      return $.decode(H, Q);
    }, writable: true });
  }, qQ = function(J) {
    const $ = Math.floor(J / f8), H = J - $ * f8;
    return { hi32: $, lo32: H };
  }, vQ = function(J, $) {
    return J * f8 + $;
  }, BH = function(J) {
    if (0 > J)
      J += 4294967296;
    return J;
  };
  Object.defineProperty(MW, "__esModule", { value: true });
  MW.s16 = MW.s8 = MW.nu64be = MW.u48be = MW.u40be = MW.u32be = MW.u24be = MW.u16be = MW.nu64 = MW.u48 = MW.u40 = MW.u32 = MW.u24 = MW.u16 = MW.u8 = MW.offset = MW.greedy = MW.Constant = MW.UTF8 = MW.CString = MW.Blob = MW.Boolean = MW.BitField = MW.BitStructure = MW.VariantLayout = MW.Union = MW.UnionLayoutDiscriminator = MW.UnionDiscriminator = MW.Structure = MW.Sequence = MW.DoubleBE = MW.Double = MW.FloatBE = MW.Float = MW.NearInt64BE = MW.NearInt64 = MW.NearUInt64BE = MW.NearUInt64 = MW.IntBE = MW.Int = MW.UIntBE = MW.UInt = MW.OffsetLayout = MW.GreedyCount = MW.ExternalLayout = MW.bindConstructorLayout = MW.nameWithProperty = MW.Layout = MW.uint8ArrayToBuffer = MW.checkUint8Array = undefined;
  MW.constant = MW.utf8 = MW.cstr = MW.blob = MW.unionLayoutDiscriminator = MW.union = MW.seq = MW.bits = MW.struct = MW.f64be = MW.f64 = MW.f32be = MW.f32 = MW.ns64be = MW.s48be = MW.s40be = MW.s32be = MW.s24be = MW.s16be = MW.ns64 = MW.s48 = MW.s40 = MW.s32 = MW.s24 = undefined;
  var y8 = mH("buffer");
  MW.checkUint8Array = MH;
  MW.uint8ArrayToBuffer = w0;

  class g0 {
    constructor(J, $) {
      if (!Number.isInteger(J))
        throw new TypeError("span must be an integer");
      this.span = J, this.property = $;
    }
    makeDestinationObject() {
      return {};
    }
    getSpan(J, $) {
      if (0 > this.span)
        throw new RangeError("indeterminate span");
      return this.span;
    }
    replicate(J) {
      const $ = Object.create(this.constructor.prototype);
      return Object.assign($, this), $.property = J, $;
    }
    fromArray(J) {
      return;
    }
  }
  MW.Layout = g0;
  MW.nameWithProperty = I8;
  MW.bindConstructorLayout = W1;

  class dJ extends g0 {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  }
  MW.ExternalLayout = dJ;

  class m8 extends dJ {
    constructor(J = 1, $) {
      if (!Number.isInteger(J) || 0 >= J)
        throw new TypeError("elementSpan must be a (positive) integer");
      super(-1, $);
      this.elementSpan = J;
    }
    isCount() {
      return true;
    }
    decode(J, $ = 0) {
      MH(J);
      const H = J.length - $;
      return Math.floor(H / this.elementSpan);
    }
    encode(J, $, H) {
      return 0;
    }
  }
  MW.GreedyCount = m8;

  class DQ extends dJ {
    constructor(J, $ = 0, H) {
      if (!(J instanceof g0))
        throw new TypeError("layout must be a Layout");
      if (!Number.isInteger($))
        throw new TypeError("offset must be integer or undefined");
      super(J.span, H || J.property);
      this.layout = J, this.offset = $;
    }
    isCount() {
      return this.layout instanceof oJ || this.layout instanceof Z$;
    }
    decode(J, $ = 0) {
      return this.layout.decode(J, $ + this.offset);
    }
    encode(J, $, H = 0) {
      return this.layout.encode(J, $, H + this.offset);
    }
  }
  MW.OffsetLayout = DQ;

  class oJ extends g0 {
    constructor(J, $) {
      super(J, $);
      if (6 < this.span)
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(J, $ = 0) {
      return w0(J).readUIntLE($, this.span);
    }
    encode(J, $, H = 0) {
      return w0($).writeUIntLE(J, H, this.span), this.span;
    }
  }
  MW.UInt = oJ;

  class Z$ extends g0 {
    constructor(J, $) {
      super(J, $);
      if (6 < this.span)
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(J, $ = 0) {
      return w0(J).readUIntBE($, this.span);
    }
    encode(J, $, H = 0) {
      return w0($).writeUIntBE(J, H, this.span), this.span;
    }
  }
  MW.UIntBE = Z$;

  class T$ extends g0 {
    constructor(J, $) {
      super(J, $);
      if (6 < this.span)
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(J, $ = 0) {
      return w0(J).readIntLE($, this.span);
    }
    encode(J, $, H = 0) {
      return w0($).writeIntLE(J, H, this.span), this.span;
    }
  }
  MW.Int = T$;

  class o$ extends g0 {
    constructor(J, $) {
      super(J, $);
      if (6 < this.span)
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(J, $ = 0) {
      return w0(J).readIntBE($, this.span);
    }
    encode(J, $, H = 0) {
      return w0($).writeIntBE(J, H, this.span), this.span;
    }
  }
  MW.IntBE = o$;
  var f8 = Math.pow(2, 32);

  class d8 extends g0 {
    constructor(J) {
      super(8, J);
    }
    decode(J, $ = 0) {
      const H = w0(J), Q = H.readUInt32LE($), W = H.readUInt32LE($ + 4);
      return vQ(W, Q);
    }
    encode(J, $, H = 0) {
      const Q = qQ(J), W = w0($);
      return W.writeUInt32LE(Q.lo32, H), W.writeUInt32LE(Q.hi32, H + 4), 8;
    }
  }
  MW.NearUInt64 = d8;

  class p8 extends g0 {
    constructor(J) {
      super(8, J);
    }
    decode(J, $ = 0) {
      const H = w0(J), Q = H.readUInt32BE($), W = H.readUInt32BE($ + 4);
      return vQ(Q, W);
    }
    encode(J, $, H = 0) {
      const Q = qQ(J), W = w0($);
      return W.writeUInt32BE(Q.hi32, H), W.writeUInt32BE(Q.lo32, H + 4), 8;
    }
  }
  MW.NearUInt64BE = p8;

  class l8 extends g0 {
    constructor(J) {
      super(8, J);
    }
    decode(J, $ = 0) {
      const H = w0(J), Q = H.readUInt32LE($), W = H.readInt32LE($ + 4);
      return vQ(W, Q);
    }
    encode(J, $, H = 0) {
      const Q = qQ(J), W = w0($);
      return W.writeUInt32LE(Q.lo32, H), W.writeInt32LE(Q.hi32, H + 4), 8;
    }
  }
  MW.NearInt64 = l8;

  class u8 extends g0 {
    constructor(J) {
      super(8, J);
    }
    decode(J, $ = 0) {
      const H = w0(J), Q = H.readInt32BE($), W = H.readUInt32BE($ + 4);
      return vQ(Q, W);
    }
    encode(J, $, H = 0) {
      const Q = qQ(J), W = w0($);
      return W.writeInt32BE(Q.hi32, H), W.writeUInt32BE(Q.lo32, H + 4), 8;
    }
  }
  MW.NearInt64BE = u8;

  class c8 extends g0 {
    constructor(J) {
      super(4, J);
    }
    decode(J, $ = 0) {
      return w0(J).readFloatLE($);
    }
    encode(J, $, H = 0) {
      return w0($).writeFloatLE(J, H), 4;
    }
  }
  MW.Float = c8;

  class s8 extends g0 {
    constructor(J) {
      super(4, J);
    }
    decode(J, $ = 0) {
      return w0(J).readFloatBE($);
    }
    encode(J, $, H = 0) {
      return w0($).writeFloatBE(J, H), 4;
    }
  }
  MW.FloatBE = s8;

  class a8 extends g0 {
    constructor(J) {
      super(8, J);
    }
    decode(J, $ = 0) {
      return w0(J).readDoubleLE($);
    }
    encode(J, $, H = 0) {
      return w0($).writeDoubleLE(J, H), 8;
    }
  }
  MW.Double = a8;

  class i8 extends g0 {
    constructor(J) {
      super(8, J);
    }
    decode(J, $ = 0) {
      return w0(J).readDoubleBE($);
    }
    encode(J, $, H = 0) {
      return w0($).writeDoubleBE(J, H), 8;
    }
  }
  MW.DoubleBE = i8;

  class r8 extends g0 {
    constructor(J, $, H) {
      if (!(J instanceof g0))
        throw new TypeError("elementLayout must be a Layout");
      if (!($ instanceof dJ && $.isCount() || Number.isInteger($) && 0 <= $))
        throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
      let Q = -1;
      if (!($ instanceof dJ) && 0 < J.span)
        Q = $ * J.span;
      super(Q, H);
      this.elementLayout = J, this.count = $;
    }
    getSpan(J, $ = 0) {
      if (0 <= this.span)
        return this.span;
      let H = 0, Q = this.count;
      if (Q instanceof dJ)
        Q = Q.decode(J, $);
      if (0 < this.elementLayout.span)
        H = Q * this.elementLayout.span;
      else {
        let W = 0;
        while (W < Q)
          H += this.elementLayout.getSpan(J, $ + H), ++W;
      }
      return H;
    }
    decode(J, $ = 0) {
      const H = [];
      let Q = 0, W = this.count;
      if (W instanceof dJ)
        W = W.decode(J, $);
      while (Q < W)
        H.push(this.elementLayout.decode(J, $)), $ += this.elementLayout.getSpan(J, $), Q += 1;
      return H;
    }
    encode(J, $, H = 0) {
      const Q = this.elementLayout, W = J.reduce((Z, Y) => {
        return Z + Q.encode(Y, $, H + Z);
      }, 0);
      if (this.count instanceof dJ)
        this.count.encode(J.length, $, H);
      return W;
    }
  }
  MW.Sequence = r8;

  class n8 extends g0 {
    constructor(J, $, H) {
      if (!(Array.isArray(J) && J.reduce((W, Z) => W && Z instanceof g0, true)))
        throw new TypeError("fields must be array of Layout instances");
      if (typeof $ === "boolean" && H === undefined)
        H = $, $ = undefined;
      for (let W of J)
        if (0 > W.span && W.property === undefined)
          throw new Error("fields cannot contain unnamed variable-length layout");
      let Q = -1;
      try {
        Q = J.reduce((W, Z) => W + Z.getSpan(), 0);
      } catch (W) {
      }
      super(Q, $);
      this.fields = J, this.decodePrefixes = !!H;
    }
    getSpan(J, $ = 0) {
      if (0 <= this.span)
        return this.span;
      let H = 0;
      try {
        H = this.fields.reduce((Q, W) => {
          const Z = W.getSpan(J, $);
          return $ += Z, Q + Z;
        }, 0);
      } catch (Q) {
        throw new RangeError("indeterminate span");
      }
      return H;
    }
    decode(J, $ = 0) {
      MH(J);
      const H = this.makeDestinationObject();
      for (let Q of this.fields) {
        if (Q.property !== undefined)
          H[Q.property] = Q.decode(J, $);
        if ($ += Q.getSpan(J, $), this.decodePrefixes && J.length === $)
          break;
      }
      return H;
    }
    encode(J, $, H = 0) {
      const Q = H;
      let W = 0, Z = 0;
      for (let Y of this.fields) {
        let z = Y.span;
        if (Z = 0 < z ? z : 0, Y.property !== undefined) {
          const j = J[Y.property];
          if (j !== undefined) {
            if (Z = Y.encode(j, $, H), 0 > z)
              z = Y.getSpan($, H);
          }
        }
        W = H, H += z;
      }
      return W + Z - Q;
    }
    fromArray(J) {
      const $ = this.makeDestinationObject();
      for (let H of this.fields)
        if (H.property !== undefined && 0 < J.length)
          $[H.property] = J.shift();
      return $;
    }
    layoutFor(J) {
      if (typeof J !== "string")
        throw new TypeError("property must be string");
      for (let $ of this.fields)
        if ($.property === J)
          return $;
      return;
    }
    offsetOf(J) {
      if (typeof J !== "string")
        throw new TypeError("property must be string");
      let $ = 0;
      for (let H of this.fields) {
        if (H.property === J)
          return $;
        if (0 > H.span)
          $ = -1;
        else if (0 <= $)
          $ += H.span;
      }
      return;
    }
  }
  MW.Structure = n8;

  class CQ {
    constructor(J) {
      this.property = J;
    }
    decode(J, $) {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode(J, $, H) {
      throw new Error("UnionDiscriminator is abstract");
    }
  }
  MW.UnionDiscriminator = CQ;

  class pH extends CQ {
    constructor(J, $) {
      if (!(J instanceof dJ && J.isCount()))
        throw new TypeError("layout must be an unsigned integer ExternalLayout");
      super($ || J.property || "variant");
      this.layout = J;
    }
    decode(J, $) {
      return this.layout.decode(J, $);
    }
    encode(J, $, H) {
      return this.layout.encode(J, $, H);
    }
  }
  MW.UnionLayoutDiscriminator = pH;

  class RQ extends g0 {
    constructor(J, $, H) {
      let Q;
      if (J instanceof oJ || J instanceof Z$)
        Q = new pH(new DQ(J));
      else if (J instanceof dJ && J.isCount())
        Q = new pH(J);
      else if (!(J instanceof CQ))
        throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
      else
        Q = J;
      if ($ === undefined)
        $ = null;
      if (!($ === null || $ instanceof g0))
        throw new TypeError("defaultLayout must be null or a Layout");
      if ($ !== null) {
        if (0 > $.span)
          throw new Error("defaultLayout must have constant span");
        if ($.property === undefined)
          $ = $.replicate("content");
      }
      let W = -1;
      if ($) {
        if (W = $.span, 0 <= W && (J instanceof oJ || J instanceof Z$))
          W += Q.layout.span;
      }
      super(W, H);
      this.discriminator = Q, this.usesPrefixDiscriminator = J instanceof oJ || J instanceof Z$, this.defaultLayout = $, this.registry = {};
      let Z = this.defaultGetSourceVariant.bind(this);
      this.getSourceVariant = function(Y) {
        return Z(Y);
      }, this.configGetSourceVariant = function(Y) {
        Z = Y.bind(this);
      };
    }
    getSpan(J, $ = 0) {
      if (0 <= this.span)
        return this.span;
      const H = this.getVariant(J, $);
      if (!H)
        throw new Error("unable to determine span for unrecognized variant");
      return H.getSpan(J, $);
    }
    defaultGetSourceVariant(J) {
      if (Object.prototype.hasOwnProperty.call(J, this.discriminator.property)) {
        if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(J, this.defaultLayout.property))
          return;
        const $ = this.registry[J[this.discriminator.property]];
        if ($ && (!$.layout || $.property && Object.prototype.hasOwnProperty.call(J, $.property)))
          return $;
      } else
        for (let $ in this.registry) {
          const H = this.registry[$];
          if (H.property && Object.prototype.hasOwnProperty.call(J, H.property))
            return H;
        }
      throw new Error("unable to infer src variant");
    }
    decode(J, $ = 0) {
      let H;
      const Q = this.discriminator, W = Q.decode(J, $), Z = this.registry[W];
      if (Z === undefined) {
        const Y = this.defaultLayout;
        let z = 0;
        if (this.usesPrefixDiscriminator)
          z = Q.layout.span;
        H = this.makeDestinationObject(), H[Q.property] = W, H[Y.property] = Y.decode(J, $ + z);
      } else
        H = Z.decode(J, $);
      return H;
    }
    encode(J, $, H = 0) {
      const Q = this.getSourceVariant(J);
      if (Q === undefined) {
        const W = this.discriminator, Z = this.defaultLayout;
        let Y = 0;
        if (this.usesPrefixDiscriminator)
          Y = W.layout.span;
        return W.encode(J[W.property], $, H), Y + Z.encode(J[Z.property], $, H + Y);
      }
      return Q.encode(J, $, H);
    }
    addVariant(J, $, H) {
      const Q = new e8(this, J, $, H);
      return this.registry[J] = Q, Q;
    }
    getVariant(J, $ = 0) {
      let H;
      if (J instanceof Uint8Array)
        H = this.discriminator.decode(J, $);
      else
        H = J;
      return this.registry[H];
    }
  }
  MW.Union = RQ;

  class e8 extends g0 {
    constructor(J, $, H, Q) {
      if (!(J instanceof RQ))
        throw new TypeError("union must be a Union");
      if (!Number.isInteger($) || 0 > $)
        throw new TypeError("variant must be a (non-negative) integer");
      if (typeof H === "string" && Q === undefined)
        Q = H, H = null;
      if (H) {
        if (!(H instanceof g0))
          throw new TypeError("layout must be a Layout");
        if (J.defaultLayout !== null && 0 <= H.span && H.span > J.defaultLayout.span)
          throw new Error("variant span exceeds span of containing union");
        if (typeof Q !== "string")
          throw new TypeError("variant must have a String property");
      }
      let W = J.span;
      if (0 > J.span) {
        if (W = H ? H.span : 0, 0 <= W && J.usesPrefixDiscriminator)
          W += J.discriminator.layout.span;
      }
      super(W, Q);
      this.union = J, this.variant = $, this.layout = H || null;
    }
    getSpan(J, $ = 0) {
      if (0 <= this.span)
        return this.span;
      let H = 0;
      if (this.union.usesPrefixDiscriminator)
        H = this.union.discriminator.layout.span;
      let Q = 0;
      if (this.layout)
        Q = this.layout.getSpan(J, $ + H);
      return H + Q;
    }
    decode(J, $ = 0) {
      const H = this.makeDestinationObject();
      if (this !== this.union.getVariant(J, $))
        throw new Error("variant mismatch");
      let Q = 0;
      if (this.union.usesPrefixDiscriminator)
        Q = this.union.discriminator.layout.span;
      if (this.layout)
        H[this.property] = this.layout.decode(J, $ + Q);
      else if (this.property)
        H[this.property] = true;
      else if (this.union.usesPrefixDiscriminator)
        H[this.union.discriminator.property] = this.variant;
      return H;
    }
    encode(J, $, H = 0) {
      let Q = 0;
      if (this.union.usesPrefixDiscriminator)
        Q = this.union.discriminator.layout.span;
      if (this.layout && !Object.prototype.hasOwnProperty.call(J, this.property))
        throw new TypeError("variant lacks property " + this.property);
      this.union.discriminator.encode(this.variant, $, H);
      let W = Q;
      if (this.layout) {
        if (this.layout.encode(J[this.property], $, H + Q), W += this.layout.getSpan($, H + Q), 0 <= this.union.span && W > this.union.span)
          throw new Error("encoded variant overruns containing union");
      }
      return W;
    }
    fromArray(J) {
      if (this.layout)
        return this.layout.fromArray(J);
      return;
    }
  }
  MW.VariantLayout = e8;

  class BQ extends g0 {
    constructor(J, $, H) {
      if (!(J instanceof oJ || J instanceof Z$))
        throw new TypeError("word must be a UInt or UIntBE layout");
      if (typeof $ === "string" && H === undefined)
        H = $, $ = false;
      if (4 < J.span)
        throw new RangeError("word cannot exceed 32 bits");
      super(J.span, H);
      this.word = J, this.msb = !!$, this.fields = [];
      let Q = 0;
      this._packedSetValue = function(W) {
        return Q = BH(W), this;
      }, this._packedGetValue = function() {
        return Q;
      };
    }
    decode(J, $ = 0) {
      const H = this.makeDestinationObject(), Q = this.word.decode(J, $);
      this._packedSetValue(Q);
      for (let W of this.fields)
        if (W.property !== undefined)
          H[W.property] = W.decode(J);
      return H;
    }
    encode(J, $, H = 0) {
      const Q = this.word.decode($, H);
      this._packedSetValue(Q);
      for (let W of this.fields)
        if (W.property !== undefined) {
          const Z = J[W.property];
          if (Z !== undefined)
            W.encode(Z);
        }
      return this.word.encode(this._packedGetValue(), $, H);
    }
    addField(J, $) {
      const H = new MQ(this, J, $);
      return this.fields.push(H), H;
    }
    addBoolean(J) {
      const $ = new t8(this, J);
      return this.fields.push($), $;
    }
    fieldFor(J) {
      if (typeof J !== "string")
        throw new TypeError("property must be string");
      for (let $ of this.fields)
        if ($.property === J)
          return $;
      return;
    }
  }
  MW.BitStructure = BQ;

  class MQ {
    constructor(J, $, H) {
      if (!(J instanceof BQ))
        throw new TypeError("container must be a BitStructure");
      if (!Number.isInteger($) || 0 >= $)
        throw new TypeError("bits must be positive integer");
      const Q = 8 * J.span, W = J.fields.reduce((Z, Y) => Z + Y.bits, 0);
      if ($ + W > Q)
        throw new Error("bits too long for span remainder (" + (Q - W) + " of " + Q + " remain)");
      if (this.container = J, this.bits = $, this.valueMask = (1 << $) - 1, $ === 32)
        this.valueMask = 4294967295;
      if (this.start = W, this.container.msb)
        this.start = Q - W - $;
      this.wordMask = BH(this.valueMask << this.start), this.property = H;
    }
    decode(J, $) {
      const H = this.container._packedGetValue();
      return BH(H & this.wordMask) >>> this.start;
    }
    encode(J) {
      if (typeof J !== "number" || !Number.isInteger(J) || J !== BH(J & this.valueMask))
        throw new TypeError(I8("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
      const $ = this.container._packedGetValue(), H = BH(J << this.start);
      this.container._packedSetValue(BH($ & ~this.wordMask) | H);
    }
  }
  MW.BitField = MQ;

  class t8 extends MQ {
    constructor(J, $) {
      super(J, 1, $);
    }
    decode(J, $) {
      return !!super.decode(J, $);
    }
    encode(J) {
      if (typeof J === "boolean")
        J = +J;
      super.encode(J);
    }
  }
  MW.Boolean = t8;

  class o8 extends g0 {
    constructor(J, $) {
      if (!(J instanceof dJ && J.isCount() || Number.isInteger(J) && 0 <= J))
        throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
      let H = -1;
      if (!(J instanceof dJ))
        H = J;
      super(H, $);
      this.length = J;
    }
    getSpan(J, $) {
      let H = this.span;
      if (0 > H)
        H = this.length.decode(J, $);
      return H;
    }
    decode(J, $ = 0) {
      let H = this.span;
      if (0 > H)
        H = this.length.decode(J, $);
      return w0(J).slice($, $ + H);
    }
    encode(J, $, H) {
      let Q = this.length;
      if (this.length instanceof dJ)
        Q = J.length;
      if (!(J instanceof Uint8Array && Q === J.length))
        throw new TypeError(I8("Blob.encode", this) + " requires (length " + Q + ") Uint8Array as src");
      if (H + Q > $.length)
        throw new RangeError("encoding overruns Uint8Array");
      const W = w0(J);
      if (w0($).write(W.toString("hex"), H, Q, "hex"), this.length instanceof dJ)
        this.length.encode(Q, $, H);
      return Q;
    }
  }
  MW.Blob = o8;

  class J6 extends g0 {
    constructor(J) {
      super(-1, J);
    }
    getSpan(J, $ = 0) {
      MH(J);
      let H = $;
      while (H < J.length && J[H] !== 0)
        H += 1;
      return 1 + H - $;
    }
    decode(J, $ = 0) {
      const H = this.getSpan(J, $);
      return w0(J).slice($, $ + H - 1).toString("utf-8");
    }
    encode(J, $, H = 0) {
      if (typeof J !== "string")
        J = String(J);
      const Q = y8.Buffer.from(J, "utf8"), W = Q.length;
      if (H + W > $.length)
        throw new RangeError("encoding overruns Buffer");
      const Z = w0($);
      return Q.copy(Z, H), Z[H + W] = 0, W + 1;
    }
  }
  MW.CString = J6;

  class $6 extends g0 {
    constructor(J, $) {
      if (typeof J === "string" && $ === undefined)
        $ = J, J = undefined;
      if (J === undefined)
        J = -1;
      else if (!Number.isInteger(J))
        throw new TypeError("maxSpan must be an integer");
      super(-1, $);
      this.maxSpan = J;
    }
    getSpan(J, $ = 0) {
      return MH(J), J.length - $;
    }
    decode(J, $ = 0) {
      const H = this.getSpan(J, $);
      if (0 <= this.maxSpan && this.maxSpan < H)
        throw new RangeError("text length exceeds maxSpan");
      return w0(J).slice($, $ + H).toString("utf-8");
    }
    encode(J, $, H = 0) {
      if (typeof J !== "string")
        J = String(J);
      const Q = y8.Buffer.from(J, "utf8"), W = Q.length;
      if (0 <= this.maxSpan && this.maxSpan < W)
        throw new RangeError("text length exceeds maxSpan");
      if (H + W > $.length)
        throw new RangeError("encoding overruns Buffer");
      return Q.copy(w0($), H), W;
    }
  }
  MW.UTF8 = $6;

  class H6 extends g0 {
    constructor(J, $) {
      super(0, $);
      this.value = J;
    }
    decode(J, $) {
      return this.value;
    }
    encode(J, $, H) {
      return 0;
    }
  }
  MW.Constant = H6;
  MW.greedy = (J, $) => new m8(J, $);
  MW.offset = (J, $, H) => new DQ(J, $, H);
  MW.u8 = (J) => new oJ(1, J);
  MW.u16 = (J) => new oJ(2, J);
  MW.u24 = (J) => new oJ(3, J);
  MW.u32 = (J) => new oJ(4, J);
  MW.u40 = (J) => new oJ(5, J);
  MW.u48 = (J) => new oJ(6, J);
  MW.nu64 = (J) => new d8(J);
  MW.u16be = (J) => new Z$(2, J);
  MW.u24be = (J) => new Z$(3, J);
  MW.u32be = (J) => new Z$(4, J);
  MW.u40be = (J) => new Z$(5, J);
  MW.u48be = (J) => new Z$(6, J);
  MW.nu64be = (J) => new p8(J);
  MW.s8 = (J) => new T$(1, J);
  MW.s16 = (J) => new T$(2, J);
  MW.s24 = (J) => new T$(3, J);
  MW.s32 = (J) => new T$(4, J);
  MW.s40 = (J) => new T$(5, J);
  MW.s48 = (J) => new T$(6, J);
  MW.ns64 = (J) => new l8(J);
  MW.s16be = (J) => new o$(2, J);
  MW.s24be = (J) => new o$(3, J);
  MW.s32be = (J) => new o$(4, J);
  MW.s40be = (J) => new o$(5, J);
  MW.s48be = (J) => new o$(6, J);
  MW.ns64be = (J) => new u8(J);
  MW.f32 = (J) => new c8(J);
  MW.f32be = (J) => new s8(J);
  MW.f64 = (J) => new a8(J);
  MW.f64be = (J) => new i8(J);
  MW.struct = (J, $, H) => new n8(J, $, H);
  MW.bits = (J, $, H) => new BQ(J, $, H);
  MW.seq = (J, $, H) => new r8(J, $, H);
  MW.union = (J, $, H) => new RQ(J, $, H);
  MW.unionLayoutDiscriminator = (J, $) => new pH(J, $);
  MW.blob = (J, $) => new o8(J, $);
  MW.cstr = (J) => new J6(J);
  MW.utf8 = (J, $) => new $6(J, $);
  MW.constant = (J, $) => new H6(J, $);
});
var hW = t$((yj, KW) => {
  var K4 = function(J) {
    if (typeof J != "string" || J.length <= 7 || J.substring(0, 7) != "file://")
      throw new TypeError("must pass in a file:// URI to convert to a file path");
    var $ = decodeURI(J.substring(7)), H = $.indexOf("/"), Q = $.substring(0, H), W = $.substring(H + 1);
    if (Q == "localhost")
      Q = "";
    if (Q)
      Q = OQ + OQ + Q;
    if (W = W.replace(/^(.+)\|/, "$1:"), OQ == "\\")
      W = W.replace(/\//g, "\\");
    if (/^.+\:/.test(W))
      ;
    else
      W = OQ + W;
    return Q + W;
  }, OQ = mH("path").sep || "/";
  KW.exports = K4;
});
var bW = t$((hQ, wW) => {
  var S4 = function(J) {
    if (typeof J == "string")
      J = { bindings: J };
    else if (!J)
      J = {};
    if (Object.keys(SW).map(function(j) {
      if (!(j in J))
        J[j] = SW[j];
    }), !J.module_root)
      J.module_root = hQ.getRoot(hQ.getFileName());
    if (KQ.extname(J.bindings) != ".node")
      J.bindings += ".node";
    var $ = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require, H = [], Q = 0, W = J.try.length, Z, Y, z;
    for (;Q < W; Q++) {
      Z = LQ.apply(null, J.try[Q].map(function(j) {
        return J[j] || j;
      })), H.push(Z);
      try {
        if (Y = J.path ? $.resolve(Z) : $(Z), !J.path)
          Y.path = Z;
        return Y;
      } catch (j) {
        if (j.code !== "MODULE_NOT_FOUND" && j.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(j.message))
          throw j;
      }
    }
    throw z = new Error("Could not locate the bindings file. Tried:\n" + H.map(function(j) {
      return J.arrow + j;
    }).join("\n")), z.tries = H, z;
  }, __filename2 = "/Users/ppegu/Projects/salona/node_modules/bindings/bindings.js", Q6 = mH("fs"), KQ = mH("path"), h4 = hW(), LQ = KQ.join, E4 = KQ.dirname, EW = Q6.accessSync && function(J) {
    try {
      Q6.accessSync(J);
    } catch ($) {
      return false;
    }
    return true;
  } || Q6.existsSync || KQ.existsSync, SW = { arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ", compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled", platform: process.platform, arch: process.arch, nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch, version: process.versions.node, bindings: "bindings.node", try: [["module_root", "build", "bindings"], ["module_root", "build", "Debug", "bindings"], ["module_root", "build", "Release", "bindings"], ["module_root", "out", "Debug", "bindings"], ["module_root", "Debug", "bindings"], ["module_root", "out", "Release", "bindings"], ["module_root", "Release", "bindings"], ["module_root", "build", "default", "bindings"], ["module_root", "compiled", "version", "platform", "arch", "bindings"], ["module_root", "addon-build", "release", "install-root", "bindings"], ["module_root", "addon-build", "debug", "install-root", "bindings"], ["module_root", "addon-build", "default", "install-root", "bindings"], ["module_root", "lib", "binding", "nodePreGyp", "bindings"]] };
  wW.exports = hQ = S4;
  hQ.getFileName = function J($) {
    var { prepareStackTrace: H, stackTraceLimit: Q } = Error, W = {}, Z;
    Error.stackTraceLimit = 10, Error.prepareStackTrace = function(z, j) {
      for (var V = 0, U = j.length;V < U; V++)
        if (Z = j[V].getFileName(), Z !== __filename2)
          if ($) {
            if (Z !== $)
              return;
          } else
            return;
    }, Error.captureStackTrace(W), W.stack, Error.prepareStackTrace = H, Error.stackTraceLimit = Q;
    var Y = "file://";
    if (Z.indexOf(Y) === 0)
      Z = h4(Z);
    return Z;
  };
  hQ.getRoot = function J($) {
    var H = E4($), Q;
    while (true) {
      if (H === ".")
        H = process.cwd();
      if (EW(LQ(H, "package.json")) || EW(LQ(H, "node_modules")))
        return H;
      if (Q === H)
        throw new Error('Could not find module root given file: "' + $ + '". Do you have a `package.json` file? ');
      Q = H, H = LQ(H, "..");
    }
  };
});
var PW = t$((_W) => {
  var w4 = function(J) {
    if (w$ === undefined) {
      const $ = Buffer.from(J);
      $.reverse();
      const H = $.toString("hex");
      if (H.length === 0)
        return BigInt(0);
      return BigInt(`0x${H}`);
    }
    return w$.toBigInt(J, false);
  }, b4 = function(J) {
    if (w$ === undefined) {
      const $ = J.toString("hex");
      if ($.length === 0)
        return BigInt(0);
      return BigInt(`0x${$}`);
    }
    return w$.toBigInt(J, true);
  }, _4 = function(J, $) {
    if (w$ === undefined) {
      const H = J.toString(16), Q = Buffer.from(H.padStart($ * 2, "0").slice(0, $ * 2), "hex");
      return Q.reverse(), Q;
    }
    return w$.fromBigInt(J, Buffer.allocUnsafe($), false);
  }, P4 = function(J, $) {
    if (w$ === undefined) {
      const H = J.toString(16);
      return Buffer.from(H.padStart($ * 2, "0").slice(0, $ * 2), "hex");
    }
    return w$.fromBigInt(J, Buffer.allocUnsafe($), true);
  };
  Object.defineProperty(_W, "__esModule", { value: true });
  var w$;
  try {
    w$ = bW()("bigint_buffer");
  } catch (J) {
    console.warn("bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)");
  }
  _W.toBigIntLE = w4;
  _W.toBigIntBE = b4;
  _W.toBufferLE = _4;
  _W.toBufferBE = P4;
});
var EJ = t$((zZ, U6) => {
  (function(J, $) {
    function H(_, G) {
      if (!_)
        throw new Error(G || "Assertion failed");
    }
    function Q(_, G) {
      _.super_ = G;
      var v = function() {
      };
      v.prototype = G.prototype, _.prototype = new v, _.prototype.constructor = _;
    }
    function W(_, G, v) {
      if (W.isBN(_))
        return _;
      if (this.negative = 0, this.words = null, this.length = 0, this.red = null, _ !== null) {
        if (G === "le" || G === "be")
          v = G, G = 10;
        this._init(_ || 0, G || 10, v || "be");
      }
    }
    if (typeof J === "object")
      J.exports = W;
    else
      $.BN = W;
    W.BN = W, W.wordSize = 26;
    var Z;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
        Z = window.Buffer;
      else
        Z = mH("buffer").Buffer;
    } catch (_) {
    }
    W.isBN = function _(G) {
      if (G instanceof W)
        return true;
      return G !== null && typeof G === "object" && G.constructor.wordSize === W.wordSize && Array.isArray(G.words);
    }, W.max = function _(G, v) {
      if (G.cmp(v) > 0)
        return G;
      return v;
    }, W.min = function _(G, v) {
      if (G.cmp(v) < 0)
        return G;
      return v;
    }, W.prototype._init = function _(G, v, X) {
      if (typeof G === "number")
        return this._initNumber(G, v, X);
      if (typeof G === "object")
        return this._initArray(G, v, X);
      if (v === "hex")
        v = 16;
      H(v === (v | 0) && v >= 2 && v <= 36), G = G.toString().replace(/\s+/g, "");
      var D = 0;
      if (G[0] === "-")
        D++, this.negative = 1;
      if (D < G.length) {
        if (v === 16)
          this._parseHex(G, D, X);
        else if (this._parseBase(G, v, D), X === "le")
          this._initArray(this.toArray(), v, X);
      }
    }, W.prototype._initNumber = function _(G, v, X) {
      if (G < 0)
        this.negative = 1, G = -G;
      if (G < 67108864)
        this.words = [G & 67108863], this.length = 1;
      else if (G < 4503599627370496)
        this.words = [G & 67108863, G / 67108864 & 67108863], this.length = 2;
      else
        H(G < 9007199254740992), this.words = [G & 67108863, G / 67108864 & 67108863, 1], this.length = 3;
      if (X !== "le")
        return;
      this._initArray(this.toArray(), v, X);
    }, W.prototype._initArray = function _(G, v, X) {
      if (H(typeof G.length === "number"), G.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(G.length / 3), this.words = new Array(this.length);
      for (var D = 0;D < this.length; D++)
        this.words[D] = 0;
      var M, L, S = 0;
      if (X === "be") {
        for (D = G.length - 1, M = 0;D >= 0; D -= 3)
          if (L = G[D] | G[D - 1] << 8 | G[D - 2] << 16, this.words[M] |= L << S & 67108863, this.words[M + 1] = L >>> 26 - S & 67108863, S += 24, S >= 26)
            S -= 26, M++;
      } else if (X === "le") {
        for (D = 0, M = 0;D < G.length; D += 3)
          if (L = G[D] | G[D + 1] << 8 | G[D + 2] << 16, this.words[M] |= L << S & 67108863, this.words[M + 1] = L >>> 26 - S & 67108863, S += 24, S >= 26)
            S -= 26, M++;
      }
      return this._strip();
    };
    function Y(_, G) {
      var v = _.charCodeAt(G);
      if (v >= 48 && v <= 57)
        return v - 48;
      else if (v >= 65 && v <= 70)
        return v - 55;
      else if (v >= 97 && v <= 102)
        return v - 87;
      else
        H(false, "Invalid character in " + _);
    }
    function z(_, G, v) {
      var X = Y(_, v);
      if (v - 1 >= G)
        X |= Y(_, v - 1) << 4;
      return X;
    }
    W.prototype._parseHex = function _(G, v, X) {
      this.length = Math.ceil((G.length - v) / 6), this.words = new Array(this.length);
      for (var D = 0;D < this.length; D++)
        this.words[D] = 0;
      var M = 0, L = 0, S;
      if (X === "be")
        for (D = G.length - 1;D >= v; D -= 2)
          if (S = z(G, v, D) << M, this.words[L] |= S & 67108863, M >= 18)
            M -= 18, L += 1, this.words[L] |= S >>> 26;
          else
            M += 8;
      else {
        var R = G.length - v;
        for (D = R % 2 === 0 ? v + 1 : v;D < G.length; D += 2)
          if (S = z(G, v, D) << M, this.words[L] |= S & 67108863, M >= 18)
            M -= 18, L += 1, this.words[L] |= S >>> 26;
          else
            M += 8;
      }
      this._strip();
    };
    function j(_, G, v, X) {
      var D = 0, M = 0, L = Math.min(_.length, v);
      for (var S = G;S < L; S++) {
        var R = _.charCodeAt(S) - 48;
        if (D *= X, R >= 49)
          M = R - 49 + 10;
        else if (R >= 17)
          M = R - 17 + 10;
        else
          M = R;
        H(R >= 0 && M < X, "Invalid character"), D += M;
      }
      return D;
    }
    W.prototype._parseBase = function _(G, v, X) {
      this.words = [0], this.length = 1;
      for (var D = 0, M = 1;M <= 67108863; M *= v)
        D++;
      D--, M = M / v | 0;
      var L = G.length - X, S = L % D, R = Math.min(L, L - S) + X, F = 0;
      for (var E = X;E < R; E += D)
        if (F = j(G, E, E + D, v), this.imuln(M), this.words[0] + F < 67108864)
          this.words[0] += F;
        else
          this._iaddn(F);
      if (S !== 0) {
        var f = 1;
        F = j(G, E, G.length, v);
        for (E = 0;E < S; E++)
          f *= v;
        if (this.imuln(f), this.words[0] + F < 67108864)
          this.words[0] += F;
        else
          this._iaddn(F);
      }
      this._strip();
    }, W.prototype.copy = function _(G) {
      G.words = new Array(this.length);
      for (var v = 0;v < this.length; v++)
        G.words[v] = this.words[v];
      G.length = this.length, G.negative = this.negative, G.red = this.red;
    };
    function V(_, G) {
      _.words = G.words, _.length = G.length, _.negative = G.negative, _.red = G.red;
    }
    if (W.prototype._move = function _(G) {
      V(G, this);
    }, W.prototype.clone = function _() {
      var G = new W(null);
      return this.copy(G), G;
    }, W.prototype._expand = function _(G) {
      while (this.length < G)
        this.words[this.length++] = 0;
      return this;
    }, W.prototype._strip = function _() {
      while (this.length > 1 && this.words[this.length - 1] === 0)
        this.length--;
      return this._normSign();
    }, W.prototype._normSign = function _() {
      if (this.length === 1 && this.words[0] === 0)
        this.negative = 0;
      return this;
    }, typeof Symbol !== "undefined" && typeof Symbol.for === "function")
      try {
        W.prototype[Symbol.for("nodejs.util.inspect.custom")] = U;
      } catch (_) {
        W.prototype.inspect = U;
      }
    else
      W.prototype.inspect = U;
    function U() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var C = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], q = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], K = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    if (W.prototype.toString = function _(G, v) {
      G = G || 10, v = v | 0 || 1;
      var X;
      if (G === 16 || G === "hex") {
        X = "";
        var D = 0, M = 0;
        for (var L = 0;L < this.length; L++) {
          var S = this.words[L], R = ((S << D | M) & 16777215).toString(16);
          if (M = S >>> 24 - D & 16777215, D += 2, D >= 26)
            D -= 26, L--;
          if (M !== 0 || L !== this.length - 1)
            X = C[6 - R.length] + R + X;
          else
            X = R + X;
        }
        if (M !== 0)
          X = M.toString(16) + X;
        while (X.length % v !== 0)
          X = "0" + X;
        if (this.negative !== 0)
          X = "-" + X;
        return X;
      }
      if (G === (G | 0) && G >= 2 && G <= 36) {
        var F = q[G], E = K[G];
        X = "";
        var f = this.clone();
        f.negative = 0;
        while (!f.isZero()) {
          var l = f.modrn(E).toString(G);
          if (f = f.idivn(E), !f.isZero())
            X = C[F - l.length] + l + X;
          else
            X = l + X;
        }
        if (this.isZero())
          X = "0" + X;
        while (X.length % v !== 0)
          X = "0" + X;
        if (this.negative !== 0)
          X = "-" + X;
        return X;
      }
      H(false, "Base should be between 2 and 36");
    }, W.prototype.toNumber = function _() {
      var G = this.words[0];
      if (this.length === 2)
        G += this.words[1] * 67108864;
      else if (this.length === 3 && this.words[2] === 1)
        G += 4503599627370496 + this.words[1] * 67108864;
      else if (this.length > 2)
        H(false, "Number can only safely store up to 53 bits");
      return this.negative !== 0 ? -G : G;
    }, W.prototype.toJSON = function _() {
      return this.toString(16, 2);
    }, Z)
      W.prototype.toBuffer = function _(G, v) {
        return this.toArrayLike(Z, G, v);
      };
    W.prototype.toArray = function _(G, v) {
      return this.toArrayLike(Array, G, v);
    };
    var w2 = function _(G, v) {
      if (G.allocUnsafe)
        return G.allocUnsafe(v);
      return new G(v);
    };
    if (W.prototype.toArrayLike = function _(G, v, X) {
      this._strip();
      var D = this.byteLength(), M = X || Math.max(1, D);
      H(D <= M, "byte array longer than desired length"), H(M > 0, "Requested array length <= 0");
      var L = w2(G, M), S = v === "le" ? "LE" : "BE";
      return this["_toArrayLike" + S](L, D), L;
    }, W.prototype._toArrayLikeLE = function _(G, v) {
      var X = 0, D = 0;
      for (var M = 0, L = 0;M < this.length; M++) {
        var S = this.words[M] << L | D;
        if (G[X++] = S & 255, X < G.length)
          G[X++] = S >> 8 & 255;
        if (X < G.length)
          G[X++] = S >> 16 & 255;
        if (L === 6) {
          if (X < G.length)
            G[X++] = S >> 24 & 255;
          D = 0, L = 0;
        } else
          D = S >>> 24, L += 2;
      }
      if (X < G.length) {
        G[X++] = D;
        while (X < G.length)
          G[X++] = 0;
      }
    }, W.prototype._toArrayLikeBE = function _(G, v) {
      var X = G.length - 1, D = 0;
      for (var M = 0, L = 0;M < this.length; M++) {
        var S = this.words[M] << L | D;
        if (G[X--] = S & 255, X >= 0)
          G[X--] = S >> 8 & 255;
        if (X >= 0)
          G[X--] = S >> 16 & 255;
        if (L === 6) {
          if (X >= 0)
            G[X--] = S >> 24 & 255;
          D = 0, L = 0;
        } else
          D = S >>> 24, L += 2;
      }
      if (X >= 0) {
        G[X--] = D;
        while (X >= 0)
          G[X--] = 0;
      }
    }, Math.clz32)
      W.prototype._countBits = function _(G) {
        return 32 - Math.clz32(G);
      };
    else
      W.prototype._countBits = function _(G) {
        var v = G, X = 0;
        if (v >= 4096)
          X += 13, v >>>= 13;
        if (v >= 64)
          X += 7, v >>>= 7;
        if (v >= 8)
          X += 4, v >>>= 4;
        if (v >= 2)
          X += 2, v >>>= 2;
        return X + v;
      };
    W.prototype._zeroBits = function _(G) {
      if (G === 0)
        return 26;
      var v = G, X = 0;
      if ((v & 8191) === 0)
        X += 13, v >>>= 13;
      if ((v & 127) === 0)
        X += 7, v >>>= 7;
      if ((v & 15) === 0)
        X += 4, v >>>= 4;
      if ((v & 3) === 0)
        X += 2, v >>>= 2;
      if ((v & 1) === 0)
        X++;
      return X;
    }, W.prototype.bitLength = function _() {
      var G = this.words[this.length - 1], v = this._countBits(G);
      return (this.length - 1) * 26 + v;
    };
    function O(_) {
      var G = new Array(_.bitLength());
      for (var v = 0;v < G.length; v++) {
        var X = v / 26 | 0, D = v % 26;
        G[v] = _.words[X] >>> D & 1;
      }
      return G;
    }
    W.prototype.zeroBits = function _() {
      if (this.isZero())
        return 0;
      var G = 0;
      for (var v = 0;v < this.length; v++) {
        var X = this._zeroBits(this.words[v]);
        if (G += X, X !== 26)
          break;
      }
      return G;
    }, W.prototype.byteLength = function _() {
      return Math.ceil(this.bitLength() / 8);
    }, W.prototype.toTwos = function _(G) {
      if (this.negative !== 0)
        return this.abs().inotn(G).iaddn(1);
      return this.clone();
    }, W.prototype.fromTwos = function _(G) {
      if (this.testn(G - 1))
        return this.notn(G).iaddn(1).ineg();
      return this.clone();
    }, W.prototype.isNeg = function _() {
      return this.negative !== 0;
    }, W.prototype.neg = function _() {
      return this.clone().ineg();
    }, W.prototype.ineg = function _() {
      if (!this.isZero())
        this.negative ^= 1;
      return this;
    }, W.prototype.iuor = function _(G) {
      while (this.length < G.length)
        this.words[this.length++] = 0;
      for (var v = 0;v < G.length; v++)
        this.words[v] = this.words[v] | G.words[v];
      return this._strip();
    }, W.prototype.ior = function _(G) {
      return H((this.negative | G.negative) === 0), this.iuor(G);
    }, W.prototype.or = function _(G) {
      if (this.length > G.length)
        return this.clone().ior(G);
      return G.clone().ior(this);
    }, W.prototype.uor = function _(G) {
      if (this.length > G.length)
        return this.clone().iuor(G);
      return G.clone().iuor(this);
    }, W.prototype.iuand = function _(G) {
      var v;
      if (this.length > G.length)
        v = G;
      else
        v = this;
      for (var X = 0;X < v.length; X++)
        this.words[X] = this.words[X] & G.words[X];
      return this.length = v.length, this._strip();
    }, W.prototype.iand = function _(G) {
      return H((this.negative | G.negative) === 0), this.iuand(G);
    }, W.prototype.and = function _(G) {
      if (this.length > G.length)
        return this.clone().iand(G);
      return G.clone().iand(this);
    }, W.prototype.uand = function _(G) {
      if (this.length > G.length)
        return this.clone().iuand(G);
      return G.clone().iuand(this);
    }, W.prototype.iuxor = function _(G) {
      var v, X;
      if (this.length > G.length)
        v = this, X = G;
      else
        v = G, X = this;
      for (var D = 0;D < X.length; D++)
        this.words[D] = v.words[D] ^ X.words[D];
      if (this !== v)
        for (;D < v.length; D++)
          this.words[D] = v.words[D];
      return this.length = v.length, this._strip();
    }, W.prototype.ixor = function _(G) {
      return H((this.negative | G.negative) === 0), this.iuxor(G);
    }, W.prototype.xor = function _(G) {
      if (this.length > G.length)
        return this.clone().ixor(G);
      return G.clone().ixor(this);
    }, W.prototype.uxor = function _(G) {
      if (this.length > G.length)
        return this.clone().iuxor(G);
      return G.clone().iuxor(this);
    }, W.prototype.inotn = function _(G) {
      H(typeof G === "number" && G >= 0);
      var v = Math.ceil(G / 26) | 0, X = G % 26;
      if (this._expand(v), X > 0)
        v--;
      for (var D = 0;D < v; D++)
        this.words[D] = ~this.words[D] & 67108863;
      if (X > 0)
        this.words[D] = ~this.words[D] & 67108863 >> 26 - X;
      return this._strip();
    }, W.prototype.notn = function _(G) {
      return this.clone().inotn(G);
    }, W.prototype.setn = function _(G, v) {
      H(typeof G === "number" && G >= 0);
      var X = G / 26 | 0, D = G % 26;
      if (this._expand(X + 1), v)
        this.words[X] = this.words[X] | 1 << D;
      else
        this.words[X] = this.words[X] & ~(1 << D);
      return this._strip();
    }, W.prototype.iadd = function _(G) {
      var v;
      if (this.negative !== 0 && G.negative === 0)
        return this.negative = 0, v = this.isub(G), this.negative ^= 1, this._normSign();
      else if (this.negative === 0 && G.negative !== 0)
        return G.negative = 0, v = this.isub(G), G.negative = 1, v._normSign();
      var X, D;
      if (this.length > G.length)
        X = this, D = G;
      else
        X = G, D = this;
      var M = 0;
      for (var L = 0;L < D.length; L++)
        v = (X.words[L] | 0) + (D.words[L] | 0) + M, this.words[L] = v & 67108863, M = v >>> 26;
      for (;M !== 0 && L < X.length; L++)
        v = (X.words[L] | 0) + M, this.words[L] = v & 67108863, M = v >>> 26;
      if (this.length = X.length, M !== 0)
        this.words[this.length] = M, this.length++;
      else if (X !== this)
        for (;L < X.length; L++)
          this.words[L] = X.words[L];
      return this;
    }, W.prototype.add = function _(G) {
      var v;
      if (G.negative !== 0 && this.negative === 0)
        return G.negative = 0, v = this.sub(G), G.negative ^= 1, v;
      else if (G.negative === 0 && this.negative !== 0)
        return this.negative = 0, v = G.sub(this), this.negative = 1, v;
      if (this.length > G.length)
        return this.clone().iadd(G);
      return G.clone().iadd(this);
    }, W.prototype.isub = function _(G) {
      if (G.negative !== 0) {
        G.negative = 0;
        var v = this.iadd(G);
        return G.negative = 1, v._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(G), this.negative = 1, this._normSign();
      var X = this.cmp(G);
      if (X === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var D, M;
      if (X > 0)
        D = this, M = G;
      else
        D = G, M = this;
      var L = 0;
      for (var S = 0;S < M.length; S++)
        v = (D.words[S] | 0) - (M.words[S] | 0) + L, L = v >> 26, this.words[S] = v & 67108863;
      for (;L !== 0 && S < D.length; S++)
        v = (D.words[S] | 0) + L, L = v >> 26, this.words[S] = v & 67108863;
      if (L === 0 && S < D.length && D !== this)
        for (;S < D.length; S++)
          this.words[S] = D.words[S];
      if (this.length = Math.max(this.length, S), D !== this)
        this.negative = 1;
      return this._strip();
    }, W.prototype.sub = function _(G) {
      return this.clone().isub(G);
    };
    function h2(_, G, v) {
      v.negative = G.negative ^ _.negative;
      var X = _.length + G.length | 0;
      v.length = X, X = X - 1 | 0;
      var D = _.words[0] | 0, M = G.words[0] | 0, L = D * M, S = L & 67108863, R = L / 67108864 | 0;
      v.words[0] = S;
      for (var F = 1;F < X; F++) {
        var E = R >>> 26, f = R & 67108863, l = Math.min(F, G.length - 1);
        for (var p = Math.max(0, F - _.length + 1);p <= l; p++) {
          var i = F - p | 0;
          D = _.words[i] | 0, M = G.words[p] | 0, L = D * M + f, E += L / 67108864 | 0, f = L & 67108863;
        }
        v.words[F] = f | 0, R = E | 0;
      }
      if (R !== 0)
        v.words[F] = R | 0;
      else
        v.length--;
      return v._strip();
    }
    var b = function _(G, v, X) {
      var D = G.words, M = v.words, L = X.words, S = 0, R, F, E, f = D[0] | 0, l = f & 8191, p = f >>> 13, i = D[1] | 0, D0 = i & 8191, Q0 = i >>> 13, fJ = D[2] | 0, Y0 = fJ & 8191, q0 = fJ >>> 13, n$ = D[3] | 0, N0 = n$ & 8191, s0 = n$ >>> 13, e$ = D[4] | 0, l0 = e$ & 8191, a0 = e$ >>> 13, iJ = D[5] | 0, u0 = iJ & 8191, c0 = iJ >>> 13, UQ = D[6] | 0, b0 = UQ & 8191, R0 = UQ >>> 13, YW = D[7] | 0, o0 = YW & 8191, JJ = YW >>> 13, zW = D[8] | 0, $J = zW & 8191, HJ = zW >>> 13, jW = D[9] | 0, QJ = jW & 8191, WJ = jW >>> 13, VW = M[0] | 0, ZJ = VW & 8191, YJ = VW >>> 13, GW = M[1] | 0, zJ = GW & 8191, jJ = GW >>> 13, FW = M[2] | 0, VJ = FW & 8191, GJ = FW >>> 13, XW = M[3] | 0, FJ = XW & 8191, XJ = XW >>> 13, UW = M[4] | 0, UJ = UW & 8191, DJ = UW >>> 13, DW = M[5] | 0, qJ = DW & 8191, vJ = DW >>> 13, qW = M[6] | 0, CJ = qW & 8191, RJ = qW >>> 13, vW = M[7] | 0, BJ = vW & 8191, MJ = vW >>> 13, CW = M[8] | 0, OJ = CW & 8191, LJ = CW >>> 13, RW = M[9] | 0, KJ = RW & 8191, hJ = RW >>> 13;
      X.negative = G.negative ^ v.negative, X.length = 19, R = Math.imul(l, ZJ), F = Math.imul(l, YJ), F = F + Math.imul(p, ZJ) | 0, E = Math.imul(p, YJ);
      var R8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (R8 >>> 26) | 0, R8 &= 67108863, R = Math.imul(D0, ZJ), F = Math.imul(D0, YJ), F = F + Math.imul(Q0, ZJ) | 0, E = Math.imul(Q0, YJ), R = R + Math.imul(l, zJ) | 0, F = F + Math.imul(l, jJ) | 0, F = F + Math.imul(p, zJ) | 0, E = E + Math.imul(p, jJ) | 0;
      var B8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (B8 >>> 26) | 0, B8 &= 67108863, R = Math.imul(Y0, ZJ), F = Math.imul(Y0, YJ), F = F + Math.imul(q0, ZJ) | 0, E = Math.imul(q0, YJ), R = R + Math.imul(D0, zJ) | 0, F = F + Math.imul(D0, jJ) | 0, F = F + Math.imul(Q0, zJ) | 0, E = E + Math.imul(Q0, jJ) | 0, R = R + Math.imul(l, VJ) | 0, F = F + Math.imul(l, GJ) | 0, F = F + Math.imul(p, VJ) | 0, E = E + Math.imul(p, GJ) | 0;
      var M8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (M8 >>> 26) | 0, M8 &= 67108863, R = Math.imul(N0, ZJ), F = Math.imul(N0, YJ), F = F + Math.imul(s0, ZJ) | 0, E = Math.imul(s0, YJ), R = R + Math.imul(Y0, zJ) | 0, F = F + Math.imul(Y0, jJ) | 0, F = F + Math.imul(q0, zJ) | 0, E = E + Math.imul(q0, jJ) | 0, R = R + Math.imul(D0, VJ) | 0, F = F + Math.imul(D0, GJ) | 0, F = F + Math.imul(Q0, VJ) | 0, E = E + Math.imul(Q0, GJ) | 0, R = R + Math.imul(l, FJ) | 0, F = F + Math.imul(l, XJ) | 0, F = F + Math.imul(p, FJ) | 0, E = E + Math.imul(p, XJ) | 0;
      var O8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (O8 >>> 26) | 0, O8 &= 67108863, R = Math.imul(l0, ZJ), F = Math.imul(l0, YJ), F = F + Math.imul(a0, ZJ) | 0, E = Math.imul(a0, YJ), R = R + Math.imul(N0, zJ) | 0, F = F + Math.imul(N0, jJ) | 0, F = F + Math.imul(s0, zJ) | 0, E = E + Math.imul(s0, jJ) | 0, R = R + Math.imul(Y0, VJ) | 0, F = F + Math.imul(Y0, GJ) | 0, F = F + Math.imul(q0, VJ) | 0, E = E + Math.imul(q0, GJ) | 0, R = R + Math.imul(D0, FJ) | 0, F = F + Math.imul(D0, XJ) | 0, F = F + Math.imul(Q0, FJ) | 0, E = E + Math.imul(Q0, XJ) | 0, R = R + Math.imul(l, UJ) | 0, F = F + Math.imul(l, DJ) | 0, F = F + Math.imul(p, UJ) | 0, E = E + Math.imul(p, DJ) | 0;
      var L8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (L8 >>> 26) | 0, L8 &= 67108863, R = Math.imul(u0, ZJ), F = Math.imul(u0, YJ), F = F + Math.imul(c0, ZJ) | 0, E = Math.imul(c0, YJ), R = R + Math.imul(l0, zJ) | 0, F = F + Math.imul(l0, jJ) | 0, F = F + Math.imul(a0, zJ) | 0, E = E + Math.imul(a0, jJ) | 0, R = R + Math.imul(N0, VJ) | 0, F = F + Math.imul(N0, GJ) | 0, F = F + Math.imul(s0, VJ) | 0, E = E + Math.imul(s0, GJ) | 0, R = R + Math.imul(Y0, FJ) | 0, F = F + Math.imul(Y0, XJ) | 0, F = F + Math.imul(q0, FJ) | 0, E = E + Math.imul(q0, XJ) | 0, R = R + Math.imul(D0, UJ) | 0, F = F + Math.imul(D0, DJ) | 0, F = F + Math.imul(Q0, UJ) | 0, E = E + Math.imul(Q0, DJ) | 0, R = R + Math.imul(l, qJ) | 0, F = F + Math.imul(l, vJ) | 0, F = F + Math.imul(p, qJ) | 0, E = E + Math.imul(p, vJ) | 0;
      var K8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (K8 >>> 26) | 0, K8 &= 67108863, R = Math.imul(b0, ZJ), F = Math.imul(b0, YJ), F = F + Math.imul(R0, ZJ) | 0, E = Math.imul(R0, YJ), R = R + Math.imul(u0, zJ) | 0, F = F + Math.imul(u0, jJ) | 0, F = F + Math.imul(c0, zJ) | 0, E = E + Math.imul(c0, jJ) | 0, R = R + Math.imul(l0, VJ) | 0, F = F + Math.imul(l0, GJ) | 0, F = F + Math.imul(a0, VJ) | 0, E = E + Math.imul(a0, GJ) | 0, R = R + Math.imul(N0, FJ) | 0, F = F + Math.imul(N0, XJ) | 0, F = F + Math.imul(s0, FJ) | 0, E = E + Math.imul(s0, XJ) | 0, R = R + Math.imul(Y0, UJ) | 0, F = F + Math.imul(Y0, DJ) | 0, F = F + Math.imul(q0, UJ) | 0, E = E + Math.imul(q0, DJ) | 0, R = R + Math.imul(D0, qJ) | 0, F = F + Math.imul(D0, vJ) | 0, F = F + Math.imul(Q0, qJ) | 0, E = E + Math.imul(Q0, vJ) | 0, R = R + Math.imul(l, CJ) | 0, F = F + Math.imul(l, RJ) | 0, F = F + Math.imul(p, CJ) | 0, E = E + Math.imul(p, RJ) | 0;
      var h8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (h8 >>> 26) | 0, h8 &= 67108863, R = Math.imul(o0, ZJ), F = Math.imul(o0, YJ), F = F + Math.imul(JJ, ZJ) | 0, E = Math.imul(JJ, YJ), R = R + Math.imul(b0, zJ) | 0, F = F + Math.imul(b0, jJ) | 0, F = F + Math.imul(R0, zJ) | 0, E = E + Math.imul(R0, jJ) | 0, R = R + Math.imul(u0, VJ) | 0, F = F + Math.imul(u0, GJ) | 0, F = F + Math.imul(c0, VJ) | 0, E = E + Math.imul(c0, GJ) | 0, R = R + Math.imul(l0, FJ) | 0, F = F + Math.imul(l0, XJ) | 0, F = F + Math.imul(a0, FJ) | 0, E = E + Math.imul(a0, XJ) | 0, R = R + Math.imul(N0, UJ) | 0, F = F + Math.imul(N0, DJ) | 0, F = F + Math.imul(s0, UJ) | 0, E = E + Math.imul(s0, DJ) | 0, R = R + Math.imul(Y0, qJ) | 0, F = F + Math.imul(Y0, vJ) | 0, F = F + Math.imul(q0, qJ) | 0, E = E + Math.imul(q0, vJ) | 0, R = R + Math.imul(D0, CJ) | 0, F = F + Math.imul(D0, RJ) | 0, F = F + Math.imul(Q0, CJ) | 0, E = E + Math.imul(Q0, RJ) | 0, R = R + Math.imul(l, BJ) | 0, F = F + Math.imul(l, MJ) | 0, F = F + Math.imul(p, BJ) | 0, E = E + Math.imul(p, MJ) | 0;
      var E8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (E8 >>> 26) | 0, E8 &= 67108863, R = Math.imul($J, ZJ), F = Math.imul($J, YJ), F = F + Math.imul(HJ, ZJ) | 0, E = Math.imul(HJ, YJ), R = R + Math.imul(o0, zJ) | 0, F = F + Math.imul(o0, jJ) | 0, F = F + Math.imul(JJ, zJ) | 0, E = E + Math.imul(JJ, jJ) | 0, R = R + Math.imul(b0, VJ) | 0, F = F + Math.imul(b0, GJ) | 0, F = F + Math.imul(R0, VJ) | 0, E = E + Math.imul(R0, GJ) | 0, R = R + Math.imul(u0, FJ) | 0, F = F + Math.imul(u0, XJ) | 0, F = F + Math.imul(c0, FJ) | 0, E = E + Math.imul(c0, XJ) | 0, R = R + Math.imul(l0, UJ) | 0, F = F + Math.imul(l0, DJ) | 0, F = F + Math.imul(a0, UJ) | 0, E = E + Math.imul(a0, DJ) | 0, R = R + Math.imul(N0, qJ) | 0, F = F + Math.imul(N0, vJ) | 0, F = F + Math.imul(s0, qJ) | 0, E = E + Math.imul(s0, vJ) | 0, R = R + Math.imul(Y0, CJ) | 0, F = F + Math.imul(Y0, RJ) | 0, F = F + Math.imul(q0, CJ) | 0, E = E + Math.imul(q0, RJ) | 0, R = R + Math.imul(D0, BJ) | 0, F = F + Math.imul(D0, MJ) | 0, F = F + Math.imul(Q0, BJ) | 0, E = E + Math.imul(Q0, MJ) | 0, R = R + Math.imul(l, OJ) | 0, F = F + Math.imul(l, LJ) | 0, F = F + Math.imul(p, OJ) | 0, E = E + Math.imul(p, LJ) | 0;
      var S8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (S8 >>> 26) | 0, S8 &= 67108863, R = Math.imul(QJ, ZJ), F = Math.imul(QJ, YJ), F = F + Math.imul(WJ, ZJ) | 0, E = Math.imul(WJ, YJ), R = R + Math.imul($J, zJ) | 0, F = F + Math.imul($J, jJ) | 0, F = F + Math.imul(HJ, zJ) | 0, E = E + Math.imul(HJ, jJ) | 0, R = R + Math.imul(o0, VJ) | 0, F = F + Math.imul(o0, GJ) | 0, F = F + Math.imul(JJ, VJ) | 0, E = E + Math.imul(JJ, GJ) | 0, R = R + Math.imul(b0, FJ) | 0, F = F + Math.imul(b0, XJ) | 0, F = F + Math.imul(R0, FJ) | 0, E = E + Math.imul(R0, XJ) | 0, R = R + Math.imul(u0, UJ) | 0, F = F + Math.imul(u0, DJ) | 0, F = F + Math.imul(c0, UJ) | 0, E = E + Math.imul(c0, DJ) | 0, R = R + Math.imul(l0, qJ) | 0, F = F + Math.imul(l0, vJ) | 0, F = F + Math.imul(a0, qJ) | 0, E = E + Math.imul(a0, vJ) | 0, R = R + Math.imul(N0, CJ) | 0, F = F + Math.imul(N0, RJ) | 0, F = F + Math.imul(s0, CJ) | 0, E = E + Math.imul(s0, RJ) | 0, R = R + Math.imul(Y0, BJ) | 0, F = F + Math.imul(Y0, MJ) | 0, F = F + Math.imul(q0, BJ) | 0, E = E + Math.imul(q0, MJ) | 0, R = R + Math.imul(D0, OJ) | 0, F = F + Math.imul(D0, LJ) | 0, F = F + Math.imul(Q0, OJ) | 0, E = E + Math.imul(Q0, LJ) | 0, R = R + Math.imul(l, KJ) | 0, F = F + Math.imul(l, hJ) | 0, F = F + Math.imul(p, KJ) | 0, E = E + Math.imul(p, hJ) | 0;
      var w8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, R = Math.imul(QJ, zJ), F = Math.imul(QJ, jJ), F = F + Math.imul(WJ, zJ) | 0, E = Math.imul(WJ, jJ), R = R + Math.imul($J, VJ) | 0, F = F + Math.imul($J, GJ) | 0, F = F + Math.imul(HJ, VJ) | 0, E = E + Math.imul(HJ, GJ) | 0, R = R + Math.imul(o0, FJ) | 0, F = F + Math.imul(o0, XJ) | 0, F = F + Math.imul(JJ, FJ) | 0, E = E + Math.imul(JJ, XJ) | 0, R = R + Math.imul(b0, UJ) | 0, F = F + Math.imul(b0, DJ) | 0, F = F + Math.imul(R0, UJ) | 0, E = E + Math.imul(R0, DJ) | 0, R = R + Math.imul(u0, qJ) | 0, F = F + Math.imul(u0, vJ) | 0, F = F + Math.imul(c0, qJ) | 0, E = E + Math.imul(c0, vJ) | 0, R = R + Math.imul(l0, CJ) | 0, F = F + Math.imul(l0, RJ) | 0, F = F + Math.imul(a0, CJ) | 0, E = E + Math.imul(a0, RJ) | 0, R = R + Math.imul(N0, BJ) | 0, F = F + Math.imul(N0, MJ) | 0, F = F + Math.imul(s0, BJ) | 0, E = E + Math.imul(s0, MJ) | 0, R = R + Math.imul(Y0, OJ) | 0, F = F + Math.imul(Y0, LJ) | 0, F = F + Math.imul(q0, OJ) | 0, E = E + Math.imul(q0, LJ) | 0, R = R + Math.imul(D0, KJ) | 0, F = F + Math.imul(D0, hJ) | 0, F = F + Math.imul(Q0, KJ) | 0, E = E + Math.imul(Q0, hJ) | 0;
      var b8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (b8 >>> 26) | 0, b8 &= 67108863, R = Math.imul(QJ, VJ), F = Math.imul(QJ, GJ), F = F + Math.imul(WJ, VJ) | 0, E = Math.imul(WJ, GJ), R = R + Math.imul($J, FJ) | 0, F = F + Math.imul($J, XJ) | 0, F = F + Math.imul(HJ, FJ) | 0, E = E + Math.imul(HJ, XJ) | 0, R = R + Math.imul(o0, UJ) | 0, F = F + Math.imul(o0, DJ) | 0, F = F + Math.imul(JJ, UJ) | 0, E = E + Math.imul(JJ, DJ) | 0, R = R + Math.imul(b0, qJ) | 0, F = F + Math.imul(b0, vJ) | 0, F = F + Math.imul(R0, qJ) | 0, E = E + Math.imul(R0, vJ) | 0, R = R + Math.imul(u0, CJ) | 0, F = F + Math.imul(u0, RJ) | 0, F = F + Math.imul(c0, CJ) | 0, E = E + Math.imul(c0, RJ) | 0, R = R + Math.imul(l0, BJ) | 0, F = F + Math.imul(l0, MJ) | 0, F = F + Math.imul(a0, BJ) | 0, E = E + Math.imul(a0, MJ) | 0, R = R + Math.imul(N0, OJ) | 0, F = F + Math.imul(N0, LJ) | 0, F = F + Math.imul(s0, OJ) | 0, E = E + Math.imul(s0, LJ) | 0, R = R + Math.imul(Y0, KJ) | 0, F = F + Math.imul(Y0, hJ) | 0, F = F + Math.imul(q0, KJ) | 0, E = E + Math.imul(q0, hJ) | 0;
      var _8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (_8 >>> 26) | 0, _8 &= 67108863, R = Math.imul(QJ, FJ), F = Math.imul(QJ, XJ), F = F + Math.imul(WJ, FJ) | 0, E = Math.imul(WJ, XJ), R = R + Math.imul($J, UJ) | 0, F = F + Math.imul($J, DJ) | 0, F = F + Math.imul(HJ, UJ) | 0, E = E + Math.imul(HJ, DJ) | 0, R = R + Math.imul(o0, qJ) | 0, F = F + Math.imul(o0, vJ) | 0, F = F + Math.imul(JJ, qJ) | 0, E = E + Math.imul(JJ, vJ) | 0, R = R + Math.imul(b0, CJ) | 0, F = F + Math.imul(b0, RJ) | 0, F = F + Math.imul(R0, CJ) | 0, E = E + Math.imul(R0, RJ) | 0, R = R + Math.imul(u0, BJ) | 0, F = F + Math.imul(u0, MJ) | 0, F = F + Math.imul(c0, BJ) | 0, E = E + Math.imul(c0, MJ) | 0, R = R + Math.imul(l0, OJ) | 0, F = F + Math.imul(l0, LJ) | 0, F = F + Math.imul(a0, OJ) | 0, E = E + Math.imul(a0, LJ) | 0, R = R + Math.imul(N0, KJ) | 0, F = F + Math.imul(N0, hJ) | 0, F = F + Math.imul(s0, KJ) | 0, E = E + Math.imul(s0, hJ) | 0;
      var P8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (P8 >>> 26) | 0, P8 &= 67108863, R = Math.imul(QJ, UJ), F = Math.imul(QJ, DJ), F = F + Math.imul(WJ, UJ) | 0, E = Math.imul(WJ, DJ), R = R + Math.imul($J, qJ) | 0, F = F + Math.imul($J, vJ) | 0, F = F + Math.imul(HJ, qJ) | 0, E = E + Math.imul(HJ, vJ) | 0, R = R + Math.imul(o0, CJ) | 0, F = F + Math.imul(o0, RJ) | 0, F = F + Math.imul(JJ, CJ) | 0, E = E + Math.imul(JJ, RJ) | 0, R = R + Math.imul(b0, BJ) | 0, F = F + Math.imul(b0, MJ) | 0, F = F + Math.imul(R0, BJ) | 0, E = E + Math.imul(R0, MJ) | 0, R = R + Math.imul(u0, OJ) | 0, F = F + Math.imul(u0, LJ) | 0, F = F + Math.imul(c0, OJ) | 0, E = E + Math.imul(c0, LJ) | 0, R = R + Math.imul(l0, KJ) | 0, F = F + Math.imul(l0, hJ) | 0, F = F + Math.imul(a0, KJ) | 0, E = E + Math.imul(a0, hJ) | 0;
      var N8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (N8 >>> 26) | 0, N8 &= 67108863, R = Math.imul(QJ, qJ), F = Math.imul(QJ, vJ), F = F + Math.imul(WJ, qJ) | 0, E = Math.imul(WJ, vJ), R = R + Math.imul($J, CJ) | 0, F = F + Math.imul($J, RJ) | 0, F = F + Math.imul(HJ, CJ) | 0, E = E + Math.imul(HJ, RJ) | 0, R = R + Math.imul(o0, BJ) | 0, F = F + Math.imul(o0, MJ) | 0, F = F + Math.imul(JJ, BJ) | 0, E = E + Math.imul(JJ, MJ) | 0, R = R + Math.imul(b0, OJ) | 0, F = F + Math.imul(b0, LJ) | 0, F = F + Math.imul(R0, OJ) | 0, E = E + Math.imul(R0, LJ) | 0, R = R + Math.imul(u0, KJ) | 0, F = F + Math.imul(u0, hJ) | 0, F = F + Math.imul(c0, KJ) | 0, E = E + Math.imul(c0, hJ) | 0;
      var g8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (g8 >>> 26) | 0, g8 &= 67108863, R = Math.imul(QJ, CJ), F = Math.imul(QJ, RJ), F = F + Math.imul(WJ, CJ) | 0, E = Math.imul(WJ, RJ), R = R + Math.imul($J, BJ) | 0, F = F + Math.imul($J, MJ) | 0, F = F + Math.imul(HJ, BJ) | 0, E = E + Math.imul(HJ, MJ) | 0, R = R + Math.imul(o0, OJ) | 0, F = F + Math.imul(o0, LJ) | 0, F = F + Math.imul(JJ, OJ) | 0, E = E + Math.imul(JJ, LJ) | 0, R = R + Math.imul(b0, KJ) | 0, F = F + Math.imul(b0, hJ) | 0, F = F + Math.imul(R0, KJ) | 0, E = E + Math.imul(R0, hJ) | 0;
      var k8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (k8 >>> 26) | 0, k8 &= 67108863, R = Math.imul(QJ, BJ), F = Math.imul(QJ, MJ), F = F + Math.imul(WJ, BJ) | 0, E = Math.imul(WJ, MJ), R = R + Math.imul($J, OJ) | 0, F = F + Math.imul($J, LJ) | 0, F = F + Math.imul(HJ, OJ) | 0, E = E + Math.imul(HJ, LJ) | 0, R = R + Math.imul(o0, KJ) | 0, F = F + Math.imul(o0, hJ) | 0, F = F + Math.imul(JJ, KJ) | 0, E = E + Math.imul(JJ, hJ) | 0;
      var x8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (x8 >>> 26) | 0, x8 &= 67108863, R = Math.imul(QJ, OJ), F = Math.imul(QJ, LJ), F = F + Math.imul(WJ, OJ) | 0, E = Math.imul(WJ, LJ), R = R + Math.imul($J, KJ) | 0, F = F + Math.imul($J, hJ) | 0, F = F + Math.imul(HJ, KJ) | 0, E = E + Math.imul(HJ, hJ) | 0;
      var A8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      S = (E + (F >>> 13) | 0) + (A8 >>> 26) | 0, A8 &= 67108863, R = Math.imul(QJ, KJ), F = Math.imul(QJ, hJ), F = F + Math.imul(WJ, KJ) | 0, E = Math.imul(WJ, hJ);
      var T8 = (S + R | 0) + ((F & 8191) << 13) | 0;
      if (S = (E + (F >>> 13) | 0) + (T8 >>> 26) | 0, T8 &= 67108863, L[0] = R8, L[1] = B8, L[2] = M8, L[3] = O8, L[4] = L8, L[5] = K8, L[6] = h8, L[7] = E8, L[8] = S8, L[9] = w8, L[10] = b8, L[11] = _8, L[12] = P8, L[13] = N8, L[14] = g8, L[15] = k8, L[16] = x8, L[17] = A8, L[18] = T8, S !== 0)
        L[19] = S, X.length++;
      return X;
    };
    if (!Math.imul)
      b = h2;
    function N(_, G, v) {
      v.negative = G.negative ^ _.negative, v.length = _.length + G.length;
      var X = 0, D = 0;
      for (var M = 0;M < v.length - 1; M++) {
        var L = D;
        D = 0;
        var S = X & 67108863, R = Math.min(M, G.length - 1);
        for (var F = Math.max(0, M - _.length + 1);F <= R; F++) {
          var E = M - F, f = _.words[E] | 0, l = G.words[F] | 0, p = f * l, i = p & 67108863;
          L = L + (p / 67108864 | 0) | 0, i = i + S | 0, S = i & 67108863, L = L + (i >>> 26) | 0, D += L >>> 26, L &= 67108863;
        }
        v.words[M] = S, X = L, L = D;
      }
      if (X !== 0)
        v.words[M] = X;
      else
        v.length--;
      return v._strip();
    }
    function x(_, G, v) {
      return N(_, G, v);
    }
    W.prototype.mulTo = function _(G, v) {
      var X, D = this.length + G.length;
      if (this.length === 10 && G.length === 10)
        X = b(this, G, v);
      else if (D < 63)
        X = h2(this, G, v);
      else if (D < 1024)
        X = N(this, G, v);
      else
        X = x(this, G, v);
      return X;
    };
    function k(_, G) {
      this.x = _, this.y = G;
    }
    k.prototype.makeRBT = function _(G) {
      var v = new Array(G), X = W.prototype._countBits(G) - 1;
      for (var D = 0;D < G; D++)
        v[D] = this.revBin(D, X, G);
      return v;
    }, k.prototype.revBin = function _(G, v, X) {
      if (G === 0 || G === X - 1)
        return G;
      var D = 0;
      for (var M = 0;M < v; M++)
        D |= (G & 1) << v - M - 1, G >>= 1;
      return D;
    }, k.prototype.permute = function _(G, v, X, D, M, L) {
      for (var S = 0;S < L; S++)
        D[S] = v[G[S]], M[S] = X[G[S]];
    }, k.prototype.transform = function _(G, v, X, D, M, L) {
      this.permute(L, G, v, X, D, M);
      for (var S = 1;S < M; S <<= 1) {
        var R = S << 1, F = Math.cos(2 * Math.PI / R), E = Math.sin(2 * Math.PI / R);
        for (var f = 0;f < M; f += R) {
          var l = F, p = E;
          for (var i = 0;i < S; i++) {
            var D0 = X[f + i], Q0 = D[f + i], fJ = X[f + i + S], Y0 = D[f + i + S], q0 = l * fJ - p * Y0;
            if (Y0 = l * Y0 + p * fJ, fJ = q0, X[f + i] = D0 + fJ, D[f + i] = Q0 + Y0, X[f + i + S] = D0 - fJ, D[f + i + S] = Q0 - Y0, i !== R)
              q0 = F * l - E * p, p = F * p + E * l, l = q0;
          }
        }
      }
    }, k.prototype.guessLen13b = function _(G, v) {
      var X = Math.max(v, G) | 1, D = X & 1, M = 0;
      for (X = X / 2 | 0;X; X = X >>> 1)
        M++;
      return 1 << M + 1 + D;
    }, k.prototype.conjugate = function _(G, v, X) {
      if (X <= 1)
        return;
      for (var D = 0;D < X / 2; D++) {
        var M = G[D];
        G[D] = G[X - D - 1], G[X - D - 1] = M, M = v[D], v[D] = -v[X - D - 1], v[X - D - 1] = -M;
      }
    }, k.prototype.normalize13b = function _(G, v) {
      var X = 0;
      for (var D = 0;D < v / 2; D++) {
        var M = Math.round(G[2 * D + 1] / v) * 8192 + Math.round(G[2 * D] / v) + X;
        if (G[D] = M & 67108863, M < 67108864)
          X = 0;
        else
          X = M / 67108864 | 0;
      }
      return G;
    }, k.prototype.convert13b = function _(G, v, X, D) {
      var M = 0;
      for (var L = 0;L < v; L++)
        M = M + (G[L] | 0), X[2 * L] = M & 8191, M = M >>> 13, X[2 * L + 1] = M & 8191, M = M >>> 13;
      for (L = 2 * v;L < D; ++L)
        X[L] = 0;
      H(M === 0), H((M & ~8191) === 0);
    }, k.prototype.stub = function _(G) {
      var v = new Array(G);
      for (var X = 0;X < G; X++)
        v[X] = 0;
      return v;
    }, k.prototype.mulp = function _(G, v, X) {
      var D = 2 * this.guessLen13b(G.length, v.length), M = this.makeRBT(D), L = this.stub(D), S = new Array(D), R = new Array(D), F = new Array(D), E = new Array(D), f = new Array(D), l = new Array(D), p = X.words;
      p.length = D, this.convert13b(G.words, G.length, S, D), this.convert13b(v.words, v.length, E, D), this.transform(S, L, R, F, D, M), this.transform(E, L, f, l, D, M);
      for (var i = 0;i < D; i++) {
        var D0 = R[i] * f[i] - F[i] * l[i];
        F[i] = R[i] * l[i] + F[i] * f[i], R[i] = D0;
      }
      return this.conjugate(R, F, D), this.transform(R, F, p, L, D, M), this.conjugate(p, L, D), this.normalize13b(p, D), X.negative = G.negative ^ v.negative, X.length = G.length + v.length, X._strip();
    }, W.prototype.mul = function _(G) {
      var v = new W(null);
      return v.words = new Array(this.length + G.length), this.mulTo(G, v);
    }, W.prototype.mulf = function _(G) {
      var v = new W(null);
      return v.words = new Array(this.length + G.length), x(this, G, v);
    }, W.prototype.imul = function _(G) {
      return this.clone().mulTo(G, this);
    }, W.prototype.imuln = function _(G) {
      var v = G < 0;
      if (v)
        G = -G;
      H(typeof G === "number"), H(G < 67108864);
      var X = 0;
      for (var D = 0;D < this.length; D++) {
        var M = (this.words[D] | 0) * G, L = (M & 67108863) + (X & 67108863);
        X >>= 26, X += M / 67108864 | 0, X += L >>> 26, this.words[D] = L & 67108863;
      }
      if (X !== 0)
        this.words[D] = X, this.length++;
      return v ? this.ineg() : this;
    }, W.prototype.muln = function _(G) {
      return this.clone().imuln(G);
    }, W.prototype.sqr = function _() {
      return this.mul(this);
    }, W.prototype.isqr = function _() {
      return this.imul(this.clone());
    }, W.prototype.pow = function _(G) {
      var v = O(G);
      if (v.length === 0)
        return new W(1);
      var X = this;
      for (var D = 0;D < v.length; D++, X = X.sqr())
        if (v[D] !== 0)
          break;
      if (++D < v.length)
        for (var M = X.sqr();D < v.length; D++, M = M.sqr()) {
          if (v[D] === 0)
            continue;
          X = X.mul(M);
        }
      return X;
    }, W.prototype.iushln = function _(G) {
      H(typeof G === "number" && G >= 0);
      var v = G % 26, X = (G - v) / 26, D = 67108863 >>> 26 - v << 26 - v, M;
      if (v !== 0) {
        var L = 0;
        for (M = 0;M < this.length; M++) {
          var S = this.words[M] & D, R = (this.words[M] | 0) - S << v;
          this.words[M] = R | L, L = S >>> 26 - v;
        }
        if (L)
          this.words[M] = L, this.length++;
      }
      if (X !== 0) {
        for (M = this.length - 1;M >= 0; M--)
          this.words[M + X] = this.words[M];
        for (M = 0;M < X; M++)
          this.words[M] = 0;
        this.length += X;
      }
      return this._strip();
    }, W.prototype.ishln = function _(G) {
      return H(this.negative === 0), this.iushln(G);
    }, W.prototype.iushrn = function _(G, v, X) {
      H(typeof G === "number" && G >= 0);
      var D;
      if (v)
        D = (v - v % 26) / 26;
      else
        D = 0;
      var M = G % 26, L = Math.min((G - M) / 26, this.length), S = 67108863 ^ 67108863 >>> M << M, R = X;
      if (D -= L, D = Math.max(0, D), R) {
        for (var F = 0;F < L; F++)
          R.words[F] = this.words[F];
        R.length = L;
      }
      if (L === 0)
        ;
      else if (this.length > L) {
        this.length -= L;
        for (F = 0;F < this.length; F++)
          this.words[F] = this.words[F + L];
      } else
        this.words[0] = 0, this.length = 1;
      var E = 0;
      for (F = this.length - 1;F >= 0 && (E !== 0 || F >= D); F--) {
        var f = this.words[F] | 0;
        this.words[F] = E << 26 - M | f >>> M, E = f & S;
      }
      if (R && E !== 0)
        R.words[R.length++] = E;
      if (this.length === 0)
        this.words[0] = 0, this.length = 1;
      return this._strip();
    }, W.prototype.ishrn = function _(G, v, X) {
      return H(this.negative === 0), this.iushrn(G, v, X);
    }, W.prototype.shln = function _(G) {
      return this.clone().ishln(G);
    }, W.prototype.ushln = function _(G) {
      return this.clone().iushln(G);
    }, W.prototype.shrn = function _(G) {
      return this.clone().ishrn(G);
    }, W.prototype.ushrn = function _(G) {
      return this.clone().iushrn(G);
    }, W.prototype.testn = function _(G) {
      H(typeof G === "number" && G >= 0);
      var v = G % 26, X = (G - v) / 26, D = 1 << v;
      if (this.length <= X)
        return false;
      var M = this.words[X];
      return !!(M & D);
    }, W.prototype.imaskn = function _(G) {
      H(typeof G === "number" && G >= 0);
      var v = G % 26, X = (G - v) / 26;
      if (H(this.negative === 0, "imaskn works only with positive numbers"), this.length <= X)
        return this;
      if (v !== 0)
        X++;
      if (this.length = Math.min(X, this.length), v !== 0) {
        var D = 67108863 ^ 67108863 >>> v << v;
        this.words[this.length - 1] &= D;
      }
      return this._strip();
    }, W.prototype.maskn = function _(G) {
      return this.clone().imaskn(G);
    }, W.prototype.iaddn = function _(G) {
      if (H(typeof G === "number"), H(G < 67108864), G < 0)
        return this.isubn(-G);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= G)
          return this.words[0] = G - (this.words[0] | 0), this.negative = 0, this;
        return this.negative = 0, this.isubn(G), this.negative = 1, this;
      }
      return this._iaddn(G);
    }, W.prototype._iaddn = function _(G) {
      this.words[0] += G;
      for (var v = 0;v < this.length && this.words[v] >= 67108864; v++)
        if (this.words[v] -= 67108864, v === this.length - 1)
          this.words[v + 1] = 1;
        else
          this.words[v + 1]++;
      return this.length = Math.max(this.length, v + 1), this;
    }, W.prototype.isubn = function _(G) {
      if (H(typeof G === "number"), H(G < 67108864), G < 0)
        return this.iaddn(-G);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(G), this.negative = 1, this;
      if (this.words[0] -= G, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var v = 0;v < this.length && this.words[v] < 0; v++)
          this.words[v] += 67108864, this.words[v + 1] -= 1;
      return this._strip();
    }, W.prototype.addn = function _(G) {
      return this.clone().iaddn(G);
    }, W.prototype.subn = function _(G) {
      return this.clone().isubn(G);
    }, W.prototype.iabs = function _() {
      return this.negative = 0, this;
    }, W.prototype.abs = function _() {
      return this.clone().iabs();
    }, W.prototype._ishlnsubmul = function _(G, v, X) {
      var D = G.length + X, M;
      this._expand(D);
      var L, S = 0;
      for (M = 0;M < G.length; M++) {
        L = (this.words[M + X] | 0) + S;
        var R = (G.words[M] | 0) * v;
        L -= R & 67108863, S = (L >> 26) - (R / 67108864 | 0), this.words[M + X] = L & 67108863;
      }
      for (;M < this.length - X; M++)
        L = (this.words[M + X] | 0) + S, S = L >> 26, this.words[M + X] = L & 67108863;
      if (S === 0)
        return this._strip();
      H(S === -1), S = 0;
      for (M = 0;M < this.length; M++)
        L = -(this.words[M] | 0) + S, S = L >> 26, this.words[M] = L & 67108863;
      return this.negative = 1, this._strip();
    }, W.prototype._wordDiv = function _(G, v) {
      var X = this.length - G.length, D = this.clone(), M = G, L = M.words[M.length - 1] | 0, S = this._countBits(L);
      if (X = 26 - S, X !== 0)
        M = M.ushln(X), D.iushln(X), L = M.words[M.length - 1] | 0;
      var R = D.length - M.length, F;
      if (v !== "mod") {
        F = new W(null), F.length = R + 1, F.words = new Array(F.length);
        for (var E = 0;E < F.length; E++)
          F.words[E] = 0;
      }
      var f = D.clone()._ishlnsubmul(M, 1, R);
      if (f.negative === 0) {
        if (D = f, F)
          F.words[R] = 1;
      }
      for (var l = R - 1;l >= 0; l--) {
        var p = (D.words[M.length + l] | 0) * 67108864 + (D.words[M.length + l - 1] | 0);
        p = Math.min(p / L | 0, 67108863), D._ishlnsubmul(M, p, l);
        while (D.negative !== 0)
          if (p--, D.negative = 0, D._ishlnsubmul(M, 1, l), !D.isZero())
            D.negative ^= 1;
        if (F)
          F.words[l] = p;
      }
      if (F)
        F._strip();
      if (D._strip(), v !== "div" && X !== 0)
        D.iushrn(X);
      return { div: F || null, mod: D };
    }, W.prototype.divmod = function _(G, v, X) {
      if (H(!G.isZero()), this.isZero())
        return { div: new W(0), mod: new W(0) };
      var D, M, L;
      if (this.negative !== 0 && G.negative === 0) {
        if (L = this.neg().divmod(G, v), v !== "mod")
          D = L.div.neg();
        if (v !== "div") {
          if (M = L.mod.neg(), X && M.negative !== 0)
            M.iadd(G);
        }
        return { div: D, mod: M };
      }
      if (this.negative === 0 && G.negative !== 0) {
        if (L = this.divmod(G.neg(), v), v !== "mod")
          D = L.div.neg();
        return { div: D, mod: L.mod };
      }
      if ((this.negative & G.negative) !== 0) {
        if (L = this.neg().divmod(G.neg(), v), v !== "div") {
          if (M = L.mod.neg(), X && M.negative !== 0)
            M.isub(G);
        }
        return { div: L.div, mod: M };
      }
      if (G.length > this.length || this.cmp(G) < 0)
        return { div: new W(0), mod: this };
      if (G.length === 1) {
        if (v === "div")
          return { div: this.divn(G.words[0]), mod: null };
        if (v === "mod")
          return { div: null, mod: new W(this.modrn(G.words[0])) };
        return { div: this.divn(G.words[0]), mod: new W(this.modrn(G.words[0])) };
      }
      return this._wordDiv(G, v);
    }, W.prototype.div = function _(G) {
      return this.divmod(G, "div", false).div;
    }, W.prototype.mod = function _(G) {
      return this.divmod(G, "mod", false).mod;
    }, W.prototype.umod = function _(G) {
      return this.divmod(G, "mod", true).mod;
    }, W.prototype.divRound = function _(G) {
      var v = this.divmod(G);
      if (v.mod.isZero())
        return v.div;
      var X = v.div.negative !== 0 ? v.mod.isub(G) : v.mod, D = G.ushrn(1), M = G.andln(1), L = X.cmp(D);
      if (L < 0 || M === 1 && L === 0)
        return v.div;
      return v.div.negative !== 0 ? v.div.isubn(1) : v.div.iaddn(1);
    }, W.prototype.modrn = function _(G) {
      var v = G < 0;
      if (v)
        G = -G;
      H(G <= 67108863);
      var X = (1 << 26) % G, D = 0;
      for (var M = this.length - 1;M >= 0; M--)
        D = (X * D + (this.words[M] | 0)) % G;
      return v ? -D : D;
    }, W.prototype.modn = function _(G) {
      return this.modrn(G);
    }, W.prototype.idivn = function _(G) {
      var v = G < 0;
      if (v)
        G = -G;
      H(G <= 67108863);
      var X = 0;
      for (var D = this.length - 1;D >= 0; D--) {
        var M = (this.words[D] | 0) + X * 67108864;
        this.words[D] = M / G | 0, X = M % G;
      }
      return this._strip(), v ? this.ineg() : this;
    }, W.prototype.divn = function _(G) {
      return this.clone().idivn(G);
    }, W.prototype.egcd = function _(G) {
      H(G.negative === 0), H(!G.isZero());
      var v = this, X = G.clone();
      if (v.negative !== 0)
        v = v.umod(G);
      else
        v = v.clone();
      var D = new W(1), M = new W(0), L = new W(0), S = new W(1), R = 0;
      while (v.isEven() && X.isEven())
        v.iushrn(1), X.iushrn(1), ++R;
      var F = X.clone(), E = v.clone();
      while (!v.isZero()) {
        for (var f = 0, l = 1;(v.words[0] & l) === 0 && f < 26; ++f, l <<= 1)
          ;
        if (f > 0) {
          v.iushrn(f);
          while (f-- > 0) {
            if (D.isOdd() || M.isOdd())
              D.iadd(F), M.isub(E);
            D.iushrn(1), M.iushrn(1);
          }
        }
        for (var p = 0, i = 1;(X.words[0] & i) === 0 && p < 26; ++p, i <<= 1)
          ;
        if (p > 0) {
          X.iushrn(p);
          while (p-- > 0) {
            if (L.isOdd() || S.isOdd())
              L.iadd(F), S.isub(E);
            L.iushrn(1), S.iushrn(1);
          }
        }
        if (v.cmp(X) >= 0)
          v.isub(X), D.isub(L), M.isub(S);
        else
          X.isub(v), L.isub(D), S.isub(M);
      }
      return { a: L, b: S, gcd: X.iushln(R) };
    }, W.prototype._invmp = function _(G) {
      H(G.negative === 0), H(!G.isZero());
      var v = this, X = G.clone();
      if (v.negative !== 0)
        v = v.umod(G);
      else
        v = v.clone();
      var D = new W(1), M = new W(0), L = X.clone();
      while (v.cmpn(1) > 0 && X.cmpn(1) > 0) {
        for (var S = 0, R = 1;(v.words[0] & R) === 0 && S < 26; ++S, R <<= 1)
          ;
        if (S > 0) {
          v.iushrn(S);
          while (S-- > 0) {
            if (D.isOdd())
              D.iadd(L);
            D.iushrn(1);
          }
        }
        for (var F = 0, E = 1;(X.words[0] & E) === 0 && F < 26; ++F, E <<= 1)
          ;
        if (F > 0) {
          X.iushrn(F);
          while (F-- > 0) {
            if (M.isOdd())
              M.iadd(L);
            M.iushrn(1);
          }
        }
        if (v.cmp(X) >= 0)
          v.isub(X), D.isub(M);
        else
          X.isub(v), M.isub(D);
      }
      var f;
      if (v.cmpn(1) === 0)
        f = D;
      else
        f = M;
      if (f.cmpn(0) < 0)
        f.iadd(G);
      return f;
    }, W.prototype.gcd = function _(G) {
      if (this.isZero())
        return G.abs();
      if (G.isZero())
        return this.abs();
      var v = this.clone(), X = G.clone();
      v.negative = 0, X.negative = 0;
      for (var D = 0;v.isEven() && X.isEven(); D++)
        v.iushrn(1), X.iushrn(1);
      do {
        while (v.isEven())
          v.iushrn(1);
        while (X.isEven())
          X.iushrn(1);
        var M = v.cmp(X);
        if (M < 0) {
          var L = v;
          v = X, X = L;
        } else if (M === 0 || X.cmpn(1) === 0)
          break;
        v.isub(X);
      } while (true);
      return X.iushln(D);
    }, W.prototype.invm = function _(G) {
      return this.egcd(G).a.umod(G);
    }, W.prototype.isEven = function _() {
      return (this.words[0] & 1) === 0;
    }, W.prototype.isOdd = function _() {
      return (this.words[0] & 1) === 1;
    }, W.prototype.andln = function _(G) {
      return this.words[0] & G;
    }, W.prototype.bincn = function _(G) {
      H(typeof G === "number");
      var v = G % 26, X = (G - v) / 26, D = 1 << v;
      if (this.length <= X)
        return this._expand(X + 1), this.words[X] |= D, this;
      var M = D;
      for (var L = X;M !== 0 && L < this.length; L++) {
        var S = this.words[L] | 0;
        S += M, M = S >>> 26, S &= 67108863, this.words[L] = S;
      }
      if (M !== 0)
        this.words[L] = M, this.length++;
      return this;
    }, W.prototype.isZero = function _() {
      return this.length === 1 && this.words[0] === 0;
    }, W.prototype.cmpn = function _(G) {
      var v = G < 0;
      if (this.negative !== 0 && !v)
        return -1;
      if (this.negative === 0 && v)
        return 1;
      this._strip();
      var X;
      if (this.length > 1)
        X = 1;
      else {
        if (v)
          G = -G;
        H(G <= 67108863, "Number is too big");
        var D = this.words[0] | 0;
        X = D === G ? 0 : D < G ? -1 : 1;
      }
      if (this.negative !== 0)
        return -X | 0;
      return X;
    }, W.prototype.cmp = function _(G) {
      if (this.negative !== 0 && G.negative === 0)
        return -1;
      if (this.negative === 0 && G.negative !== 0)
        return 1;
      var v = this.ucmp(G);
      if (this.negative !== 0)
        return -v | 0;
      return v;
    }, W.prototype.ucmp = function _(G) {
      if (this.length > G.length)
        return 1;
      if (this.length < G.length)
        return -1;
      var v = 0;
      for (var X = this.length - 1;X >= 0; X--) {
        var D = this.words[X] | 0, M = G.words[X] | 0;
        if (D === M)
          continue;
        if (D < M)
          v = -1;
        else if (D > M)
          v = 1;
        break;
      }
      return v;
    }, W.prototype.gtn = function _(G) {
      return this.cmpn(G) === 1;
    }, W.prototype.gt = function _(G) {
      return this.cmp(G) === 1;
    }, W.prototype.gten = function _(G) {
      return this.cmpn(G) >= 0;
    }, W.prototype.gte = function _(G) {
      return this.cmp(G) >= 0;
    }, W.prototype.ltn = function _(G) {
      return this.cmpn(G) === -1;
    }, W.prototype.lt = function _(G) {
      return this.cmp(G) === -1;
    }, W.prototype.lten = function _(G) {
      return this.cmpn(G) <= 0;
    }, W.prototype.lte = function _(G) {
      return this.cmp(G) <= 0;
    }, W.prototype.eqn = function _(G) {
      return this.cmpn(G) === 0;
    }, W.prototype.eq = function _(G) {
      return this.cmp(G) === 0;
    }, W.red = function _(G) {
      return new n(G);
    }, W.prototype.toRed = function _(G) {
      return H(!this.red, "Already a number in reduction context"), H(this.negative === 0, "red works only with positives"), G.convertTo(this)._forceRed(G);
    }, W.prototype.fromRed = function _() {
      return H(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, W.prototype._forceRed = function _(G) {
      return this.red = G, this;
    }, W.prototype.forceRed = function _(G) {
      return H(!this.red, "Already a number in reduction context"), this._forceRed(G);
    }, W.prototype.redAdd = function _(G) {
      return H(this.red, "redAdd works only with red numbers"), this.red.add(this, G);
    }, W.prototype.redIAdd = function _(G) {
      return H(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, G);
    }, W.prototype.redSub = function _(G) {
      return H(this.red, "redSub works only with red numbers"), this.red.sub(this, G);
    }, W.prototype.redISub = function _(G) {
      return H(this.red, "redISub works only with red numbers"), this.red.isub(this, G);
    }, W.prototype.redShl = function _(G) {
      return H(this.red, "redShl works only with red numbers"), this.red.shl(this, G);
    }, W.prototype.redMul = function _(G) {
      return H(this.red, "redMul works only with red numbers"), this.red._verify2(this, G), this.red.mul(this, G);
    }, W.prototype.redIMul = function _(G) {
      return H(this.red, "redMul works only with red numbers"), this.red._verify2(this, G), this.red.imul(this, G);
    }, W.prototype.redSqr = function _() {
      return H(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, W.prototype.redISqr = function _() {
      return H(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, W.prototype.redSqrt = function _() {
      return H(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, W.prototype.redInvm = function _() {
      return H(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, W.prototype.redNeg = function _() {
      return H(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, W.prototype.redPow = function _(G) {
      return H(this.red && !G.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, G);
    };
    var g = { k256: null, p224: null, p192: null, p25519: null };
    function A(_, G) {
      this.name = _, this.p = new W(G, 16), this.n = this.p.bitLength(), this.k = new W(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    A.prototype._tmp = function _() {
      var G = new W(null);
      return G.words = new Array(Math.ceil(this.n / 13)), G;
    }, A.prototype.ireduce = function _(G) {
      var v = G, X;
      do
        this.split(v, this.tmp), v = this.imulK(v), v = v.iadd(this.tmp), X = v.bitLength();
      while (X > this.n);
      var D = X < this.n ? -1 : v.ucmp(this.p);
      if (D === 0)
        v.words[0] = 0, v.length = 1;
      else if (D > 0)
        v.isub(this.p);
      else if (v.strip !== undefined)
        v.strip();
      else
        v._strip();
      return v;
    }, A.prototype.split = function _(G, v) {
      G.iushrn(this.n, 0, v);
    }, A.prototype.imulK = function _(G) {
      return G.imul(this.k);
    };
    function I() {
      A.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Q(I, A), I.prototype.split = function _(G, v) {
      var X = 4194303, D = Math.min(G.length, 9);
      for (var M = 0;M < D; M++)
        v.words[M] = G.words[M];
      if (v.length = D, G.length <= 9) {
        G.words[0] = 0, G.length = 1;
        return;
      }
      var L = G.words[9];
      v.words[v.length++] = L & X;
      for (M = 10;M < G.length; M++) {
        var S = G.words[M] | 0;
        G.words[M - 10] = (S & X) << 4 | L >>> 22, L = S;
      }
      if (L >>>= 22, G.words[M - 10] = L, L === 0 && G.length > 10)
        G.length -= 10;
      else
        G.length -= 9;
    }, I.prototype.imulK = function _(G) {
      G.words[G.length] = 0, G.words[G.length + 1] = 0, G.length += 2;
      var v = 0;
      for (var X = 0;X < G.length; X++) {
        var D = G.words[X] | 0;
        v += D * 977, G.words[X] = v & 67108863, v = D * 64 + (v / 67108864 | 0);
      }
      if (G.words[G.length - 1] === 0) {
        if (G.length--, G.words[G.length - 1] === 0)
          G.length--;
      }
      return G;
    };
    function T() {
      A.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Q(T, A);
    function u() {
      A.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Q(u, A);
    function a() {
      A.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Q(a, A), a.prototype.imulK = function _(G) {
      var v = 0;
      for (var X = 0;X < G.length; X++) {
        var D = (G.words[X] | 0) * 19 + v, M = D & 67108863;
        D >>>= 26, G.words[X] = M, v = D;
      }
      if (v !== 0)
        G.words[G.length++] = v;
      return G;
    }, W._prime = function _(G) {
      if (g[G])
        return g[G];
      var v;
      if (G === "k256")
        v = new I;
      else if (G === "p224")
        v = new T;
      else if (G === "p192")
        v = new u;
      else if (G === "p25519")
        v = new a;
      else
        throw new Error("Unknown prime " + G);
      return g[G] = v, v;
    };
    function n(_) {
      if (typeof _ === "string") {
        var G = W._prime(_);
        this.m = G.p, this.prime = G;
      } else
        H(_.gtn(1), "modulus must be greater than 1"), this.m = _, this.prime = null;
    }
    n.prototype._verify1 = function _(G) {
      H(G.negative === 0, "red works only with positives"), H(G.red, "red works only with red numbers");
    }, n.prototype._verify2 = function _(G, v) {
      H((G.negative | v.negative) === 0, "red works only with positives"), H(G.red && G.red === v.red, "red works only with red numbers");
    }, n.prototype.imod = function _(G) {
      if (this.prime)
        return this.prime.ireduce(G)._forceRed(this);
      return V(G, G.umod(this.m)._forceRed(this)), G;
    }, n.prototype.neg = function _(G) {
      if (G.isZero())
        return G.clone();
      return this.m.sub(G)._forceRed(this);
    }, n.prototype.add = function _(G, v) {
      this._verify2(G, v);
      var X = G.add(v);
      if (X.cmp(this.m) >= 0)
        X.isub(this.m);
      return X._forceRed(this);
    }, n.prototype.iadd = function _(G, v) {
      this._verify2(G, v);
      var X = G.iadd(v);
      if (X.cmp(this.m) >= 0)
        X.isub(this.m);
      return X;
    }, n.prototype.sub = function _(G, v) {
      this._verify2(G, v);
      var X = G.sub(v);
      if (X.cmpn(0) < 0)
        X.iadd(this.m);
      return X._forceRed(this);
    }, n.prototype.isub = function _(G, v) {
      this._verify2(G, v);
      var X = G.isub(v);
      if (X.cmpn(0) < 0)
        X.iadd(this.m);
      return X;
    }, n.prototype.shl = function _(G, v) {
      return this._verify1(G), this.imod(G.ushln(v));
    }, n.prototype.imul = function _(G, v) {
      return this._verify2(G, v), this.imod(G.imul(v));
    }, n.prototype.mul = function _(G, v) {
      return this._verify2(G, v), this.imod(G.mul(v));
    }, n.prototype.isqr = function _(G) {
      return this.imul(G, G.clone());
    }, n.prototype.sqr = function _(G) {
      return this.mul(G, G);
    }, n.prototype.sqrt = function _(G) {
      if (G.isZero())
        return G.clone();
      var v = this.m.andln(3);
      if (H(v % 2 === 1), v === 3) {
        var X = this.m.add(new W(1)).iushrn(2);
        return this.pow(G, X);
      }
      var D = this.m.subn(1), M = 0;
      while (!D.isZero() && D.andln(1) === 0)
        M++, D.iushrn(1);
      H(!D.isZero());
      var L = new W(1).toRed(this), S = L.redNeg(), R = this.m.subn(1).iushrn(1), F = this.m.bitLength();
      F = new W(2 * F * F).toRed(this);
      while (this.pow(F, R).cmp(S) !== 0)
        F.redIAdd(S);
      var E = this.pow(F, D), f = this.pow(G, D.addn(1).iushrn(1)), l = this.pow(G, D), p = M;
      while (l.cmp(L) !== 0) {
        var i = l;
        for (var D0 = 0;i.cmp(L) !== 0; D0++)
          i = i.redSqr();
        H(D0 < p);
        var Q0 = this.pow(E, new W(1).iushln(p - D0 - 1));
        f = f.redMul(Q0), E = Q0.redSqr(), l = l.redMul(E), p = D0;
      }
      return f;
    }, n.prototype.invm = function _(G) {
      var v = G._invmp(this.m);
      if (v.negative !== 0)
        return v.negative = 0, this.imod(v).redNeg();
      else
        return this.imod(v);
    }, n.prototype.pow = function _(G, v) {
      if (v.isZero())
        return new W(1).toRed(this);
      if (v.cmpn(1) === 0)
        return G.clone();
      var X = 4, D = new Array(1 << X);
      D[0] = new W(1).toRed(this), D[1] = G;
      for (var M = 2;M < D.length; M++)
        D[M] = this.mul(D[M - 1], G);
      var L = D[0], S = 0, R = 0, F = v.bitLength() % 26;
      if (F === 0)
        F = 26;
      for (M = v.length - 1;M >= 0; M--) {
        var E = v.words[M];
        for (var f = F - 1;f >= 0; f--) {
          var l = E >> f & 1;
          if (L !== D[0])
            L = this.sqr(L);
          if (l === 0 && S === 0) {
            R = 0;
            continue;
          }
          if (S <<= 1, S |= l, R++, R !== X && (M !== 0 || f !== 0))
            continue;
          L = this.mul(L, D[S]), R = 0, S = 0;
        }
        F = 26;
      }
      return L;
    }, n.prototype.convertTo = function _(G) {
      var v = G.umod(this.m);
      return v === G ? v.clone() : v;
    }, n.prototype.convertFrom = function _(G) {
      var v = G.clone();
      return v.red = null, v;
    }, W.mont = function _(G) {
      return new Z0(G);
    };
    function Z0(_) {
      if (n.call(this, _), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
        this.shift += 26 - this.shift % 26;
      this.r = new W(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    Q(Z0, n), Z0.prototype.convertTo = function _(G) {
      return this.imod(G.ushln(this.shift));
    }, Z0.prototype.convertFrom = function _(G) {
      var v = this.imod(G.mul(this.rinv));
      return v.red = null, v;
    }, Z0.prototype.imul = function _(G, v) {
      if (G.isZero() || v.isZero())
        return G.words[0] = 0, G.length = 1, G;
      var X = G.imul(v), D = X.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), M = X.isub(D).iushrn(this.shift), L = M;
      if (M.cmp(this.m) >= 0)
        L = M.isub(this.m);
      else if (M.cmpn(0) < 0)
        L = M.iadd(this.m);
      return L._forceRed(this);
    }, Z0.prototype.mul = function _(G, v) {
      if (G.isZero() || v.isZero())
        return new W(0)._forceRed(this);
      var X = G.mul(v), D = X.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), M = X.isub(D).iushrn(this.shift), L = M;
      if (M.cmp(this.m) >= 0)
        L = M.isub(this.m);
      else if (M.cmpn(0) < 0)
        L = M.iadd(this.m);
      return L._forceRed(this);
    }, Z0.prototype.invm = function _(G) {
      var v = this.imod(G._invmp(this.m).mul(this.r2));
      return v._forceRed(this);
    };
  })(typeof U6 === "undefined" || U6, zZ);
});
var EZ = t$((hZ, iQ) => {
  /*! decimal.js-light v2.5.1 https://github.com/MikeMcl/decimal.js-light/LICENCE */
  (function(J) {
    var $ = 1e9, H = { precision: 20, rounding: 4, toExpNeg: -7, toExpPos: 21, LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286" }, Q = true, W = "[DecimalError] ", Z = W + "Invalid argument: ", Y = W + "Exponent out of range: ", z = Math.floor, j = Math.pow, V = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, U, C = 1e7, q = 7, K = 9007199254740991, w2 = z(K / q), O = {};
    O.absoluteValue = O.abs = function() {
      var X = new this.constructor(this);
      if (X.s)
        X.s = 1;
      return X;
    }, O.comparedTo = O.cmp = function(X) {
      var D, M, L, S, R = this;
      if (X = new R.constructor(X), R.s !== X.s)
        return R.s || -X.s;
      if (R.e !== X.e)
        return R.e > X.e ^ R.s < 0 ? 1 : -1;
      L = R.d.length, S = X.d.length;
      for (D = 0, M = L < S ? L : S;D < M; ++D)
        if (R.d[D] !== X.d[D])
          return R.d[D] > X.d[D] ^ R.s < 0 ? 1 : -1;
      return L === S ? 0 : L > S ^ R.s < 0 ? 1 : -1;
    }, O.decimalPlaces = O.dp = function() {
      var X = this, D = X.d.length - 1, M = (D - X.e) * q;
      if (D = X.d[D], D)
        for (;D % 10 == 0; D /= 10)
          M--;
      return M < 0 ? 0 : M;
    }, O.dividedBy = O.div = function(X) {
      return x(this, new this.constructor(X));
    }, O.dividedToIntegerBy = O.idiv = function(X) {
      var D = this, M = D.constructor;
      return a(x(D, new M(X), 0, 1), M.precision);
    }, O.equals = O.eq = function(X) {
      return !this.cmp(X);
    }, O.exponent = function() {
      return g(this);
    }, O.greaterThan = O.gt = function(X) {
      return this.cmp(X) > 0;
    }, O.greaterThanOrEqualTo = O.gte = function(X) {
      return this.cmp(X) >= 0;
    }, O.isInteger = O.isint = function() {
      return this.e > this.d.length - 2;
    }, O.isNegative = O.isneg = function() {
      return this.s < 0;
    }, O.isPositive = O.ispos = function() {
      return this.s > 0;
    }, O.isZero = function() {
      return this.s === 0;
    }, O.lessThan = O.lt = function(X) {
      return this.cmp(X) < 0;
    }, O.lessThanOrEqualTo = O.lte = function(X) {
      return this.cmp(X) < 1;
    }, O.logarithm = O.log = function(X) {
      var D, M = this, L = M.constructor, S = L.precision, R = S + 5;
      if (X === undefined)
        X = new L(10);
      else if (X = new L(X), X.s < 1 || X.eq(U))
        throw Error(W + "NaN");
      if (M.s < 1)
        throw Error(W + (M.s ? "NaN" : "-Infinity"));
      if (M.eq(U))
        return new L(0);
      return Q = false, D = x(T(M, R), T(X, R), R), Q = true, a(D, S);
    }, O.minus = O.sub = function(X) {
      var D = this;
      return X = new D.constructor(X), D.s == X.s ? n(D, X) : h2(D, (X.s = -X.s, X));
    }, O.modulo = O.mod = function(X) {
      var D, M = this, L = M.constructor, S = L.precision;
      if (X = new L(X), !X.s)
        throw Error(W + "NaN");
      if (!M.s)
        return a(new L(M), S);
      return Q = false, D = x(M, X, 0, 1).times(X), Q = true, M.minus(D);
    }, O.naturalExponential = O.exp = function() {
      return k(this);
    }, O.naturalLogarithm = O.ln = function() {
      return T(this);
    }, O.negated = O.neg = function() {
      var X = new this.constructor(this);
      return X.s = -X.s || 0, X;
    }, O.plus = O.add = function(X) {
      var D = this;
      return X = new D.constructor(X), D.s == X.s ? h2(D, X) : n(D, (X.s = -X.s, X));
    }, O.precision = O.sd = function(X) {
      var D, M, L, S = this;
      if (X !== undefined && X !== !!X && X !== 1 && X !== 0)
        throw Error(Z + X);
      if (D = g(S) + 1, L = S.d.length - 1, M = L * q + 1, L = S.d[L], L) {
        for (;L % 10 == 0; L /= 10)
          M--;
        for (L = S.d[0];L >= 10; L /= 10)
          M++;
      }
      return X && D > M ? D : M;
    }, O.squareRoot = O.sqrt = function() {
      var X, D, M, L, S, R, F, E = this, f = E.constructor;
      if (E.s < 1) {
        if (!E.s)
          return new f(0);
        throw Error(W + "NaN");
      }
      if (X = g(E), Q = false, S = Math.sqrt(+E), S == 0 || S == Infinity) {
        if (D = N(E.d), (D.length + X) % 2 == 0)
          D += "0";
        if (S = Math.sqrt(D), X = z((X + 1) / 2) - (X < 0 || X % 2), S == Infinity)
          D = "5e" + X;
        else
          D = S.toExponential(), D = D.slice(0, D.indexOf("e") + 1) + X;
        L = new f(D);
      } else
        L = new f(S.toString());
      M = f.precision, S = F = M + 3;
      for (;; )
        if (R = L, L = R.plus(x(E, R, F + 2)).times(0.5), N(R.d).slice(0, F) === (D = N(L.d)).slice(0, F)) {
          if (D = D.slice(F - 3, F + 1), S == F && D == "4999") {
            if (a(R, M + 1, 0), R.times(R).eq(E)) {
              L = R;
              break;
            }
          } else if (D != "9999")
            break;
          F += 4;
        }
      return Q = true, a(L, M);
    }, O.times = O.mul = function(X) {
      var D, M, L, S, R, F, E, f, l, p = this, i = p.constructor, D0 = p.d, Q0 = (X = new i(X)).d;
      if (!p.s || !X.s)
        return new i(0);
      if (X.s *= p.s, M = p.e + X.e, f = D0.length, l = Q0.length, f < l)
        R = D0, D0 = Q0, Q0 = R, F = f, f = l, l = F;
      R = [], F = f + l;
      for (L = F;L--; )
        R.push(0);
      for (L = l;--L >= 0; ) {
        D = 0;
        for (S = f + L;S > L; )
          E = R[S] + Q0[L] * D0[S - L - 1] + D, R[S--] = E % C | 0, D = E / C | 0;
        R[S] = (R[S] + D) % C | 0;
      }
      for (;!R[--F]; )
        R.pop();
      if (D)
        ++M;
      else
        R.shift();
      return X.d = R, X.e = M, Q ? a(X, i.precision) : X;
    }, O.toDecimalPlaces = O.todp = function(X, D) {
      var M = this, L = M.constructor;
      if (M = new L(M), X === undefined)
        return M;
      if (b(X, 0, $), D === undefined)
        D = L.rounding;
      else
        b(D, 0, 8);
      return a(M, X + g(M) + 1, D);
    }, O.toExponential = function(X, D) {
      var M, L = this, S = L.constructor;
      if (X === undefined)
        M = Z0(L, true);
      else {
        if (b(X, 0, $), D === undefined)
          D = S.rounding;
        else
          b(D, 0, 8);
        L = a(new S(L), X + 1, D), M = Z0(L, true, X + 1);
      }
      return M;
    }, O.toFixed = function(X, D) {
      var M, L, S = this, R = S.constructor;
      if (X === undefined)
        return Z0(S);
      if (b(X, 0, $), D === undefined)
        D = R.rounding;
      else
        b(D, 0, 8);
      return L = a(new R(S), X + g(S) + 1, D), M = Z0(L.abs(), false, X + g(L) + 1), S.isneg() && !S.isZero() ? "-" + M : M;
    }, O.toInteger = O.toint = function() {
      var X = this, D = X.constructor;
      return a(new D(X), g(X) + 1, D.rounding);
    }, O.toNumber = function() {
      return +this;
    }, O.toPower = O.pow = function(X) {
      var D, M, L, S, R, F, E = this, f = E.constructor, l = 12, p = +(X = new f(X));
      if (!X.s)
        return new f(U);
      if (E = new f(E), !E.s) {
        if (X.s < 1)
          throw Error(W + "Infinity");
        return E;
      }
      if (E.eq(U))
        return E;
      if (L = f.precision, X.eq(U))
        return a(E, L);
      if (D = X.e, M = X.d.length - 1, F = D >= M, R = E.s, !F) {
        if (R < 0)
          throw Error(W + "NaN");
      } else if ((M = p < 0 ? -p : p) <= K) {
        S = new f(U), D = Math.ceil(L / q + 4), Q = false;
        for (;; ) {
          if (M % 2)
            S = S.times(E), _(S.d, D);
          if (M = z(M / 2), M === 0)
            break;
          E = E.times(E), _(E.d, D);
        }
        return Q = true, X.s < 0 ? new f(U).div(S) : a(S, L);
      }
      return R = R < 0 && X.d[Math.max(D, M)] & 1 ? -1 : 1, E.s = 1, Q = false, S = X.times(T(E, L + l)), Q = true, S = k(S), S.s = R, S;
    }, O.toPrecision = function(X, D) {
      var M, L, S = this, R = S.constructor;
      if (X === undefined)
        M = g(S), L = Z0(S, M <= R.toExpNeg || M >= R.toExpPos);
      else {
        if (b(X, 1, $), D === undefined)
          D = R.rounding;
        else
          b(D, 0, 8);
        S = a(new R(S), X, D), M = g(S), L = Z0(S, X <= M || M <= R.toExpNeg, X);
      }
      return L;
    }, O.toSignificantDigits = O.tosd = function(X, D) {
      var M = this, L = M.constructor;
      if (X === undefined)
        X = L.precision, D = L.rounding;
      else if (b(X, 1, $), D === undefined)
        D = L.rounding;
      else
        b(D, 0, 8);
      return a(new L(M), X, D);
    }, O.toString = O.valueOf = O.val = O.toJSON = function() {
      var X = this, D = g(X), M = X.constructor;
      return Z0(X, D <= M.toExpNeg || D >= M.toExpPos);
    };
    function h2(X, D) {
      var M, L, S, R, F, E, f, l, p = X.constructor, i = p.precision;
      if (!X.s || !D.s) {
        if (!D.s)
          D = new p(X);
        return Q ? a(D, i) : D;
      }
      if (f = X.d, l = D.d, F = X.e, S = D.e, f = f.slice(), R = F - S, R) {
        if (R < 0)
          L = f, R = -R, E = l.length;
        else
          L = l, S = F, E = f.length;
        if (F = Math.ceil(i / q), E = F > E ? F + 1 : E + 1, R > E)
          R = E, L.length = 1;
        L.reverse();
        for (;R--; )
          L.push(0);
        L.reverse();
      }
      if (E = f.length, R = l.length, E - R < 0)
        R = E, L = l, l = f, f = L;
      for (M = 0;R; )
        M = (f[--R] = f[R] + l[R] + M) / C | 0, f[R] %= C;
      if (M)
        f.unshift(M), ++S;
      for (E = f.length;f[--E] == 0; )
        f.pop();
      return D.d = f, D.e = S, Q ? a(D, i) : D;
    }
    function b(X, D, M) {
      if (X !== ~~X || X < D || X > M)
        throw Error(Z + X);
    }
    function N(X) {
      var D, M, L, S = X.length - 1, R = "", F = X[0];
      if (S > 0) {
        R += F;
        for (D = 1;D < S; D++) {
          if (L = X[D] + "", M = q - L.length, M)
            R += I(M);
          R += L;
        }
        if (F = X[D], L = F + "", M = q - L.length, M)
          R += I(M);
      } else if (F === 0)
        return "0";
      for (;F % 10 === 0; )
        F /= 10;
      return R + F;
    }
    var x = function() {
      function X(L, S) {
        var R, F = 0, E = L.length;
        for (L = L.slice();E--; )
          R = L[E] * S + F, L[E] = R % C | 0, F = R / C | 0;
        if (F)
          L.unshift(F);
        return L;
      }
      function D(L, S, R, F) {
        var E, f;
        if (R != F)
          f = R > F ? 1 : -1;
        else
          for (E = f = 0;E < R; E++)
            if (L[E] != S[E]) {
              f = L[E] > S[E] ? 1 : -1;
              break;
            }
        return f;
      }
      function M(L, S, R) {
        var F = 0;
        for (;R--; )
          L[R] -= F, F = L[R] < S[R] ? 1 : 0, L[R] = F * C + L[R] - S[R];
        for (;!L[0] && L.length > 1; )
          L.shift();
      }
      return function(L, S, R, F) {
        var E, f, l, p, i, D0, Q0, fJ, Y0, q0, n$, N0, s0, e$, l0, a0, iJ, u0, c0 = L.constructor, UQ = L.s == S.s ? 1 : -1, b0 = L.d, R0 = S.d;
        if (!L.s)
          return new c0(L);
        if (!S.s)
          throw Error(W + "Division by zero");
        f = L.e - S.e, iJ = R0.length, l0 = b0.length, Q0 = new c0(UQ), fJ = Q0.d = [];
        for (l = 0;R0[l] == (b0[l] || 0); )
          ++l;
        if (R0[l] > (b0[l] || 0))
          --f;
        if (R == null)
          N0 = R = c0.precision;
        else if (F)
          N0 = R + (g(L) - g(S)) + 1;
        else
          N0 = R;
        if (N0 < 0)
          return new c0(0);
        if (N0 = N0 / q + 2 | 0, l = 0, iJ == 1) {
          p = 0, R0 = R0[0], N0++;
          for (;(l < l0 || p) && N0--; l++)
            s0 = p * C + (b0[l] || 0), fJ[l] = s0 / R0 | 0, p = s0 % R0 | 0;
        } else {
          if (p = C / (R0[0] + 1) | 0, p > 1)
            R0 = X(R0, p), b0 = X(b0, p), iJ = R0.length, l0 = b0.length;
          e$ = iJ, Y0 = b0.slice(0, iJ), q0 = Y0.length;
          for (;q0 < iJ; )
            Y0[q0++] = 0;
          if (u0 = R0.slice(), u0.unshift(0), a0 = R0[0], R0[1] >= C / 2)
            ++a0;
          do {
            if (p = 0, E = D(R0, Y0, iJ, q0), E < 0) {
              if (n$ = Y0[0], iJ != q0)
                n$ = n$ * C + (Y0[1] || 0);
              if (p = n$ / a0 | 0, p > 1) {
                if (p >= C)
                  p = C - 1;
                if (i = X(R0, p), D0 = i.length, q0 = Y0.length, E = D(i, Y0, D0, q0), E == 1)
                  p--, M(i, iJ < D0 ? u0 : R0, D0);
              } else {
                if (p == 0)
                  E = p = 1;
                i = R0.slice();
              }
              if (D0 = i.length, D0 < q0)
                i.unshift(0);
              if (M(Y0, i, q0), E == -1) {
                if (q0 = Y0.length, E = D(R0, Y0, iJ, q0), E < 1)
                  p++, M(Y0, iJ < q0 ? u0 : R0, q0);
              }
              q0 = Y0.length;
            } else if (E === 0)
              p++, Y0 = [0];
            if (fJ[l++] = p, E && Y0[0])
              Y0[q0++] = b0[e$] || 0;
            else
              Y0 = [b0[e$]], q0 = 1;
          } while ((e$++ < l0 || Y0[0] !== undefined) && N0--);
        }
        if (!fJ[0])
          fJ.shift();
        return Q0.e = f, a(Q0, F ? R + g(Q0) + 1 : R);
      };
    }();
    function k(X, D) {
      var M, L, S, R, F, E, f = 0, l = 0, p = X.constructor, i = p.precision;
      if (g(X) > 16)
        throw Error(Y + g(X));
      if (!X.s)
        return new p(U);
      if (D == null)
        Q = false, E = i;
      else
        E = D;
      F = new p(0.03125);
      while (X.abs().gte(0.1))
        X = X.times(F), l += 5;
      L = Math.log(j(2, l)) / Math.LN10 * 2 + 5 | 0, E += L, M = S = R = new p(U), p.precision = E;
      for (;; ) {
        if (S = a(S.times(X), E), M = M.times(++f), F = R.plus(x(S, M, E)), N(F.d).slice(0, E) === N(R.d).slice(0, E)) {
          while (l--)
            R = a(R.times(R), E);
          return p.precision = i, D == null ? (Q = true, a(R, i)) : R;
        }
        R = F;
      }
    }
    function g(X) {
      var D = X.e * q, M = X.d[0];
      for (;M >= 10; M /= 10)
        D++;
      return D;
    }
    function A(X, D, M) {
      if (D > X.LN10.sd()) {
        if (Q = true, M)
          X.precision = M;
        throw Error(W + "LN10 precision limit exceeded");
      }
      return a(new X(X.LN10), D);
    }
    function I(X) {
      var D = "";
      for (;X--; )
        D += "0";
      return D;
    }
    function T(X, D) {
      var M, L, S, R, F, E, f, l, p, i = 1, D0 = 10, Q0 = X, fJ = Q0.d, Y0 = Q0.constructor, q0 = Y0.precision;
      if (Q0.s < 1)
        throw Error(W + (Q0.s ? "NaN" : "-Infinity"));
      if (Q0.eq(U))
        return new Y0(0);
      if (D == null)
        Q = false, l = q0;
      else
        l = D;
      if (Q0.eq(10)) {
        if (D == null)
          Q = true;
        return A(Y0, l);
      }
      if (l += D0, Y0.precision = l, M = N(fJ), L = M.charAt(0), R = g(Q0), Math.abs(R) < 1500000000000000) {
        while (L < 7 && L != 1 || L == 1 && M.charAt(1) > 3)
          Q0 = Q0.times(X), M = N(Q0.d), L = M.charAt(0), i++;
        if (R = g(Q0), L > 1)
          Q0 = new Y0("0." + M), R++;
        else
          Q0 = new Y0(L + "." + M.slice(1));
      } else
        return f = A(Y0, l + 2, q0).times(R + ""), Q0 = T(new Y0(L + "." + M.slice(1)), l - D0).plus(f), Y0.precision = q0, D == null ? (Q = true, a(Q0, q0)) : Q0;
      E = F = Q0 = x(Q0.minus(U), Q0.plus(U), l), p = a(Q0.times(Q0), l), S = 3;
      for (;; ) {
        if (F = a(F.times(p), l), f = E.plus(x(F, new Y0(S), l)), N(f.d).slice(0, l) === N(E.d).slice(0, l)) {
          if (E = E.times(2), R !== 0)
            E = E.plus(A(Y0, l + 2, q0).times(R + ""));
          return E = x(E, new Y0(i), l), Y0.precision = q0, D == null ? (Q = true, a(E, q0)) : E;
        }
        E = f, S += 2;
      }
    }
    function u(X, D) {
      var M, L, S;
      if ((M = D.indexOf(".")) > -1)
        D = D.replace(".", "");
      if ((L = D.search(/e/i)) > 0) {
        if (M < 0)
          M = L;
        M += +D.slice(L + 1), D = D.substring(0, L);
      } else if (M < 0)
        M = D.length;
      for (L = 0;D.charCodeAt(L) === 48; )
        ++L;
      for (S = D.length;D.charCodeAt(S - 1) === 48; )
        --S;
      if (D = D.slice(L, S), D) {
        if (S -= L, M = M - L - 1, X.e = z(M / q), X.d = [], L = (M + 1) % q, M < 0)
          L += q;
        if (L < S) {
          if (L)
            X.d.push(+D.slice(0, L));
          for (S -= q;L < S; )
            X.d.push(+D.slice(L, L += q));
          D = D.slice(L), L = q - D.length;
        } else
          L -= S;
        for (;L--; )
          D += "0";
        if (X.d.push(+D), Q && (X.e > w2 || X.e < -w2))
          throw Error(Y + M);
      } else
        X.s = 0, X.e = 0, X.d = [0];
      return X;
    }
    function a(X, D, M) {
      var L, S, R, F, E, f, l, p, i = X.d;
      for (F = 1, R = i[0];R >= 10; R /= 10)
        F++;
      if (L = D - F, L < 0)
        L += q, S = D, l = i[p = 0];
      else {
        if (p = Math.ceil((L + 1) / q), R = i.length, p >= R)
          return X;
        l = R = i[p];
        for (F = 1;R >= 10; R /= 10)
          F++;
        L %= q, S = L - q + F;
      }
      if (M !== undefined)
        R = j(10, F - S - 1), E = l / R % 10 | 0, f = D < 0 || i[p + 1] !== undefined || l % R, f = M < 4 ? (E || f) && (M == 0 || M == (X.s < 0 ? 3 : 2)) : E > 5 || E == 5 && (M == 4 || f || M == 6 && (L > 0 ? S > 0 ? l / j(10, F - S) : 0 : i[p - 1]) % 10 & 1 || M == (X.s < 0 ? 8 : 7));
      if (D < 1 || !i[0]) {
        if (f)
          R = g(X), i.length = 1, D = D - R - 1, i[0] = j(10, (q - D % q) % q), X.e = z(-D / q) || 0;
        else
          i.length = 1, i[0] = X.e = X.s = 0;
        return X;
      }
      if (L == 0)
        i.length = p, R = 1, p--;
      else
        i.length = p + 1, R = j(10, q - L), i[p] = S > 0 ? (l / j(10, F - S) % j(10, S) | 0) * R : 0;
      if (f)
        for (;; )
          if (p == 0) {
            if ((i[0] += R) == C)
              i[0] = 1, ++X.e;
            break;
          } else {
            if (i[p] += R, i[p] != C)
              break;
            i[p--] = 0, R = 1;
          }
      for (L = i.length;i[--L] === 0; )
        i.pop();
      if (Q && (X.e > w2 || X.e < -w2))
        throw Error(Y + g(X));
      return X;
    }
    function n(X, D) {
      var M, L, S, R, F, E, f, l, p, i, D0 = X.constructor, Q0 = D0.precision;
      if (!X.s || !D.s) {
        if (D.s)
          D.s = -D.s;
        else
          D = new D0(X);
        return Q ? a(D, Q0) : D;
      }
      if (f = X.d, i = D.d, L = D.e, l = X.e, f = f.slice(), F = l - L, F) {
        if (p = F < 0, p)
          M = f, F = -F, E = i.length;
        else
          M = i, L = l, E = f.length;
        if (S = Math.max(Math.ceil(Q0 / q), E) + 2, F > S)
          F = S, M.length = 1;
        M.reverse();
        for (S = F;S--; )
          M.push(0);
        M.reverse();
      } else {
        if (S = f.length, E = i.length, p = S < E, p)
          E = S;
        for (S = 0;S < E; S++)
          if (f[S] != i[S]) {
            p = f[S] < i[S];
            break;
          }
        F = 0;
      }
      if (p)
        M = f, f = i, i = M, D.s = -D.s;
      E = f.length;
      for (S = i.length - E;S > 0; --S)
        f[E++] = 0;
      for (S = i.length;S > F; ) {
        if (f[--S] < i[S]) {
          for (R = S;R && f[--R] === 0; )
            f[R] = C - 1;
          --f[R], f[S] += C;
        }
        f[S] -= i[S];
      }
      for (;f[--E] === 0; )
        f.pop();
      for (;f[0] === 0; f.shift())
        --L;
      if (!f[0])
        return new D0(0);
      return D.d = f, D.e = L, Q ? a(D, Q0) : D;
    }
    function Z0(X, D, M) {
      var L, S = g(X), R = N(X.d), F = R.length;
      if (D) {
        if (M && (L = M - F) > 0)
          R = R.charAt(0) + "." + R.slice(1) + I(L);
        else if (F > 1)
          R = R.charAt(0) + "." + R.slice(1);
        R = R + (S < 0 ? "e" : "e+") + S;
      } else if (S < 0) {
        if (R = "0." + I(-S - 1) + R, M && (L = M - F) > 0)
          R += I(L);
      } else if (S >= F) {
        if (R += I(S + 1 - F), M && (L = M - S - 1) > 0)
          R = R + "." + I(L);
      } else {
        if ((L = S + 1) < F)
          R = R.slice(0, L) + "." + R.slice(L);
        if (M && (L = M - F) > 0) {
          if (S + 1 === F)
            R += ".";
          R += I(L);
        }
      }
      return X.s < 0 ? "-" + R : R;
    }
    function _(X, D) {
      if (X.length > D)
        return X.length = D, true;
    }
    function G(X) {
      var D, M, L;
      function S(R) {
        var F = this;
        if (!(F instanceof S))
          return new S(R);
        if (F.constructor = S, R instanceof S) {
          F.s = R.s, F.e = R.e, F.d = (R = R.d) ? R.slice() : R;
          return;
        }
        if (typeof R === "number") {
          if (R * 0 !== 0)
            throw Error(Z + R);
          if (R > 0)
            F.s = 1;
          else if (R < 0)
            R = -R, F.s = -1;
          else {
            F.s = 0, F.e = 0, F.d = [0];
            return;
          }
          if (R === ~~R && R < 1e7) {
            F.e = 0, F.d = [R];
            return;
          }
          return u(F, R.toString());
        } else if (typeof R !== "string")
          throw Error(Z + R);
        if (R.charCodeAt(0) === 45)
          R = R.slice(1), F.s = -1;
        else
          F.s = 1;
        if (V.test(R))
          u(F, R);
        else
          throw Error(Z + R);
      }
      if (S.prototype = O, S.ROUND_UP = 0, S.ROUND_DOWN = 1, S.ROUND_CEIL = 2, S.ROUND_FLOOR = 3, S.ROUND_HALF_UP = 4, S.ROUND_HALF_DOWN = 5, S.ROUND_HALF_EVEN = 6, S.ROUND_HALF_CEIL = 7, S.ROUND_HALF_FLOOR = 8, S.clone = G, S.config = S.set = v, X === undefined)
        X = {};
      if (X) {
        L = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
        for (D = 0;D < L.length; )
          if (!X.hasOwnProperty(M = L[D++]))
            X[M] = this[M];
      }
      return S.config(X), S;
    }
    function v(X) {
      if (!X || typeof X !== "object")
        throw Error(W + "Object expected");
      var D, M, L, S = ["precision", 1, $, "rounding", 0, 8, "toExpNeg", (-Infinity), 0, "toExpPos", 0, Infinity];
      for (D = 0;D < S.length; D += 3)
        if ((L = X[M = S[D]]) !== undefined)
          if (z(L) === L && L >= S[D + 1] && L <= S[D + 2])
            this[M] = L;
          else
            throw Error(Z + M + ": " + L);
      if ((L = X[M = "LN10"]) !== undefined)
        if (L == Math.LN10)
          this[M] = new this(L);
        else
          throw Error(Z + M + ": " + L);
      return this;
    }
    if (H = G(H), H.default = H.Decimal = H, U = new H(1), typeof define == "function" && define.amd)
      define(function() {
        return H;
      });
    else if (typeof iQ != "undefined" && hZ)
      iQ.exports = H;
    else {
      if (!J)
        J = typeof self != "undefined" && self && self.self == self ? self : Function("return this")();
      J.Decimal = H;
    }
  })(hZ);
});
var SZ = t$((NG, rQ) => {
  var _z = function(J) {
    return J.prototype.toFormat = function $(H, Q, W) {
      if (!this.e && this.e !== 0)
        return this.toString();
      var Z, Y, z, j, V, U, C, q, K, w2, O, h2, b, N, x, k = this.format || {}, g = this.constructor.format || {};
      if (H != V)
        if (typeof H == "object")
          W = H, H = V;
        else if (Q != V) {
          if (typeof Q == "object")
            W = Q, Q = V;
          else if (typeof W != "object")
            W = {};
        } else
          W = {};
      else
        W = {};
      if (Z = this.toFixed(H, Q).split("."), q = Z[0], K = Z[1], C = this.s < 0 ? q.slice(1) : q, U = C.length, w2 = W.decimalSeparator, w2 == V) {
        if (w2 = k.decimalSeparator, w2 == V) {
          if (w2 = g.decimalSeparator, w2 == V)
            w2 = ".";
        }
      }
      if (O = W.groupSeparator, O == V) {
        if (O = k.groupSeparator, O == V)
          O = g.groupSeparator;
      }
      if (O) {
        if (h2 = W.groupSize, h2 == V) {
          if (h2 = k.groupSize, h2 == V) {
            if (h2 = g.groupSize, h2 == V)
              h2 = 0;
          }
        }
        if (b = W.secondaryGroupSize, b == V) {
          if (b = k.secondaryGroupSize, b == V) {
            if (b = g.secondaryGroupSize, b == V)
              b = 0;
          }
        }
        if (b)
          Y = +b, z = +h2, U -= z;
        else
          Y = +h2, z = +b;
        if (Y > 0 && U > 0) {
          j = U % Y || Y, q = C.substr(0, j);
          for (;j < U; j += Y)
            q += O + C.substr(j, Y);
          if (z > 0)
            q += O + C.slice(j);
          if (this.s < 0)
            q = "-" + q;
        }
      }
      if (K) {
        if (N = W.fractionGroupSeparator, N == V) {
          if (N = k.fractionGroupSeparator, N == V)
            N = g.fractionGroupSeparator;
        }
        if (N) {
          if (x = W.fractionGroupSize, x == V) {
            if (x = k.fractionGroupSize, x == V) {
              if (x = g.fractionGroupSize, x == V)
                x = 0;
            }
          }
          if (x = +x, x)
            K = K.replace(new RegExp("\\d{" + x + "}\\B", "g"), "$&" + N);
        }
        return q + w2 + K;
      } else
        return q;
    }, J.format = { decimalSeparator: ".", groupSeparator: ",", groupSize: 3, secondaryGroupSize: 0, fractionGroupSeparator: "", fractionGroupSize: 0 }, J;
  };
  if (typeof rQ !== "undefined" && NG)
    rQ.exports = _z;
});
var m2 = new $PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var W$ = new $PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
var tJ = new $PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var kj = new $PublicKey("So11111111111111111111111111111111111111112");
var xj = new $PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
var JH = (J) => {
  const $ = J.decode.bind(J), H = J.encode.bind(J);
  return { decode: $, encode: H };
};
var W6 = E0(pJ(), 1);
var f$ = E0(PW(), 1);
var EQ = (J) => ($) => {
  const H = W6.blob(J, $), { encode: Q, decode: W } = JH(H), Z = H;
  return Z.decode = (Y, z) => {
    const j = W(Y, z);
    return f$.toBigIntLE(Buffer.from(j));
  }, Z.encode = (Y, z, j) => {
    const V = f$.toBufferLE(Y, J);
    return Q(V, z, j);
  }, Z;
};
var SQ = (J) => ($) => {
  const H = W6.blob(J, $), { encode: Q, decode: W } = JH(H), Z = H;
  return Z.decode = (Y, z) => {
    const j = W(Y, z);
    return f$.toBigIntBE(Buffer.from(j));
  }, Z.encode = (Y, z, j) => {
    const V = f$.toBufferBE(Y, J);
    return Q(V, z, j);
  }, Z;
};
var lJ = EQ(8);
var lj = SQ(8);
var uj = EQ(16);
var cj = SQ(16);
var sj = EQ(24);
var aj = SQ(24);
var ij = EQ(32);
var rj = SQ(32);
var NW = E0(pJ(), 1);
var wQ = (J) => {
  const $ = NW.u8(J), { encode: H, decode: Q } = JH($), W = $;
  return W.decode = (Z, Y) => {
    return !!Q(Z, Y);
  }, W.encode = (Z, Y, z) => {
    const j = Number(Z);
    return H(j, Y, z);
  }, W;
};
var gW = E0(pJ(), 1);
var d0 = (J) => {
  const $ = gW.blob(32, J), { encode: H, decode: Q } = JH($), W = $;
  return W.decode = (Z, Y) => {
    const z = Q(Z, Y);
    return new $PublicKey(z);
  }, W.encode = (Z, Y, z) => {
    const j = Z.toBuffer();
    return H(j, Y, z);
  }, W;
};

class $H extends Error {
  constructor(J) {
    super(J);
  }
}

class HH extends $H {
  constructor() {
    super(...arguments);
    this.name = "TokenAccountNotFoundError";
  }
}

class Z6 extends $H {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountError";
  }
}

class QH extends $H {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountOwnerError";
  }
}

class y$ extends $H {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountSizeError";
  }
}

class Y6 extends $H {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidMintError";
  }
}

class z6 extends $H {
  constructor() {
    super(...arguments);
    this.name = "TokenOwnerOffCurveError";
  }
}
var rJ;
(function(J) {
  J[J.InitializeMint = 0] = "InitializeMint", J[J.InitializeAccount = 1] = "InitializeAccount", J[J.InitializeMultisig = 2] = "InitializeMultisig", J[J.Transfer = 3] = "Transfer", J[J.Approve = 4] = "Approve", J[J.Revoke = 5] = "Revoke", J[J.SetAuthority = 6] = "SetAuthority", J[J.MintTo = 7] = "MintTo", J[J.Burn = 8] = "Burn", J[J.CloseAccount = 9] = "CloseAccount", J[J.FreezeAccount = 10] = "FreezeAccount", J[J.ThawAccount = 11] = "ThawAccount", J[J.TransferChecked = 12] = "TransferChecked", J[J.ApproveChecked = 13] = "ApproveChecked", J[J.MintToChecked = 14] = "MintToChecked", J[J.BurnChecked = 15] = "BurnChecked", J[J.InitializeAccount2 = 16] = "InitializeAccount2", J[J.SyncNative = 17] = "SyncNative", J[J.InitializeAccount3 = 18] = "InitializeAccount3", J[J.InitializeMultisig2 = 19] = "InitializeMultisig2", J[J.InitializeMint2 = 20] = "InitializeMint2", J[J.GetAccountDataSize = 21] = "GetAccountDataSize", J[J.InitializeImmutableOwner = 22] = "InitializeImmutableOwner", J[J.AmountToUiAmount = 23] = "AmountToUiAmount", J[J.UiAmountToAmount = 24] = "UiAmountToAmount", J[J.InitializeMintCloseAuthority = 25] = "InitializeMintCloseAuthority", J[J.TransferFeeExtension = 26] = "TransferFeeExtension", J[J.ConfidentialTransferExtension = 27] = "ConfidentialTransferExtension", J[J.DefaultAccountStateExtension = 28] = "DefaultAccountStateExtension", J[J.Reallocate = 29] = "Reallocate", J[J.MemoTransferExtension = 30] = "MemoTransferExtension", J[J.CreateNativeMint = 31] = "CreateNativeMint", J[J.InitializeNonTransferableMint = 32] = "InitializeNonTransferableMint", J[J.InterestBearingMintExtension = 33] = "InterestBearingMintExtension", J[J.CpiGuardExtension = 34] = "CpiGuardExtension", J[J.InitializePermanentDelegate = 35] = "InitializePermanentDelegate", J[J.TransferHookExtension = 36] = "TransferHookExtension", J[J.MetadataPointerExtension = 39] = "MetadataPointerExtension";
})(rJ || (rJ = {}));
var bQ = E0(pJ(), 1);
var kW = bQ.struct([bQ.u8("instruction")]);
var I$ = E0(pJ(), 1);
var LH;
(function(J) {
  J[J.Uninitialized = 0] = "Uninitialized", J[J.Mint = 1] = "Mint", J[J.Account = 2] = "Account";
})(LH || (LH = {}));
var PQ = 1;
var lH = E0(pJ(), 1);
var y4 = lH.struct([lH.u8("m"), lH.u8("n"), wQ("isInitialized"), d0("signer1"), d0("signer2"), d0("signer3"), d0("signer4"), d0("signer5"), d0("signer6"), d0("signer7"), d0("signer8"), d0("signer9"), d0("signer10"), d0("signer11")]);
var NQ = y4.span;
var gQ;
(function(J) {
  J[J.Uninitialized = 0] = "Uninitialized", J[J.Initialized = 1] = "Initialized", J[J.Frozen = 2] = "Frozen";
})(gQ || (gQ = {}));
var _$ = I$.struct([d0("mint"), d0("owner"), lJ("amount"), I$.u32("delegateOption"), d0("delegate"), I$.u8("state"), I$.u32("isNativeOption"), lJ("isNative"), lJ("delegatedAmount"), I$.u32("closeAuthorityOption"), d0("closeAuthority")]);
var b$ = _$.span;
var WH = E0(pJ(), 1);
var TW = WH.struct([WH.u32("mintAuthorityOption"), d0("mintAuthority"), lJ("supply"), WH.u8("decimals"), wQ("isInitialized"), WH.u32("freezeAuthorityOption"), d0("freezeAuthority")]);
var j6 = TW.span;
var KH = E0(pJ(), 1);
var m4 = 1e4;
var P2 = BigInt(m4);
var IW = KH.struct([d0("transferFeeConfigAuthority"), d0("withdrawWithheldAuthority"), lJ("withheldAmount"), yW("olderTransferFee"), yW("newerTransferFee")]);
var N2 = IW.span;
var d4 = KH.struct([lJ("withheldAmount")]);
var g2 = d4.span;
var pW = function(J) {
  return J + lW + p4;
};
var xQ;
(function(J) {
  J[J.Uninitialized = 0] = "Uninitialized", J[J.TransferFeeConfig = 1] = "TransferFeeConfig", J[J.TransferFeeAmount = 2] = "TransferFeeAmount", J[J.MintCloseAuthority = 3] = "MintCloseAuthority", J[J.ConfidentialTransferMint = 4] = "ConfidentialTransferMint", J[J.ConfidentialTransferAccount = 5] = "ConfidentialTransferAccount", J[J.DefaultAccountState = 6] = "DefaultAccountState", J[J.ImmutableOwner = 7] = "ImmutableOwner", J[J.MemoTransfer = 8] = "MemoTransfer", J[J.NonTransferable = 9] = "NonTransferable", J[J.InterestBearingConfig = 10] = "InterestBearingConfig", J[J.CpiGuard = 11] = "CpiGuard", J[J.PermanentDelegate = 12] = "PermanentDelegate", J[J.NonTransferableAccount = 13] = "NonTransferableAccount", J[J.TransferHook = 14] = "TransferHook", J[J.TransferHookAccount = 15] = "TransferHookAccount", J[J.MetadataPointer = 18] = "MetadataPointer", J[J.TokenMetadata = 19] = "TokenMetadata";
})(xQ || (xQ = {}));
var lW = 2;
var p4 = 2;
var AQ = E0(pJ(), 1);
var uW = AQ.struct([AQ.u8("instruction")]);
var a4 = function(J, $, H, Q, W, Z = m2, Y = tJ) {
  const z = [{ pubkey: J, isSigner: true, isWritable: true }, { pubkey: $, isSigner: false, isWritable: true }, { pubkey: H, isSigner: false, isWritable: false }, { pubkey: Q, isSigner: false, isWritable: false }, { pubkey: $SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: Z, isSigner: false, isWritable: false }];
  return new $TransactionInstruction({ keys: z, programId: Y, data: W });
};
var fQ = E0(pJ(), 1);
var sW = fQ.struct([fQ.u8("instruction")]);
var yQ = E0(pJ(), 1);
var iW = yQ.struct([yQ.u8("instruction"), lJ("amount")]);
var IQ = E0(pJ(), 1);
var nW = IQ.struct([IQ.u8("instruction"), lJ("amount")]);
var hH = E0(pJ(), 1);
var tW = hH.struct([hH.u8("instruction"), hH.u8("decimals"), d0("mintAuthority"), hH.u8("freezeAuthorityOption"), d0("freezeAuthority")]);
var Jz = function(J) {
  return J instanceof Uint8Array || J != null && typeof J === "object" && J.constructor.name === "Uint8Array";
};
var $z = function(J, ...$) {
  if (!Jz(J))
    throw new Error("Expected Uint8Array");
  if ($.length > 0 && !$.includes(J.length))
    throw new Error(`Expected Uint8Array of length ${$}, not of length=${J.length}`);
};
var V6 = function(J, $ = true) {
  if (J.destroyed)
    throw new Error("Hash instance has been destroyed");
  if ($ && J.finished)
    throw new Error("Hash#digest() has already been called");
};
var JZ = function(J, $) {
  $z(J);
  const H = $.outputLen;
  if (J.length < H)
    throw new Error(`digestInto() expects output buffer of length at least ${H}`);
};
var Hz = function(J) {
  return J instanceof Uint8Array || J != null && typeof J === "object" && J.constructor.name === "Uint8Array";
};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var mQ = (J) => new DataView(J.buffer, J.byteOffset, J.byteLength);
var j$ = (J, $) => J << 32 - $ | J >>> $;
var Qz = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Qz)
  throw new Error("Non little-endian hardware is not supported");

class F6 {
  clone() {
    return this._cloneInto();
  }
}
var GV = {}.toString;
var Zz = function(J, $, H, Q) {
  if (typeof J.setBigUint64 === "function")
    return J.setBigUint64($, H, Q);
  const W = BigInt(32), Z = BigInt(4294967295), Y = Number(H >> W & Z), z = Number(H & Z), j = Q ? 4 : 0, V = Q ? 0 : 4;
  J.setUint32($ + j, Y, Q), J.setUint32($ + V, z, Q);
};

class X6 extends F6 {
  constructor(J, $, H, Q) {
    super();
    this.blockLen = J, this.outputLen = $, this.padOffset = H, this.isLE = Q, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(J), this.view = mQ(this.buffer);
  }
  update(J) {
    V6(this);
    const { view: $, buffer: H, blockLen: Q } = this;
    J = G6(J);
    const W = J.length;
    for (let Z = 0;Z < W; ) {
      const Y = Math.min(Q - this.pos, W - Z);
      if (Y === Q) {
        const z = mQ(J);
        for (;Q <= W - Z; Z += Q)
          this.process(z, Z);
        continue;
      }
      if (H.set(J.subarray(Z, Z + Y), this.pos), this.pos += Y, Z += Y, this.pos === Q)
        this.process($, 0), this.pos = 0;
    }
    return this.length += J.length, this.roundClean(), this;
  }
  digestInto(J) {
    V6(this), JZ(J, this), this.finished = true;
    const { buffer: $, view: H, blockLen: Q, isLE: W } = this;
    let { pos: Z } = this;
    if ($[Z++] = 128, this.buffer.subarray(Z).fill(0), this.padOffset > Q - Z)
      this.process(H, 0), Z = 0;
    for (let U = Z;U < Q; U++)
      $[U] = 0;
    Zz(H, Q - 8, BigInt(this.length * 8), W), this.process(H, 0);
    const Y = mQ(J), z = this.outputLen;
    if (z % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const j = z / 4, V = this.get();
    if (j > V.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let U = 0;U < j; U++)
      Y.setUint32(4 * U, V[U], W);
  }
  digest() {
    const { buffer: J, outputLen: $ } = this;
    this.digestInto(J);
    const H = J.slice(0, $);
    return this.destroy(), H;
  }
  _cloneInto(J) {
    J || (J = new this.constructor), J.set(...this.get());
    const { blockLen: $, buffer: H, length: Q, finished: W, destroyed: Z, pos: Y } = this;
    if (J.length = Q, J.pos = Y, J.finished = W, J.destroyed = Z, Q % $)
      J.buffer.set(H);
    return J;
  }
}
var Yz = (J, $, H) => J & $ ^ ~J & H;
var zz = (J, $, H) => J & $ ^ J & H ^ $ & H;
var jz = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var m$ = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var d$ = new Uint32Array(64);

class HZ extends X6 {
  constructor() {
    super(64, 32, 8, false);
    this.A = m$[0] | 0, this.B = m$[1] | 0, this.C = m$[2] | 0, this.D = m$[3] | 0, this.E = m$[4] | 0, this.F = m$[5] | 0, this.G = m$[6] | 0, this.H = m$[7] | 0;
  }
  get() {
    const { A: J, B: $, C: H, D: Q, E: W, F: Z, G: Y, H: z } = this;
    return [J, $, H, Q, W, Z, Y, z];
  }
  set(J, $, H, Q, W, Z, Y, z) {
    this.A = J | 0, this.B = $ | 0, this.C = H | 0, this.D = Q | 0, this.E = W | 0, this.F = Z | 0, this.G = Y | 0, this.H = z | 0;
  }
  process(J, $) {
    for (let U = 0;U < 16; U++, $ += 4)
      d$[U] = J.getUint32($, false);
    for (let U = 16;U < 64; U++) {
      const C = d$[U - 15], q = d$[U - 2], K = j$(C, 7) ^ j$(C, 18) ^ C >>> 3, w2 = j$(q, 17) ^ j$(q, 19) ^ q >>> 10;
      d$[U] = w2 + d$[U - 7] + K + d$[U - 16] | 0;
    }
    let { A: H, B: Q, C: W, D: Z, E: Y, F: z, G: j, H: V } = this;
    for (let U = 0;U < 64; U++) {
      const C = j$(Y, 6) ^ j$(Y, 11) ^ j$(Y, 25), q = V + C + Yz(Y, z, j) + jz[U] + d$[U] | 0, w2 = (j$(H, 2) ^ j$(H, 13) ^ j$(H, 22)) + zz(H, Q, W) | 0;
      V = j, j = z, z = Y, Y = Z + q | 0, Z = W, W = Q, Q = H, H = q + w2 | 0;
    }
    H = H + this.A | 0, Q = Q + this.B | 0, W = W + this.C | 0, Z = Z + this.D | 0, Y = Y + this.E | 0, z = z + this.F | 0, j = j + this.G | 0, V = V + this.H | 0, this.set(H, Q, W, Z, Y, z, j, V);
  }
  roundClean() {
    d$.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
var QZ = $Z(() => new HZ);
var YZ = function() {
  function J($) {
    var H = this;
    if (!(H instanceof J))
      return $ === q$ ? YZ() : new J($);
    if ($ instanceof J)
      H.s = $.s, H.e = $.e, H.c = $.c.slice();
    else {
      if (typeof $ !== "string") {
        if (J.strict === true && typeof $ !== "bigint")
          throw TypeError(YH + "value");
        $ = $ === 0 && 1 / $ < 0 ? "-0" : String($);
      }
      vz(H, $);
    }
    H.constructor = J;
  }
  return J.prototype = x0, J.DP = Vz, J.RM = Gz, J.NE = Fz, J.PE = Xz, J.strict = Uz, J.roundDown = 0, J.roundHalfUp = 1, J.roundHalfEven = 2, J.roundUp = 3, J;
};
var vz = function(J, $) {
  var H, Q, W;
  if (!qz.test($))
    throw Error(YH + "number");
  if (J.s = $.charAt(0) == "-" ? ($ = $.slice(1), -1) : 1, (H = $.indexOf(".")) > -1)
    $ = $.replace(".", "");
  if ((Q = $.search(/e/i)) > 0) {
    if (H < 0)
      H = Q;
    H += +$.slice(Q + 1), $ = $.substring(0, Q);
  } else if (H < 0)
    H = $.length;
  W = $.length;
  for (Q = 0;Q < W && $.charAt(Q) == "0"; )
    ++Q;
  if (Q == W)
    J.c = [J.e = 0];
  else {
    for (;W > 0 && $.charAt(--W) == "0"; )
      ;
    J.e = H - Q - 1, J.c = [];
    for (H = 0;Q <= W; )
      J.c[H++] = +$.charAt(Q++);
  }
  return J;
};
var zH = function(J, $, H, Q) {
  var W = J.c;
  if (H === q$)
    H = J.constructor.RM;
  if (H !== 0 && H !== 1 && H !== 2 && H !== 3)
    throw Error(Dz);
  if ($ < 1)
    if (Q = H === 3 && (Q || !!W[0]) || $ === 0 && (H === 1 && W[0] >= 5 || H === 2 && (W[0] > 5 || W[0] === 5 && (Q || W[1] !== q$))), W.length = 1, Q)
      J.e = J.e - $ + 1, W[0] = 1;
    else
      W[0] = J.e = 0;
  else if ($ < W.length) {
    if (Q = H === 1 && W[$] >= 5 || H === 2 && (W[$] > 5 || W[$] === 5 && (Q || W[$ + 1] !== q$ || W[$ - 1] & 1)) || H === 3 && (Q || !!W[0]), W.length = $, Q) {
      for (;++W[--$] > 9; )
        if (W[$] = 0, $ === 0) {
          ++J.e, W.unshift(1);
          break;
        }
    }
    for ($ = W.length;!W[--$]; )
      W.pop();
  }
  return J;
};
var EH = function(J, $, H) {
  var Q = J.e, W = J.c.join(""), Z = W.length;
  if ($)
    W = W.charAt(0) + (Z > 1 ? "." + W.slice(1) : "") + (Q < 0 ? "e" : "e+") + Q;
  else if (Q < 0) {
    for (;++Q; )
      W = "0" + W;
    W = "0." + W;
  } else if (Q > 0) {
    if (++Q > Z)
      for (Q -= Z;Q--; )
        W += "0";
    else if (Q < Z)
      W = W.slice(0, Q) + "." + W.slice(Q);
  } else if (Z > 1)
    W = W.charAt(0) + "." + W.slice(1);
  return J.s < 0 && H ? "-" + W : W;
};
var Vz = 20;
var Gz = 1;
var ZH = 1e6;
var WZ = 1e6;
var Fz = -7;
var Xz = 21;
var Uz = false;
var uH = "[big.js] ";
var YH = uH + "Invalid ";
var dQ = YH + "decimal places";
var Dz = YH + "rounding mode";
var ZZ = uH + "Division by zero";
var x0 = {};
var q$ = undefined;
var qz = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
x0.abs = function() {
  var J = new this.constructor(this);
  return J.s = 1, J;
};
x0.cmp = function(J) {
  var $, H = this, Q = H.c, W = (J = new H.constructor(J)).c, Z = H.s, Y = J.s, z = H.e, j = J.e;
  if (!Q[0] || !W[0])
    return !Q[0] ? !W[0] ? 0 : -Y : Z;
  if (Z != Y)
    return Z;
  if ($ = Z < 0, z != j)
    return z > j ^ $ ? 1 : -1;
  Y = (z = Q.length) < (j = W.length) ? z : j;
  for (Z = -1;++Z < Y; )
    if (Q[Z] != W[Z])
      return Q[Z] > W[Z] ^ $ ? 1 : -1;
  return z == j ? 0 : z > j ^ $ ? 1 : -1;
};
x0.div = function(J) {
  var $ = this, H = $.constructor, Q = $.c, W = (J = new H(J)).c, Z = $.s == J.s ? 1 : -1, Y = H.DP;
  if (Y !== ~~Y || Y < 0 || Y > ZH)
    throw Error(dQ);
  if (!W[0])
    throw Error(ZZ);
  if (!Q[0])
    return J.s = Z, J.c = [J.e = 0], J;
  var z, j, V, U, C, q = W.slice(), K = z = W.length, w2 = Q.length, O = Q.slice(0, z), h2 = O.length, b = J, N = b.c = [], x = 0, k = Y + (b.e = $.e - J.e) + 1;
  b.s = Z, Z = k < 0 ? 0 : k, q.unshift(0);
  for (;h2++ < z; )
    O.push(0);
  do {
    for (V = 0;V < 10; V++) {
      if (z != (h2 = O.length))
        U = z > h2 ? 1 : -1;
      else
        for (C = -1, U = 0;++C < z; )
          if (W[C] != O[C]) {
            U = W[C] > O[C] ? 1 : -1;
            break;
          }
      if (U < 0) {
        for (j = h2 == z ? W : q;h2; ) {
          if (O[--h2] < j[h2]) {
            C = h2;
            for (;C && !O[--C]; )
              O[C] = 9;
            --O[C], O[h2] += 10;
          }
          O[h2] -= j[h2];
        }
        for (;!O[0]; )
          O.shift();
      } else
        break;
    }
    if (N[x++] = U ? V : ++V, O[0] && U)
      O[h2] = Q[K] || 0;
    else
      O = [Q[K]];
  } while ((K++ < w2 || O[0] !== q$) && Z--);
  if (!N[0] && x != 1)
    N.shift(), b.e--, k--;
  if (x > k)
    zH(b, k, H.RM, O[0] !== q$);
  return b;
};
x0.eq = function(J) {
  return this.cmp(J) === 0;
};
x0.gt = function(J) {
  return this.cmp(J) > 0;
};
x0.gte = function(J) {
  return this.cmp(J) > -1;
};
x0.lt = function(J) {
  return this.cmp(J) < 0;
};
x0.lte = function(J) {
  return this.cmp(J) < 1;
};
x0.minus = x0.sub = function(J) {
  var $, H, Q, W, Z = this, Y = Z.constructor, z = Z.s, j = (J = new Y(J)).s;
  if (z != j)
    return J.s = -j, Z.plus(J);
  var V = Z.c.slice(), U = Z.e, C = J.c, q = J.e;
  if (!V[0] || !C[0]) {
    if (C[0])
      J.s = -j;
    else if (V[0])
      J = new Y(Z);
    else
      J.s = 1;
    return J;
  }
  if (z = U - q) {
    if (W = z < 0)
      z = -z, Q = V;
    else
      q = U, Q = C;
    Q.reverse();
    for (j = z;j--; )
      Q.push(0);
    Q.reverse();
  } else {
    H = ((W = V.length < C.length) ? V : C).length;
    for (z = j = 0;j < H; j++)
      if (V[j] != C[j]) {
        W = V[j] < C[j];
        break;
      }
  }
  if (W)
    Q = V, V = C, C = Q, J.s = -J.s;
  if ((j = (H = C.length) - ($ = V.length)) > 0)
    for (;j--; )
      V[$++] = 0;
  for (j = $;H > z; ) {
    if (V[--H] < C[H]) {
      for ($ = H;$ && !V[--$]; )
        V[$] = 9;
      --V[$], V[H] += 10;
    }
    V[H] -= C[H];
  }
  for (;V[--j] === 0; )
    V.pop();
  for (;V[0] === 0; )
    V.shift(), --q;
  if (!V[0])
    J.s = 1, V = [q = 0];
  return J.c = V, J.e = q, J;
};
x0.mod = function(J) {
  var $, H = this, Q = H.constructor, W = H.s, Z = (J = new Q(J)).s;
  if (!J.c[0])
    throw Error(ZZ);
  if (H.s = J.s = 1, $ = J.cmp(H) == 1, H.s = W, J.s = Z, $)
    return new Q(H);
  return W = Q.DP, Z = Q.RM, Q.DP = Q.RM = 0, H = H.div(J), Q.DP = W, Q.RM = Z, this.minus(H.times(J));
};
x0.neg = function() {
  var J = new this.constructor(this);
  return J.s = -J.s, J;
};
x0.plus = x0.add = function(J) {
  var $, H, Q, W = this, Z = W.constructor;
  if (J = new Z(J), W.s != J.s)
    return J.s = -J.s, W.minus(J);
  var { e: Y, c: z } = W, j = J.e, V = J.c;
  if (!z[0] || !V[0]) {
    if (!V[0])
      if (z[0])
        J = new Z(W);
      else
        J.s = W.s;
    return J;
  }
  if (z = z.slice(), $ = Y - j) {
    if ($ > 0)
      j = Y, Q = V;
    else
      $ = -$, Q = z;
    Q.reverse();
    for (;$--; )
      Q.push(0);
    Q.reverse();
  }
  if (z.length - V.length < 0)
    Q = V, V = z, z = Q;
  $ = V.length;
  for (H = 0;$; z[$] %= 10)
    H = (z[--$] = z[$] + V[$] + H) / 10 | 0;
  if (H)
    z.unshift(H), ++j;
  for ($ = z.length;z[--$] === 0; )
    z.pop();
  return J.c = z, J.e = j, J;
};
x0.pow = function(J) {
  var $ = this, H = new $.constructor("1"), Q = H, W = J < 0;
  if (J !== ~~J || J < -WZ || J > WZ)
    throw Error(YH + "exponent");
  if (W)
    J = -J;
  for (;; ) {
    if (J & 1)
      Q = Q.times($);
    if (J >>= 1, !J)
      break;
    $ = $.times($);
  }
  return W ? H.div(Q) : Q;
};
x0.prec = function(J, $) {
  if (J !== ~~J || J < 1 || J > ZH)
    throw Error(YH + "precision");
  return zH(new this.constructor(this), J, $);
};
x0.round = function(J, $) {
  if (J === q$)
    J = 0;
  else if (J !== ~~J || J < -ZH || J > ZH)
    throw Error(dQ);
  return zH(new this.constructor(this), J + this.e + 1, $);
};
x0.sqrt = function() {
  var J, $, H, Q = this, W = Q.constructor, Z = Q.s, Y = Q.e, z = new W("0.5");
  if (!Q.c[0])
    return new W(Q);
  if (Z < 0)
    throw Error(uH + "No square root");
  if (Z = Math.sqrt(Q + ""), Z === 0 || Z === Infinity) {
    if ($ = Q.c.join(""), !($.length + Y & 1))
      $ += "0";
    Z = Math.sqrt($), Y = ((Y + 1) / 2 | 0) - (Y < 0 || Y & 1), J = new W((Z == Infinity ? "5e" : (Z = Z.toExponential()).slice(0, Z.indexOf("e") + 1)) + Y);
  } else
    J = new W(Z + "");
  Y = J.e + (W.DP += 4);
  do
    H = J, J = z.times(H.plus(Q.div(H)));
  while (H.c.slice(0, Y).join("") !== J.c.slice(0, Y).join(""));
  return zH(J, (W.DP -= 4) + J.e + 1, W.RM);
};
x0.times = x0.mul = function(J) {
  var $, H = this, Q = H.constructor, W = H.c, Z = (J = new Q(J)).c, Y = W.length, z = Z.length, j = H.e, V = J.e;
  if (J.s = H.s == J.s ? 1 : -1, !W[0] || !Z[0])
    return J.c = [J.e = 0], J;
  if (J.e = j + V, Y < z)
    $ = W, W = Z, Z = $, V = Y, Y = z, z = V;
  for ($ = new Array(V = Y + z);V--; )
    $[V] = 0;
  for (j = z;j--; ) {
    z = 0;
    for (V = Y + j;V > j; )
      z = $[V] + Z[j] * W[V - j - 1] + z, $[V--] = z % 10, z = z / 10 | 0;
    $[V] = z;
  }
  if (z)
    ++J.e;
  else
    $.shift();
  for (j = $.length;!$[--j]; )
    $.pop();
  return J.c = $, J;
};
x0.toExponential = function(J, $) {
  var H = this, Q = H.c[0];
  if (J !== q$) {
    if (J !== ~~J || J < 0 || J > ZH)
      throw Error(dQ);
    H = zH(new H.constructor(H), ++J, $);
    for (;H.c.length < J; )
      H.c.push(0);
  }
  return EH(H, true, !!Q);
};
x0.toFixed = function(J, $) {
  var H = this, Q = H.c[0];
  if (J !== q$) {
    if (J !== ~~J || J < 0 || J > ZH)
      throw Error(dQ);
    H = zH(new H.constructor(H), J + H.e + 1, $);
    for (J = J + H.e + 1;H.c.length < J; )
      H.c.push(0);
  }
  return EH(H, false, !!Q);
};
x0[Symbol.for("nodejs.util.inspect.custom")] = x0.toJSON = x0.toString = function() {
  var J = this, $ = J.constructor;
  return EH(J, J.e <= $.NE || J.e >= $.PE, !!J.c[0]);
};
x0.toNumber = function() {
  var J = Number(EH(this, true, true));
  if (this.constructor.strict === true && !this.eq(J.toString()))
    throw Error(uH + "Imprecise conversion");
  return J;
};
x0.toPrecision = function(J, $) {
  var H = this, Q = H.constructor, W = H.c[0];
  if (J !== q$) {
    if (J !== ~~J || J < 1 || J > ZH)
      throw Error(YH + "precision");
    H = zH(new Q(H), J, $);
    for (;H.c.length < J; )
      H.c.push(0);
  }
  return EH(H, J <= H.e || H.e <= Q.NE || H.e >= Q.PE, !!W);
};
x0.valueOf = function() {
  var J = this, $ = J.constructor;
  if ($.strict === true)
    throw Error(uH + "valueOf disallowed");
  return EH(J, J.e <= $.NE || J.e >= $.PE, true);
};
var Cz = YZ();
var pQ = Cz;
var eH = E0(EJ(), 1);
var qZ = E0(EJ(), 1);
var D6 = "1.1.0-beta.6";
var Bz = function() {
  try {
    const J = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach(($) => {
      try {
        if ("test".normalize($) !== "test")
          throw new Error("bad normalize");
      } catch (H) {
        J.push($);
      }
    }), J.length)
      throw new Error("missing " + J.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (J) {
    if (J instanceof Error)
      return J.message;
  }
  return "";
};
var UZ = function(J, $ = false) {
  let H = J;
  try {
    if (J instanceof Uint8Array) {
      let Q = "";
      for (let W = 0;W < J.length; W++)
        Q += XZ[J[W] >> 4], Q += XZ[J[W] & 15];
      H = `Uint8Array(0x${Q})`;
    } else if (J instanceof $PublicKey)
      H = `PublicKey(${J.toBase58()})`;
    else if (J instanceof Object && !$) {
      const Q = {};
      Object.entries(J).forEach(([W, Z]) => {
        Q[W] = UZ(Z, true);
      }), H = JSON.stringify(Q);
    } else if (!$)
      H = JSON.stringify(J);
  } catch (Q) {
    H = JSON.stringify(J.toString());
  }
  return H;
};
var jZ = false;
var VZ = false;
var lQ = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
var GZ = {};
var q6;
var FZ = Bz();
var v6;
(function(J) {
  J.DEBUG = "DEBUG", J.INFO = "INFO", J.WARNING = "WARNING", J.ERROR = "ERROR", J.OFF = "OFF";
})(v6 || (v6 = {}));
var C6;
(function(J) {
  J.UNKNOWN_ERROR = "UNKNOWN_ERROR", J.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", J.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", J.NETWORK_ERROR = "NETWORK_ERROR", J.RPC_ERROR = "RPC_ERROR", J.TIMEOUT = "TIMEOUT", J.BUFFER_OVERRUN = "BUFFER_OVERRUN", J.NUMERIC_FAULT = "NUMERIC_FAULT", J.MISSING_NEW = "MISSING_NEW", J.INVALID_ARGUMENT = "INVALID_ARGUMENT", J.MISSING_ARGUMENT = "MISSING_ARGUMENT", J.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", J.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS";
})(C6 || (C6 = {}));
var XZ = "0123456789abcdef";

class U0 {
  constructor(J) {
    this.version = D6, this.moduleName = J;
  }
  _log(J, $) {
    const H = J.toLowerCase();
    if (lQ[H] == null)
      this.throwArgumentError("invalid log level name", "logLevel", J);
    if ((GZ[this.moduleName] || lQ.default) > lQ[H])
      return;
    console.log(...$);
  }
  debug(...J) {
    this._log(U0.levels.DEBUG, ["[DEBUG]", ...J]);
  }
  info(...J) {
    this._log(U0.levels.INFO, ["[INFO]", ...J]);
  }
  warn(...J) {
    this._log(U0.levels.WARNING, ["[WARN]", ...J]);
  }
  makeError(J, $, H) {
    if (VZ)
      return this.makeError("censored error", $, {});
    if (!$)
      $ = U0.errors.UNKNOWN_ERROR;
    if (!H)
      H = {};
    const Q = [];
    Object.entries(H).forEach(([Y, z]) => {
      Q.push(`${Y}=${UZ(z)})`);
    }), Q.push(`code=${$}`), Q.push(`module=${this.moduleName}`), Q.push(`version=${this.version}`);
    const W = J;
    if (Q.length)
      J += " (" + Q.join(", ") + ")";
    const Z = new Error(J);
    return Z.reason = W, Z.code = $, Object.entries(H).forEach(([Y, z]) => {
      Z[Y] = z;
    }), Z;
  }
  throwError(J, $, H) {
    throw this.makeError(J, $, H);
  }
  throwArgumentError(J, $, H) {
    return this.throwError(J, U0.errors.INVALID_ARGUMENT, { argument: $, value: H });
  }
  assert(J, $, H, Q) {
    if (J)
      return;
    this.throwError($, H, Q);
  }
  assertArgument(J, $, H, Q) {
    if (J)
      return;
    this.throwArgumentError($, H, Q);
  }
  checkNormalize(J) {
    if (J == null)
      J = "platform missing String.prototype.normalize";
    if (FZ)
      this.throwError("platform missing String.prototype.normalize", U0.errors.UNSUPPORTED_OPERATION, { operation: "String.prototype.normalize", form: FZ });
  }
  checkSafeUint53(J, $) {
    if (typeof J !== "number")
      return;
    if ($ == null)
      $ = "value not safe";
    if (J < 0 || J >= 9007199254740991)
      this.throwError($, U0.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "out-of-safe-range", value: J });
    if (J % 1)
      this.throwError($, U0.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "non-integer", value: J });
  }
  checkArgumentCount(J, $, H) {
    if (H)
      H = ": " + H;
    else
      H = "";
    if (J < $)
      this.throwError("missing argument" + H, U0.errors.MISSING_ARGUMENT, { count: J, expectedCount: $ });
    if (J > $)
      this.throwError("too many arguments" + H, U0.errors.UNEXPECTED_ARGUMENT, { count: J, expectedCount: $ });
  }
  checkNew(J, $) {
    if (J === Object || J == null)
      this.throwError("missing new", U0.errors.MISSING_NEW, { name: $.name });
  }
  checkAbstract(J, $) {
    if (J === $)
      this.throwError("cannot instantiate abstract class " + JSON.stringify($.name) + " directly; use a sub-class", U0.errors.UNSUPPORTED_OPERATION, { name: J.name, operation: "new" });
    else if (J === Object || J == null)
      this.throwError("missing new", U0.errors.MISSING_NEW, { name: $.name });
  }
  static globalLogger() {
    if (!q6)
      q6 = new U0(D6);
    return q6;
  }
  static setCensorship(J, $) {
    if (!J && $)
      this.globalLogger().throwError("cannot permanently disable censorship", U0.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" });
    if (jZ) {
      if (!J)
        return;
      this.globalLogger().throwError("error censorship permanent", U0.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" });
    }
    VZ = !!J, jZ = !!$;
  }
  static setLogLevel(J, $) {
    const H = lQ[$.toLowerCase()];
    if (H == null) {
      U0.globalLogger().warn("invalid log level - " + $);
      return;
    }
    GZ[J] = H;
  }
  static from(J) {
    return new U0(J);
  }
}
U0.errors = C6;
U0.levels = v6;
var DZ = U0.from("common/pubkey");
var t0 = $SystemProgram.programId;
var cH = new $PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
var v$ = new $PublicKey("SysvarRent111111111111111111111111111111111");
var SH = new $PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
var uQ = new $PublicKey("Sysvar1nstructions1111111111111111111111111");
var Lz = function(J) {
  return typeof J === "object" && J !== null && ![O0, $PublicKey, y0, qZ.BN, Y$, r0, PJ, uJ].some(($) => typeof $ === "object" && J instanceof $);
};
var Kz = E0(EJ(), 1);
var cQ = function({ makeTxVersion: J, innerIns: $, payer: H, lookupTableAddressAccount: Q }) {
  const W = $.map((V) => V.instructions).flat(), Z = [...new Set($.map((V) => V.signers).flat().map((V) => V.publicKey.toString()))].map((V) => new $PublicKey(V)), Y = $.map((V) => V.lookupTableAddress ?? []).flat().map((V) => V.toString()), z = {}, j = Q ?? {};
  for (let V of Y)
    if (j[V] !== undefined)
      z[V] = j[V];
  return J === GH.V0 ? bz({ instructions: W, payer: H, lookupTableAddressAccount: z }) : wz({ instructions: W, payer: H, signers: Z });
};
var wz = function({ instructions: J, payer: $, signers: H }) {
  return BZ(J, [$, ...H]);
};
var bz = function({ instructions: J, payer: $, lookupTableAddressAccount: H }) {
  const W = new $TransactionMessage({ payerKey: $, recentBlockhash: $Keypair.generate().publicKey.toString(), instructions: J }).compileToV0Message(Object.values(H ?? {}));
  try {
    return Buffer.from(W.serialize()).toString("base64").length < MZ;
  } catch (Z) {
    return false;
  }
};
var z$ = U0.from("common/web3");
var MZ = 1644;
var iH = E0(EJ(), 1);
var R$ = E0(EJ(), 1);
var nJ;
(function(J) {
  J[J.ROUND_DOWN = 0] = "ROUND_DOWN", J[J.ROUND_HALF_UP = 1] = "ROUND_HALF_UP", J[J.ROUND_UP = 2] = "ROUND_UP";
})(nJ || (nJ = {}));
var J0 = new R$.default(0);
var k0 = new R$.default(1);
var JG = new R$.default(2);
var $G = new R$.default(3);
var HG = new R$.default(5);
var XH = new R$.default(10);
var LZ = new R$.default(100);
var QG = new R$.default(1000);
var WG = new R$.default(1e4);
var sQ = U0.from("entity/bignumber");
var KZ = 9007199254740991;
var bH = { symbol: "SOL", name: "Solana", decimals: 9 };
var SJ = { symbol: "WSOL", name: "Wrapped SOL", mint: "So11111111111111111111111111111111111111112", decimals: 9, extensions: { coingeckoId: "solana" } };
var FG = { WSOL: { ...SJ } };
var B = { WSOL: { ...SJ }, BTC: { symbol: "BTC", name: "Bitcoin", mint: "9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E", decimals: 6, extensions: { coingeckoId: "bitcoin" } }, ETH: { symbol: "ETH", name: "Ethereum", mint: "2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk", decimals: 6, extensions: { coingeckoId: "ethereum" } }, USDT: { symbol: "USDT", name: "Tether", mint: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB", decimals: 6, extensions: { coingeckoId: "tether" } }, WUSDT: { symbol: "WUSDT", name: "Wrapped USDT", mint: "BQcdHdAQW1hczDbBi9hiegXAR7A98Q9jx3X3iBBBDiq4", decimals: 6, extensions: { coingeckoId: "tether" } }, USDC: { symbol: "USDC", name: "USD Coin", mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", decimals: 6, extensions: { coingeckoId: "usd-coin" } }, WUSDC: { symbol: "WUSDC", name: "Wrapped USDC", mint: "BXXkv6z8ykpG1yuvUDPgh732wzVHB69RnB9YgSYh3itW", decimals: 6, extensions: { coingeckoId: "usd-coin" } }, YFI: { symbol: "YFI", name: "YFI", mint: "3JSf5tPeuscJGtaCp5giEiDhv51gQ4v3zWg8DGgyLfAB", decimals: 6, extensions: { coingeckoId: "yearn-finance" } }, LINK: { symbol: "LINK", name: "Chainlink", mint: "CWE8jPTUYhdCTZYWPTe1o5DFqfdjzWKc9WKz6rSjQUdG", decimals: 6, extensions: { coingeckoId: "chainlink" } }, XRP: { symbol: "XRP", name: "XRP", mint: "Ga2AXHpfAF6mv2ekZwcsJFqu7wB4NV331qNH7fW9Nst8", decimals: 6, extensions: { coingeckoId: "ripple" } }, SUSHI: { symbol: "SUSHI", name: "SUSHI", mint: "AR1Mtgh7zAtxuxGd2XPovXPVjcSdY3i4rQYisNadjfKy", decimals: 6, extensions: { coingeckoId: "sushi" } }, ALEPH: { symbol: "ALEPH", name: "ALEPH", mint: "CsZ5LZkDS7h9TDKjrbL7VAwQZ9nsRu8vJLhRYfmGaN8K", decimals: 6, extensions: { coingeckoId: "aleph" } }, SXP: { symbol: "SXP", name: "SXP", mint: "SF3oTvfWzEP3DTwGSvUXRrGTvr75pdZNnBLAH9bzMuX", decimals: 6, extensions: { coingeckoId: "swipe" } }, HGET: { symbol: "HGET", name: "HGET", mint: "BtZQfWqDGbk9Wf2rXEiWyQBdBY1etnUUn6zEphvVS7yN", decimals: 6, extensions: { coingeckoId: "hedget" } }, CREAM: { symbol: "CREAM", name: "CREAM", mint: "5Fu5UUgbjpUvdBveb3a1JTNirL8rXtiYeSMWvKjtUNQv", decimals: 6, extensions: { coingeckoId: "cream-2" } }, UNI: { symbol: "UNI", name: "UNI", mint: "DEhAasscXF4kEGxFgJ3bq4PpVGp5wyUxMRvn6TzGVHaw", decimals: 6, extensions: { coingeckoId: "uniswap" } }, SRM: { symbol: "SRM", name: "Serum", mint: "SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt", decimals: 6, extensions: { coingeckoId: "serum" } }, FTT: { symbol: "FTT", name: "FTX Token", mint: "AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3", decimals: 6, extensions: { coingeckoId: "ftx-token" } }, MSRM: { symbol: "MSRM", name: "MegaSerum", mint: "MSRMcoVyrFxnSgo5uXwone5SKcGhT1KEJMFEkMEWf9L", decimals: 0, extensions: { coingeckoId: "megaserum" } }, TOMO: { symbol: "TOMO", name: "TOMO", mint: "GXMvfY2jpQctDqZ9RoU3oWPhufKiCcFEfchvYumtX7jd", decimals: 6, extensions: { coingeckoId: "tomochain" } }, KARMA: { symbol: "KARMA", name: "KARMA", mint: "EcqExpGNFBve2i1cMJUTR4bPXj4ZoqmDD2rTkeCcaTFX", decimals: 4, extensions: { coingeckoId: "karma-dao" } }, LUA: { symbol: "LUA", name: "LUA", mint: "EqWCKXfs3x47uVosDpTRgFniThL9Y8iCztJaapxbEaVX", decimals: 6, extensions: { coingeckoId: "lua-token" } }, MATH: { symbol: "MATH", name: "MATH", mint: "GeDS162t9yGJuLEHPWXXGrb1zwkzinCgRwnT8vHYjKza", decimals: 6, extensions: { coingeckoId: "math" } }, KEEP: { symbol: "KEEP", name: "KEEP", mint: "GUohe4DJUA5FKPWo3joiPgsB7yzer7LpDmt1Vhzy3Zht", decimals: 6, extensions: { coingeckoId: "keep-network" } }, SWAG: { symbol: "SWAG", name: "SWAG", mint: "9F9fNTT6qwjsu4X4yWYKZpsbw5qT7o6yR2i57JF2jagy", decimals: 6, extensions: { coingeckoId: "swag-finance" } }, FIDA: { symbol: "FIDA", name: "Bonfida", mint: "EchesyfXePKdLtoiZSL8pBe8Myagyy8ZRqsACNCFGnvp", decimals: 6, extensions: { coingeckoId: "bonfida" } }, KIN: { symbol: "KIN", name: "Kin", mint: "kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6", decimals: 5, extensions: { coingeckoId: "kin" } }, MAPS: { symbol: "MAPS", name: "MAPS", mint: "MAPS41MDahZ9QdKXhVa4dWB9RuyfV4XqhyAZ8XcYepb", decimals: 6, extensions: { coingeckoId: "maps" } }, OXY: { symbol: "OXY", name: "Oxygen", mint: "z3dn17yLaGMKffVogeFHQ9zWVcXgqgf3PQnDsNs2g6M", decimals: 6, extensions: { coingeckoId: "oxygen" } }, RAY: { symbol: "RAY", name: "Raydium", mint: "4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R", decimals: 6, extensions: { coingeckoId: "raydium" } }, xCOPE: { symbol: "xCOPE", name: "xCOPE", mint: "3K6rftdAaQYMPunrtNRHgnK2UAtjm2JwyT2oCiTDouYE", decimals: 0, extensions: { coingeckoId: "cope" } }, COPE: { symbol: "COPE", name: "Cope", mint: "8HGyAAB1yoM1ttS7pXjHMa3dukTFGQggnFFH3hJZgzQh", decimals: 6, extensions: { coingeckoId: "cope" } }, STEP: { symbol: "STEP", name: "Step Finance", mint: "StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT", decimals: 9, extensions: { coingeckoId: "step-finance" } }, MEDIA: { symbol: "MEDIA", name: "Media Network", mint: "ETAtLmCmsoiEEKfNrHKJ2kYy3MoABhU6NQvpSfij5tDs", decimals: 6, extensions: { coingeckoId: "media-network" } }, ROPE: { symbol: "ROPE", name: "Rope Token", mint: "8PMHT4swUMtBzgHnh5U564N5sjPSiUz2cjEQzFnnP1Fo", decimals: 9, extensions: { coingeckoId: "rope-token" } }, MER: { symbol: "MER", name: "Mercurial", mint: "MERt85fc5boKw3BW1eYdxonEuJNvXbiMbs6hvheau5K", decimals: 6, extensions: { coingeckoId: "mercurial" } }, TULIP: { symbol: "TULIP", name: "Tulip Protocol", mint: "TuLipcqtGVXP9XR62wM8WWCm6a9vhLs7T1uoWBk6FDs", decimals: 6, extensions: { coingeckoId: "solfarm" } }, SNY: { symbol: "SNY", name: "SNY", mint: "4dmKkXNHdgYsXqBHCuMikNQWwVomZURhYvkkX5c4pQ7y", decimals: 6, extensions: { coingeckoId: "synthetify-token" } }, SLRS: { symbol: "SLRS", name: "SLRS", mint: "SLRSSpSLUTP7okbCUBYStWCo1vUgyt775faPqz8HUMr", decimals: 6, extensions: { coingeckoId: "solrise-finance" } }, WOO: { symbol: "WOO", name: "WOO Network", mint: "E5rk3nmgLUuKUiS94gg4bpWwWwyjCMtddsAXkTFLtHEy", decimals: 6, extensions: { coingeckoId: "woo-network" } }, BOP: { symbol: "BOP", name: "Boring Protocol", mint: "BLwTnYKqf7u4qjgZrrsKeNs2EzWkMLqVCu6j8iHyrNA3", decimals: 8, extensions: { coingeckoId: "boring-protocol" } }, SAMO: { symbol: "SAMO", name: "Samoyedcoin", mint: "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU", decimals: 9, extensions: { coingeckoId: "samoyedcoin" } }, renBTC: { symbol: "renBTC", name: "renBTC", mint: "CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5", decimals: 8, extensions: { coingeckoId: "renbtc" } }, renDOGE: { symbol: "renDOGE", name: "renDOGE", mint: "ArUkYE2XDKzqy77PRRGjo4wREWwqk6RXTfM9NeqzPvjU", decimals: 8, extensions: { coingeckoId: "rendoge" } }, LIKE: { symbol: "LIKE", name: "Only1", mint: "3bRTivrVsitbmCTGtqwp7hxXPsybkjn4XLNtPsHqa3zR", decimals: 9, extensions: { coingeckoId: "only1" } }, DXL: { symbol: "DXL", name: "Dexlab", mint: "GsNzxJfFn6zQdJGeYsupJWzUAm57Ba7335mfhWvFiE9Z", decimals: 6, extensions: { coingeckoId: "dexlab" } }, mSOL: { symbol: "mSOL", name: "Marinade staked SOL", mint: "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So", decimals: 9, extensions: { coingeckoId: "msol" } }, PAI: { symbol: "PAI", name: "Parrot USD", mint: "Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS", decimals: 6, extensions: { coingeckoId: "parrot-usd" } }, PORT: { symbol: "PORT", name: "Port Finance", mint: "PoRTjZMPXb9T7dyU7tpLEZRQj7e6ssfAE62j2oQuc6y", decimals: 6, extensions: { coingeckoId: "port-finance" } }, MNGO: { symbol: "MNGO", name: "Mango", mint: "MangoCzJ36AjZyKwVj3VnYU4GTonjfVEnJmvvWaxLac", decimals: 6, extensions: { coingeckoId: "mango-markets" } }, CRP: { symbol: "CRP", name: "CropperFinance", mint: "DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz", decimals: 9, extensions: { coingeckoId: "cropperfinance" } }, ATLAS: { symbol: "ATLAS", name: "Star Atlas", mint: "ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx", decimals: 8, extensions: { coingeckoId: "star-atlas" } }, POLIS: { symbol: "POLIS", name: "Star Atlas DAO", mint: "poLisWXnNRwC6oBu1vHiuKQzFjGL4XDSu4g9qjz9qVk", decimals: 8, extensions: { coingeckoId: "star-atlas-dao" } }, GRAPE: { symbol: "GRAPE", name: "Grape Protocol", mint: "8upjSpvjcdpuzhfR1zriwg5NXkwDruejqNE9WNbPRtyA", decimals: 6, extensions: { coingeckoId: "grape-2" } }, GENE: { symbol: "GENE", name: "Genopets", mint: "GENEtH5amGSi8kHAtQoezp1XEXwZJ8vcuePYnXdKrMYz", decimals: 9, extensions: { coingeckoId: "genopets" } }, DFL: { symbol: "DFL", name: "DeFi Land", mint: "DFL1zNkaGPWm1BqAVqRjCZvHmwTFrEaJtbzJWgseoNJh", decimals: 9, extensions: { coingeckoId: "defi-land" } }, CHEEMS: { symbol: "CHEEMS", name: "Cheems", mint: "3FoUAsGDbvTD6YZ4wVKJgTB76onJUKz7GPEBNiR5b8wc", decimals: 4, extensions: { coingeckoId: "cheems" } }, stSOL: { symbol: "stSOL", name: "Lido Staked SOL", mint: "7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj", decimals: 9, extensions: { coingeckoId: "lido-staked-sol" } }, LARIX: { symbol: "LARIX", name: "Larix", mint: "Lrxqnh6ZHKbGy3dcrCED43nsoLkM1LTzU2jRfWe8qUC", decimals: 6, extensions: { coingeckoId: "larix" } }, RIN: { symbol: "RIN", name: "Aldrin", mint: "E5ndSkaB17Dm7CsD22dvcjfrYSDLCxFcMd6z8ddCk5wp", decimals: 9, extensions: { coingeckoId: "aldrin" } }, APEX: { symbol: "APEX", name: "ApeXit Finance", mint: "51tMb3zBKDiQhNwGqpgwbavaGH54mk8fXFzxTc1xnasg", decimals: 9, extensions: { coingeckoId: "apexit-finance" } }, MNDE: { symbol: "MNDE", name: "Marinade", mint: "MNDEFzGvMt87ueuHvVU9VcTqsAP5b3fTGPsHuuPA5ey", decimals: 9, extensions: { coingeckoId: "marinade" } }, LIQ: { symbol: "LIQ", name: "LIQ Protocol", mint: "4wjPQJ6PrkC4dHhYghwJzGBVP78DkBzA2U3kHoFNBuhj", decimals: 6, extensions: { coingeckoId: "liq-protocol" } }, WAG: { symbol: "WAG", name: "Waggle Network", mint: "5tN42n9vMi6ubp67Uy4NnmM5DMZYN8aS8GeB3bEDHr6E", decimals: 9, extensions: { coingeckoId: "waggle-network" } }, wLDO: { symbol: "wLDO", name: "wLDO", mint: "HZRCwxP2Vq9PCpPXooayhJ2bxTpo5xfpQrwB1svh332p", decimals: 8, extensions: {} }, SLIM: { symbol: "SLIM", name: "Solanium", mint: "xxxxa1sKNGwFtw2kFn8XauW9xq8hBZ5kVtcSesTT9fW", decimals: 6, extensions: { coingeckoId: "solanium" } }, PRT: { symbol: "PRT", name: "Parrot Protocol", mint: "PRT88RkA4Kg5z7pKnezeNH4mafTvtQdfFgpQTGRjz44", decimals: 6, extensions: { coingeckoId: "parrot-protocol" } }, SBR: { symbol: "SBR", name: "SBR", mint: "Saber2gLauYim4Mvftnrasomsv6NvAuncvMEZwcLpD1", decimals: 6, extensions: {} }, FAB: { symbol: "FAB", name: "Fabric", mint: "EdAhkbj5nF9sRM7XN7ewuW8C9XEUMs8P7cnoQ57SYE96", decimals: 9, extensions: { coingeckoId: "fabric" } }, ABR: { symbol: "ABR", name: "Allbridge", mint: "a11bdAAuV8iB2fu7X6AxAvDTo1QZ8FXB3kk5eecdasp", decimals: 9, extensions: { coingeckoId: "allbridge" } }, IVN: { symbol: "IVN", name: "Investin", mint: "iVNcrNE9BRZBC9Aqf753iZiZfbszeAVUoikgT9yvr2a", decimals: 6, extensions: { coingeckoId: "investin" } }, CYS: { symbol: "CYS", name: "Cyclos", mint: "BRLsMczKuaR5w9vSubF4j8HwEGGprVAyyVgS4EX7DKEg", decimals: 6, extensions: { coingeckoId: "cyclos" } }, FRKT: { symbol: "FRKT", name: "FRAKT Token", mint: "ErGB9xa24Szxbk1M28u2Tx8rKPqzL6BroNkkzk5rG4zj", decimals: 8, extensions: { coingeckoId: "frakt-token" } }, AURY: { symbol: "AURY", name: "Aurory", mint: "AURYydfxJib1ZkTir1Jn1J9ECYUtjb6rKQVmtYaixWPP", decimals: 9, extensions: { coingeckoId: "aurory" } }, SYP: { symbol: "SYP", name: "Sypool", mint: "FnKE9n6aGjQoNWRBZXy4RW6LZVao7qwBonUbiD7edUmZ", decimals: 9, extensions: { coingeckoId: "sypool" } }, WOOF: { symbol: "WOOF", name: "WOOF", mint: "9nEqaUcb16sQ3Tn1psbkWqyhPdLmfHWjKGymREjsAgTE", decimals: 6, extensions: { coingeckoId: "woof-token" } }, ORCA: { symbol: "ORCA", name: "Orca", mint: "orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE", decimals: 6, extensions: { coingeckoId: "orca" } }, SLND: { symbol: "SLND", name: "Solend", mint: "SLNDpmoWTVADgEdndyvWzroNL7zSi1dF9PC3xHGtPwp", decimals: 6, extensions: { coingeckoId: "solend" } }, weWETH: { symbol: "weWETH", name: "weWETH", mint: "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs", decimals: 8, extensions: {} }, weUNI: { symbol: "weUNI", name: "weUNI", mint: "8FU95xFJhUUkyyCLU13HSzDLs7oC4QZdXQHL6SCeab36", decimals: 8, extensions: {} }, weSUSHI: { symbol: "weSUSHI", name: "weSUSHI", mint: "ChVzxWRmrTeSgwd3Ui3UumcN8KX7VK3WaD4KGeSKpypj", decimals: 8, extensions: {} }, GOFX: { symbol: "GOFX", name: "GooseFX", mint: "GFX1ZjR2P15tmrSwow6FjyDYcEkoFb4p4gJCpLBjaxHD", decimals: 9, extensions: { coingeckoId: "goosefx" } }, IN: { symbol: "IN", name: "Invictus", mint: "inL8PMVd6iiW3RCBJnr5AsrRN6nqr4BTrcNuQWQSkvY", decimals: 9, extensions: { coingeckoId: "invictus" } }, weDYDX: { symbol: "weDYDX", name: "weDYDX", mint: "4Hx6Bj56eGyw8EJrrheM6LBQAvVYRikYCWsALeTrwyRU", decimals: 8, extensions: {} }, STARS: { symbol: "STARS", name: "StarLaunch", mint: "HCgybxq5Upy8Mccihrp7EsmwwFqYZtrHrsmsKwtGXLgW", decimals: 6, extensions: { coingeckoId: "starlaunch" } }, weAXS: { symbol: "weAXS", name: "weAXS", mint: "HysWcbHiYY9888pHbaqhwLYZQeZrcQMXKQWRqS7zcPK5", decimals: 8, extensions: {} }, weSHIB: { symbol: "weSHIB", name: "weSHIB", mint: "CiKu4eHsVrc1eueVQeHn7qhXTcVu95gSQmBpX4utjL9z", decimals: 8, extensions: {} }, OXS: { symbol: "OXS", name: "Oxbull Solana", mint: "4TGxgCSJQx2GQk9oHZ8dC5m3JNXTYZHjXumKAW3vLnNx", decimals: 9, extensions: { coingeckoId: "oxbull-solana" } }, CWAR: { symbol: "CWAR", name: "Cryowar", mint: "HfYFjMKNZygfMC8LsQ8LtpPsPxEJoXJx4M6tqi75Hajo", decimals: 9, extensions: { coingeckoId: "cryowar-token" } }, UPS: { symbol: "UPS", name: "UPFI Network", mint: "EwJN2GqUGXXzYmoAciwuABtorHczTA5LqbukKXV1viH7", decimals: 6, extensions: { coingeckoId: "upfi-network" } }, weSAND: { symbol: "weSAND", name: "weSAND", mint: "49c7WuCZkQgc3M4qH8WuEUNXfgwupZf1xqWkDQ7gjRGt", decimals: 8, extensions: {} }, weMANA: { symbol: "weMANA", name: "weMANA", mint: "7dgHoN8wBZCc5wbnQ2C47TDnBMAxG4Q5L3KjP67z8kNi", decimals: 8, extensions: {} }, CAVE: { symbol: "CAVE", name: "Crypto Cavemen", mint: "4SZjjNABoqhbd4hnapbvoEPEqT8mnNkfbEoAwALf1V8t", decimals: 6, extensions: { coingeckoId: "cave" } }, JSOL: { symbol: "JSOL", name: "JPool", mint: "7Q2afV64in6N6SeZsAAB81TJzwDoD6zpqmHkzi9Dcavn", decimals: 9, extensions: { coingeckoId: "jpool" } }, APT: { symbol: "APT", name: "Apricot", mint: "APTtJyaRX5yGTsJU522N4VYWg3vCvSb65eam5GrPT5Rt", decimals: 6, extensions: { coingeckoId: "apricot" } }, SONAR: { symbol: "SONAR", name: "SonarWatch", mint: "sonarX4VtVkQemriJeLm6CKeW3GDMyiBnnAEMw1MRAE", decimals: 9, extensions: { coingeckoId: "sonarwatch" } }, SHILL: { symbol: "SHILL", name: "SHILL Token", mint: "6cVgJUqo4nmvQpbgrDZwyfd6RwWw5bfnCamS3M9N1fd", decimals: 6, extensions: { coingeckoId: "shill-token" } }, TTT: { symbol: "TTT", name: "TabTrader", mint: "FNFKRV3V8DtA3gVJN6UshMiLGYA8izxFwkNWmJbFjmRj", decimals: 6, extensions: { coingeckoId: "tabtrader" } }, BOKU: { symbol: "BOKU", name: "Boryoku Dragonz", mint: "CN7qFa5iYkHz99PTctvT4xXUHnxwjQ5MHxCuTJtPN5uS", decimals: 9, extensions: { coingeckoId: "boku" } }, MIMO: { symbol: "MIMO", name: "Million Monke", mint: "9TE7ebz1dsFo1uQ2T4oYAKSm39Y6fWuHrd6Uk6XaiD16", decimals: 9, extensions: { coingeckoId: "million-monke" } }, wbWBNB: { symbol: "wbWBNB", name: "wbWBNB", mint: "9gP2kCy3wA1ctvYWQk75guqXuHfrEomqydHLtcTCqiLa", decimals: 8, extensions: {} }, wePEOPLE: { symbol: "wePEOPLE", name: "wePEOPLE", mint: "CobcsUrt3p91FwvULYKorQejgsm5HoQdv5T8RUZ6PnLA", decimals: 8, extensions: {} }, XTAG: { symbol: "XTAG", name: "xHashtag", mint: "5gs8nf4wojB5EXgDUWNLwXpknzgV2YWDhveAeBZpVLbp", decimals: 6, extensions: { coingeckoId: "xhashtag" } }, KKO: { symbol: "KKO", name: "Kineko", mint: "kiNeKo77w1WBEzFFCXrTDRWGRWGP8yHvKC9rX6dqjQh", decimals: 9, extensions: { coingeckoId: "kineko" } }, VI: { symbol: "VI", name: "Vybit", mint: "7zBWymxbZt7PVHQzfi3i85frc1YRiQc23K7bh3gos8ZC", decimals: 9, extensions: { coingeckoId: "vybit" } }, SOLC: { symbol: "SOLC", name: "Solcubator", mint: "Bx1fDtvTN6NvE4kjdPHQXtmGSg582bZx9fGy4DQNMmAT", decimals: 9, extensions: { coingeckoId: "solcubator" } }, STR: { symbol: "STR", name: "Solster", mint: "9zoqdwEBKWEi9G5Ze8BSkdmppxGgVv1Kw4LuigDiNr9m", decimals: 9, extensions: { coingeckoId: "solster" } }, SPWN: { symbol: "SPWN", name: "Bitspawn", mint: "5U9QqCPhqXAJcEv9uyzFJd5zhN93vuPk1aNNkXnUfPnt", decimals: 9, extensions: { coingeckoId: "bitspawn" } }, ISOLA: { symbol: "ISOLA", name: "Intersola", mint: "333iHoRM2Awhf9uVZtSyTfU8AekdGrgQePZsKMFPgKmS", decimals: 6, extensions: { coingeckoId: "intersola" } }, RUN: { symbol: "RUN", name: "Run", mint: "6F9XriABHfWhit6zmMUYAQBSy6XK5VF1cHXuW5LDpRtC", decimals: 9, extensions: { coingeckoId: "run" } }, REAL: { symbol: "REAL", name: "Realy Metaverse", mint: "AD27ov5fVU2XzwsbvnFvb1JpCBaCB5dRXrczV9CqSVGb", decimals: 9, extensions: { coingeckoId: "realy-metaverse" } }, CRWNY: { symbol: "CRWNY", name: "CRWNY", mint: "CRWNYkqdgvhGGae9CKfNka58j6QQkaD5bLhKXvUYqnc1", decimals: 6, extensions: {} }, BLOCK: { symbol: "BLOCK", name: "Blockasset", mint: "NFTUkR4u7wKxy9QLaX2TGvd9oZSWoMo4jqSJqdMb7Nk", decimals: 6, extensions: { coingeckoId: "blockasset" } }, SOLAR: { symbol: "SOLAR", name: "Solar", mint: "2wmKXX1xsxLfrvjEPrt2UHiqj8Gbzwxvffr9qmNjsw8g", decimals: 9, extensions: { coingeckoId: "solar" } }, BASIS: { symbol: "BASIS", name: "basis.markets", mint: "Basis9oJw9j8cw53oMV7iqsgo6ihi9ALw4QR31rcjUJa", decimals: 6, extensions: { coingeckoId: "basis-markets" } }, SOLX: { symbol: "SOLX", name: "Soldex", mint: "CH74tuRLTYcxG7qNJCsV9rghfLXJCQJbsu7i52a8F1Gn", decimals: 9, extensions: { coingeckoId: "soldex" } }, CHICKS: { symbol: "CHICKS", name: "SolChicks Token", mint: "cxxShYRVcepDudXhe7U62QHvw8uBJoKFifmzggGKVC2", decimals: 9, extensions: { coingeckoId: "solchicks-token" } }, GST: { symbol: "GST", name: "GST", mint: "AFbX8oGjGpmVFywbVouvhQSRmiW2aR1mohfahi4Y2AdB", decimals: 9, extensions: { coingeckoId: "gst" } }, MBS: { symbol: "MBS", name: "MonkeyBall", mint: "Fm9rHUTF5v3hwMLbStjZXqNBBoZyGriQaFM6sTFz3K8A", decimals: 6, extensions: { coingeckoId: "monkeyball" } }, PRISM: { symbol: "PRISM", name: "Prism", mint: "PRSMNsEPqhGVCH1TtWiJqPjJyh2cKrLostPZTNy1o5x", decimals: 6, extensions: { coingeckoId: "prism" } }, MEAN: { symbol: "MEAN", name: "Meanfi", mint: "MEANeD3XDdUmNMsRGjASkSWdC8prLYsoRJ61pPeHctD", decimals: 6, extensions: { coingeckoId: "meanfi" } }, TINY: { symbol: "TINY", name: "Tiny Colony", mint: "HKfs24UEDQpHS5hUyKYkHd9q7GY5UQ679q2bokeL2whu", decimals: 6, extensions: { coingeckoId: "tiny-colony" } }, SHDW: { symbol: "SHDW", name: "GenesysGo Shadow", mint: "SHDWyBxihqiCj6YekG2GUr7wqKLeLAMK1gHZck9pL6y", decimals: 9, extensions: { coingeckoId: "genesysgo-shadow" } }, SCY: { symbol: "SCY", name: "Synchrony", mint: "SCYfrGCw8aDiqdgcpdGjV6jp4UVVQLuphxTDLNWu36f", decimals: 9, extensions: { coingeckoId: "synchrony" } }, SLC: { symbol: "SLC", name: "Solice", mint: "METAmTMXwdb8gYzyCPfXXFmZZw4rUsXX58PNsDg7zjL", decimals: 6, extensions: { coingeckoId: "solice" } } };
var t = { FIDA_RAY_V4: { symbol: "FIDA-RAY", name: "FIDA-RAY V4 LP", mint: "DsBuznXRTmzvEdb36Dx3aVLVo1XmH7r1PRZUFugLPTFv", base: B.FIDA, quote: B.RAY, decimals: B.FIDA.decimals, version: 4 }, OXY_RAY_V4: { symbol: "OXY-RAY", name: "OXY-RAY V4 LP", mint: "FwaX9W7iThTZH5MFeasxdLpxTVxRcM7ZHieTCnYog8Yb", base: B.OXY, quote: B.RAY, decimals: B.OXY.decimals, version: 4 }, MAPS_RAY_V4: { symbol: "MAPS-RAY", name: "MAPS-RAY V4 LP", mint: "CcKK8srfVdTSsFGV3VLBb2YDbzF4T4NM2C3UEjC39RLP", base: B.MAPS, quote: B.RAY, decimals: B.MAPS.decimals, version: 4 }, KIN_RAY_V4: { symbol: "KIN-RAY", name: "KIN-RAY V4 LP", mint: "CHT8sft3h3gpLYbCcZ9o27mT5s3Z6VifBVbUiDvprHPW", base: B.KIN, quote: B.RAY, decimals: 6, version: 4 }, RAY_USDT_V4: { symbol: "RAY-USDT", name: "RAY-USDT V4 LP", mint: "C3sT1R3nsw4AVdepvLTLKr5Gvszr7jufyBWUCvy4TUvT", base: B.RAY, quote: B.USDT, decimals: B.RAY.decimals, version: 4 }, SOL_USDC_V4: { symbol: "SOL-USDC", name: "SOL-USDC V4 LP", mint: "8HoQnePLqPj4M7PUDzfw8e3Ymdwgc7NLGnaTUapubyvu", base: B.WSOL, quote: B.USDC, decimals: B.WSOL.decimals, version: 4 }, YFI_USDC_V4: { symbol: "YFI-USDC", name: "YFI-USDC V4 LP", mint: "865j7iMmRRycSYUXzJ33ZcvLiX9JHvaLidasCyUyKaRE", base: B.YFI, quote: B.USDC, decimals: B.YFI.decimals, version: 4 }, SRM_USDC_V4: { symbol: "SRM-USDC", name: "SRM-USDC V4 LP", mint: "9XnZd82j34KxNLgQfz29jGbYdxsYznTWRpvZE3SRE7JG", base: B.SRM, quote: B.USDC, decimals: B.SRM.decimals, version: 4 }, FTT_USDC_V4: { symbol: "FTT-USDC", name: "FTT-USDC V4 LP", mint: "75dCoKfUHLUuZ4qEh46ovsxfgWhB4icc3SintzWRedT9", base: B.FTT, quote: B.USDC, decimals: B.FTT.decimals, version: 4 }, BTC_USDC_V4: { symbol: "BTC-USDC", name: "BTC-USDC V4 LP", mint: "2hMdRdVWZqetQsaHG8kQjdZinEMBz75vsoWTCob1ijXu", base: B.BTC, quote: B.USDC, decimals: B.BTC.decimals, version: 4 }, SUSHI_USDC_V4: { symbol: "SUSHI-USDC", name: "SUSHI-USDC V4 LP", mint: "2QVjeR9d2PbSf8em8NE8zWd8RYHjFtucDUdDgdbDD2h2", base: B.SUSHI, quote: B.USDC, decimals: B.SUSHI.decimals, version: 4 }, TOMO_USDC_V4: { symbol: "TOMO-USDC", name: "TOMO-USDC V4 LP", mint: "CHyUpQFeW456zcr5XEh4RZiibH8Dzocs6Wbgz9aWpXnQ", base: B.TOMO, quote: B.USDC, decimals: B.TOMO.decimals, version: 4 }, LINK_USDC_V4: { symbol: "LINK-USDC", name: "LINK-USDC V4 LP", mint: "BqjoYjqKrXtfBKXeaWeAT5sYCy7wsAYf3XjgDWsHSBRs", base: B.LINK, quote: B.USDC, decimals: B.LINK.decimals, version: 4 }, ETH_USDC_V4: { symbol: "ETH-USDC", name: "ETH-USDC V4 LP", mint: "13PoKid6cZop4sj2GfoBeujnGfthUbTERdE5tpLCDLEY", base: B.ETH, quote: B.USDC, decimals: B.ETH.decimals, version: 4 }, xCOPE_USDC_V4: { symbol: "xCOPE-USDC", name: "xCOPE-USDC V4 LP", mint: "2Vyyeuyd15Gp8aH6uKE72c4hxc8TVSLibxDP9vzspQWG", base: B.xCOPE, quote: B.USDC, decimals: B.xCOPE.decimals, version: 4 }, SOL_USDT_V4: { symbol: "SOL-USDT", name: "SOL-USDT V4 LP", mint: "Epm4KfTj4DMrvqn6Bwg2Tr2N8vhQuNbuK8bESFp4k33K", base: B.WSOL, quote: B.USDT, decimals: B.WSOL.decimals, version: 4 }, YFI_USDT_V4: { symbol: "YFI-USDT", name: "YFI-USDT V4 LP", mint: "FA1i7fej1pAbQbnY8NbyYUsTrWcasTyipKreDgy1Mgku", base: B.YFI, quote: B.USDT, decimals: B.YFI.decimals, version: 4 }, SRM_USDT_V4: { symbol: "SRM-USDT", name: "SRM-USDT V4 LP", mint: "HYSAu42BFejBS77jZAZdNAWa3iVcbSRJSzp3wtqCbWwv", base: B.SRM, quote: B.USDT, decimals: B.SRM.decimals, version: 4 }, FTT_USDT_V4: { symbol: "FTT-USDT", name: "FTT-USDT V4 LP", mint: "2cTCiUnect5Lap2sk19xLby7aajNDYseFhC9Pigou11z", base: B.FTT, quote: B.USDT, decimals: B.FTT.decimals, version: 4 }, BTC_USDT_V4: { symbol: "BTC-USDT", name: "BTC-USDT V4 LP", mint: "DgGuvR9GSHimopo3Gc7gfkbKamLKrdyzWkq5yqA6LqYS", base: B.BTC, quote: B.USDT, decimals: B.BTC.decimals, version: 4 }, SUSHI_USDT_V4: { symbol: "SUSHI-USDT", name: "SUSHI-USDT V4 LP", mint: "Ba26poEYDy6P2o95AJUsewXgZ8DM9BCsmnU9hmC9i4Ki", base: B.SUSHI, quote: B.USDT, decimals: B.SUSHI.decimals, version: 4 }, TOMO_USDT_V4: { symbol: "TOMO-USDT", name: "TOMO-USDT V4 LP", mint: "D3iGro1vn6PWJXo9QAPj3dfta6dKkHHnmiiym2EfsAmi", base: B.TOMO, quote: B.USDT, decimals: B.TOMO.decimals, version: 4 }, LINK_USDT_V4: { symbol: "LINK-USDT", name: "LINK-USDT V4 LP", mint: "Dr12Sgt9gkY8WU5tRkgZf1TkVWJbvjYuPAhR3aDCwiiX", base: B.LINK, quote: B.USDT, decimals: B.LINK.decimals, version: 4 }, ETH_USDT_V4: { symbol: "ETH-USDT", name: "ETH-USDT V4 LP", mint: "nPrB78ETY8661fUgohpuVusNCZnedYCgghzRJzxWnVb", base: B.ETH, quote: B.USDT, decimals: B.ETH.decimals, version: 4 }, YFI_SRM_V4: { symbol: "YFI-SRM", name: "YFI-SRM V4 LP", mint: "EGJht91R7dKpCj8wzALkjmNdUUUcQgodqWCYweyKcRcV", base: B.YFI, quote: B.SRM, decimals: B.YFI.decimals, version: 4 }, FTT_SRM_V4: { symbol: "FTT-SRM", name: "FTT-SRM V4 LP", mint: "AsDuPg9MgPtt3jfoyctUCUgsvwqAN6RZPftqoeiPDefM", base: B.FTT, quote: B.SRM, decimals: B.FTT.decimals, version: 4 }, BTC_SRM_V4: { symbol: "BTC-SRM", name: "BTC-SRM V4 LP", mint: "AGHQxXb3GSzeiLTcLtXMS2D5GGDZxsB2fZYZxSB5weqB", base: B.BTC, quote: B.SRM, decimals: B.BTC.decimals, version: 4 }, SUSHI_SRM_V4: { symbol: "SUSHI-SRM", name: "SUSHI-SRM V4 LP", mint: "3HYhUnUdV67j1vn8fu7ExuVGy5dJozHEyWvqEstDbWwE", base: B.SUSHI, quote: B.SRM, decimals: B.SUSHI.decimals, version: 4 }, TOMO_SRM_V4: { symbol: "TOMO-SRM", name: "TOMO-SRM V4 LP", mint: "GgH9RnKrQpaMQeqmdbMvs5oo1A24hERQ9wuY2pSkeG7x", base: B.TOMO, quote: B.SRM, decimals: B.TOMO.decimals, version: 4 }, LINK_SRM_V4: { symbol: "LINK-SRM", name: "LINK-SRM V4 LP", mint: "GXN6yJv12o18skTmJXaeFXZVY1iqR18CHsmCT8VVCmDD", base: B.LINK, quote: B.SRM, decimals: B.LINK.decimals, version: 4 }, ETH_SRM_V4: { symbol: "ETH-SRM", name: "ETH-SRM V4 LP", mint: "9VoY3VERETuc2FoadMSYYizF26mJinY514ZpEzkHMtwG", base: B.ETH, quote: B.SRM, decimals: B.ETH.decimals, version: 4 }, SRM_SOL_V4: { symbol: "SRM-SOL", name: "SRM-SOL V4 LP", mint: "AKJHspCwDhABucCxNLXUSfEzb7Ny62RqFtC9uNjJi4fq", base: B.SRM, quote: B.WSOL, decimals: B.SRM.decimals, version: 4 }, STEP_USDC_V4: { symbol: "STEP-USDC", name: "STEP-USDC V4 LP", mint: "3k8BDobgihmk72jVmXYLE168bxxQUhqqyESW4dQVktqC", base: B.STEP, quote: B.USDC, decimals: B.STEP.decimals, version: 4 }, MEDIA_USDC_V4: { symbol: "MEDIA-USDC", name: "MEDIA-USDC V4 LP", mint: "A5zanvgtioZGiJMdEyaKN4XQmJsp1p7uVxaq2696REvQ", base: B.MEDIA, quote: B.USDC, decimals: B.MEDIA.decimals, version: 4 }, ROPE_USDC_V4: { symbol: "ROPE-USDC", name: "ROPE-USDC V4 LP", mint: "Cq4HyW5xia37tKejPF2XfZeXQoPYW6KfbPvxvw5eRoUE", base: B.ROPE, quote: B.USDC, decimals: B.ROPE.decimals, version: 4 }, MER_USDC_V4: { symbol: "MER-USDC", name: "MER-USDC V4 LP", mint: "3H9NxvaZoxMZZDZcbBDdWMKbrfNj7PCF5sbRwDr7SdDW", base: B.MER, quote: B.USDC, decimals: B.MER.decimals, version: 4 }, COPE_USDC_V4: { symbol: "COPE-USDC", name: "COPE-USDC V4 LP", mint: "Cz1kUvHw98imKkrqqu95GQB9h1frY8RikxPojMwWKGXf", base: B.COPE, quote: B.USDC, decimals: B.COPE.decimals, version: 4 }, ALEPH_USDC_V4: { symbol: "ALEPH-USDC", name: "ALEPH-USDC V4 LP", mint: "iUDasAP2nXm5wvTukAHEKSdSXn8vQkRtaiShs9ceGB7", base: B.ALEPH, quote: B.USDC, decimals: B.ALEPH.decimals, version: 4 }, TULIP_USDC_V4: { symbol: "TULIP-USDC", name: "TULIP-USDC V4 LP", mint: "2doeZGLJyACtaG9DCUyqMLtswesfje1hjNA11hMdj6YU", base: B.TULIP, quote: B.USDC, decimals: B.TULIP.decimals, version: 4 }, WOO_USDC_V4: { symbol: "WOO-USDC", name: "WOO-USDC V4 LP", mint: "7cu42ao8Jgrd5A3y3bNQsCxq5poyGZNmTydkGfJYQfzh", base: B.WOO, quote: B.USDC, decimals: B.WOO.decimals, version: 4 }, SNY_USDC_V4: { symbol: "SNY-USDC", name: "SNY-USDC V4 LP", mint: "G8qcfeFqxwbCqpxv5LpLWxUCd1PyMB5nWb5e5YyxLMKg", base: B.SNY, quote: B.USDC, decimals: B.SNY.decimals, version: 4 }, BOP_RAY_V4: { symbol: "BOP-RAY", name: "BOP-RAY V4 LP", mint: "9nQPYJvysyfnXhQ6nkK5V7sZG26hmDgusfdNQijRk5LD", base: B.BOP, quote: B.RAY, decimals: B.BOP.decimals, version: 4 }, SLRS_USDC_V4: { symbol: "SLRS-USDC", name: "SLRS-USDC V4 LP", mint: "2Xxbm1hdv5wPeen5ponDSMT3VqhGMTQ7mH9stNXm9shU", base: B.SLRS, quote: B.USDC, decimals: B.SLRS.decimals, version: 4 }, SAMO_RAY_V4: { symbol: "SAMO-RAY", name: "SAMO-RAY V4 LP", mint: "HwzkXyX8B45LsaHXwY8su92NoRBS5GQC32HzjQRDqPnr", base: B.SAMO, quote: B.RAY, decimals: B.SAMO.decimals, version: 4 }, renBTC_USDC_V4: { symbol: "renBTC-USDC", name: "renBTC-USDC V4 LP", mint: "CTEpsih91ZLo5gunvryLpJ3pzMjmt5jbS6AnSQrzYw7V", base: B.renBTC, quote: B.USDC, decimals: B.renBTC.decimals, version: 4 }, renDOGE_USDC_V4: { symbol: "renDOGE-USDC", name: "renDOGE-USDC V4 LP", mint: "Hb8KnZNKvRxu7pgMRWJgoMSMcepfvNiBFFDDrdf9o3wA", base: B.renDOGE, quote: B.USDC, decimals: B.renDOGE.decimals, version: 4 }, RAY_USDC_V4: { symbol: "RAY-USDC", name: "RAY-USDC V4 LP", mint: "FbC6K13MzHvN42bXrtGaWsvZY9fxrackRSZcBGfjPc7m", base: B.RAY, quote: B.USDC, decimals: B.RAY.decimals, version: 4 }, RAY_SRM_V4: { symbol: "RAY-SRM", name: "RAY-SRM V4 LP", mint: "7P5Thr9Egi2rvMmEuQkLn8x8e8Qro7u2U7yLD2tU2Hbe", base: B.RAY, quote: B.SRM, decimals: B.RAY.decimals, version: 4 }, RAY_ETH_V4: { symbol: "RAY-ETH", name: "RAY-ETH V4 LP", mint: "mjQH33MqZv5aKAbKHi8dG3g3qXeRQqq1GFcXceZkNSr", base: B.RAY, quote: B.ETH, decimals: B.RAY.decimals, version: 4 }, RAY_SOL_V4: { symbol: "RAY-SOL", name: "RAY-SOL V4 LP", mint: "89ZKE4aoyfLBe2RuV6jM3JGNhaV18Nxh8eNtjRcndBip", base: B.RAY, quote: B.WSOL, decimals: B.RAY.decimals, version: 4 }, DXL_USDC_V4: { symbol: "DXL-USDC", name: "DXL-USDC V4 LP", mint: "4HFaSvfgskipvrzT1exoVKsUZ174JyExEsA8bDfsAdY5", base: B.DXL, quote: B.USDC, decimals: B.DXL.decimals, version: 4 }, LIKE_USDC_V4: { symbol: "LIKE-USDC", name: "LIKE-USDC V4 LP", mint: "cjZmbt8sJgaoyWYUttomAu5LJYU44ZrcKTbzTSEPDVw", base: B.LIKE, quote: B.USDC, decimals: B.LIKE.decimals, version: 4 }, mSOL_USDC_V4: { symbol: "mSOL-USDC", name: "mSOL-USDC V4 LP", mint: "4xTpJ4p76bAeggXoYywpCCNKfJspbuRzZ79R7pRhbqSf", base: B.mSOL, quote: B.USDC, decimals: B.mSOL.decimals, version: 4 }, mSOL_SOL_V4: { symbol: "mSOL-SOL", name: "mSOL-SOL V4 LP", mint: "5ijRoAHVgd5T5CNtK5KDRUBZ7Bffb69nktMj5n6ks6m4", base: B.mSOL, quote: B.WSOL, decimals: B.mSOL.decimals, version: 4 }, MER_PAI_V4: { symbol: "MER-PAI", name: "MER-PAI V4 LP", mint: "DU5RT2D9EviaSmX6Ta8MZwMm85HwSEqGMRdqUiuCGfmD", base: B.MER, quote: B.PAI, decimals: B.MER.decimals, version: 4 }, PORT_USDC_V4: { symbol: "PORT-USDC", name: "PORT-USDC V4 LP", mint: "9tmNtbUCrLS15qC4tEfr5NNeqcqpZ4uiGgi2vS5CLQBS", base: B.PORT, quote: B.USDC, decimals: B.PORT.decimals, version: 4 }, MNGO_USDC_V4: { symbol: "MNGO-USDC", name: "MNGO-USDC V4 LP", mint: "DkiqCQ792n743xjWQVCbBUaVtkdiuvQeYndM53ReWnCC", base: B.MNGO, quote: B.USDC, decimals: B.MNGO.decimals, version: 4 }, ATLAS_USDC_V4: { symbol: "ATLAS-USDC", name: "ATLAS-USDC V4 LP", mint: "9shGU9f1EsxAbiR567MYZ78WUiS6ZNCYbHe53WUULQ7n", base: B.ATLAS, quote: B.USDC, decimals: B.ATLAS.decimals, version: 4 }, POLIS_USDC_V4: { symbol: "POLIS-USDC", name: "POLIS-USDC V4 LP", mint: "8MbKSBpyXs8fVneKgt71jfHrn5SWtX8n4wMLpiVfF9So", base: B.POLIS, quote: B.USDC, decimals: B.POLIS.decimals, version: 4 }, ATLAS_RAY_V4: { symbol: "ATLAS-RAY", name: "ATLAS-RAY V4 LP", mint: "418MFhkaYQtbn529wmjLLqL6uKxDz7j4eZBaV1cobkyd", base: B.ATLAS, quote: B.RAY, decimals: B.ATLAS.decimals, version: 4 }, POLIS_RAY_V4: { symbol: "POLIS-RAY", name: "POLIS-RAY V4 LP", mint: "9ysGKUH6WqzjQEUT4dxqYCUaFNVK9QFEa24pGzjFq8xg", base: B.POLIS, quote: B.RAY, decimals: B.POLIS.decimals, version: 4 }, ALEPH_RAY_V4: { symbol: "ALEPH-RAY", name: "ALEPH-RAY V4 LP", mint: "n76skjqv4LirhdLok2zJELXNLdRpYDgVJQuQFbamscy", base: B.ALEPH, quote: B.RAY, decimals: B.ALEPH.decimals, version: 4 }, TULIP_RAY_V4: { symbol: "TULIP-RAY", name: "TULIP-RAY V4 LP", mint: "3AZTviji5qduMG2s4FfWGR3SSQmNUCyx8ao6UKCPg3oJ", base: B.TULIP, quote: B.RAY, decimals: B.TULIP.decimals, version: 4 }, SLRS_RAY_V4: { symbol: "SLRS-RAY", name: "SLRS-RAY V4 LP", mint: "2pk78vsKT3jfJAcN2zbpMUnrR57SZrxHqaZYyFgp92mM", base: B.SLRS, quote: B.RAY, decimals: B.SLRS.decimals, version: 4 }, MER_RAY_V4: { symbol: "MER-RAY", name: "MER-RAY V4 LP", mint: "214hxy3AbKoaEKgqcg2aC1cP5R67cGGAyDEg5GDwC7Ub", base: B.MER, quote: B.RAY, decimals: B.MER.decimals, version: 4 }, MEDIA_RAY_V4: { symbol: "MEDIA-RAY", name: "MEDIA-RAY V4 LP", mint: "9Aseg5A1JD1yCiFFdDaNNxCiJ7XzrpZFmcEmLjXFdPaH", base: B.MEDIA, quote: B.RAY, decimals: B.MEDIA.decimals, version: 4 }, SNY_RAY_V4: { symbol: "SNY-RAY", name: "SNY-RAY V4 LP", mint: "2k4quTuuLUxrSEhFH99qcoZzvgvVEc3b5sz3xz3qstfS", base: B.SNY, quote: B.RAY, decimals: B.SNY.decimals, version: 4 }, LIKE_RAY_V4: { symbol: "LIKE-RAY", name: "LIKE-RAY V4 LP", mint: "7xqDycbFSCpUpzkYapFeyPJWPwEpV7zdWbYf2MVHTNjv", base: B.LIKE, quote: B.RAY, decimals: B.LIKE.decimals, version: 4 }, COPE_RAY_V4: { symbol: "COPE-RAY", name: "COPE-RAY V4 LP", mint: "A7GCVHA8NSsbdFscHdoNU41tL1TRKNmCH4K94CgcLK9F", base: B.COPE, quote: B.RAY, decimals: B.COPE.decimals, version: 4 }, ETH_SOL_V4: { symbol: "ETH-SOL", name: "ETH-SOL V4 LP", mint: "GKfgC86iJoMjwAtcyiLu6nWnjggqUXsDQihXkP14fDez", base: B.ETH, quote: B.WSOL, decimals: B.ETH.decimals, version: 4 }, stSOL_USDC_V4: { symbol: "stSOL-USDC", name: "stSOL-USDC V4 LP", mint: "HDUJMwYZkjUZre63xUeDhdCi8c6LgUDiBqxmP3QC3VPX", base: B.stSOL, quote: B.USDC, decimals: B.stSOL.decimals, version: 4 }, GRAPE_USDC_V4: { symbol: "GRAPE-USDC", name: "GRAPE-USDC V4 LP", mint: "A8ZYmnZ1vwxUa4wpJVUaJgegsuTEz5TKy5CiJXffvmpt", base: B.GRAPE, quote: B.USDC, decimals: B.GRAPE.decimals, version: 4 }, LARIX_USDC_V4: { symbol: "LARIX-USDC", name: "LARIX-USDC V4 LP", mint: "7yieit4YsNsZ9CAK8H5ZEMvvk35kPEHHeXwp6naoWU9V", base: B.LARIX, quote: B.USDC, decimals: B.LARIX.decimals, version: 4 }, RIN_USDC_V4: { symbol: "RIN-USDC", name: "RIN-USDC V4 LP", mint: "GfCWfrZez7BDmCSEeMERVDVUaaM2TEreyYUgb2cpuS3w", base: B.RIN, quote: B.USDC, decimals: B.RIN.decimals, version: 4 }, APEX_USDC_V4: { symbol: "APEX-USDC", name: "APEX-USDC V4 LP", mint: "444cVqYyDxJNo6FqiMb9qQWFUd7tYzFRdDuJRFrSAGnU", base: B.APEX, quote: B.USDC, decimals: B.APEX.decimals, version: 4 }, mSOL_RAY_V4: { symbol: "mSOL-RAY", name: "mSOL-RAY V4 LP", mint: "De2EHBAdkgfc72DpShqDGG42cV3iDWh8wvvZdPsiEcqP", base: B.mSOL, quote: B.RAY, decimals: B.mSOL.decimals, version: 4 }, MNDE_mSOL_V4: { symbol: "MNDE-mSOL", name: "MNDE-mSOL V4 LP", mint: "4bh8XCzTHSbqbWN8o1Jn4ueBdz1LvJFoEasN6K6CQ8Ny", base: B.MNDE, quote: B.mSOL, decimals: B.MNDE.decimals, version: 4 }, LARIX_RAY_V4: { symbol: "LARIX-RAY", name: "LARIX-RAY V4 LP", mint: "ZRDfSLgWGeaYSmhdPvFNKQQhDcYdZQaue2N8YDmHX4q", base: B.LARIX, quote: B.RAY, decimals: B.LARIX.decimals, version: 4 }, LIQ_USDC_V4: { symbol: "LIQ-USDC", name: "LIQ-USDC V4 LP", mint: "GWpD3eTfhJB5KDCcnE85dBQrjAk2CsrgDF9b52R9CrjV", base: B.LIQ, quote: B.USDC, decimals: B.LIQ.decimals, version: 4 }, WAG_USDC_V4: { symbol: "WAG-USDC", name: "WAG-USDC V4 LP", mint: "4yykyPugitUVRewNPXXCviRvxGfsfsRMoP32z3b6FmUC", base: B.WAG, quote: B.USDC, decimals: B.WAG.decimals, version: 4 }, ETH_mSOL_V4: { symbol: "ETH-mSOL", name: "ETH-mSOL V4 LP", mint: "HYv3grQfi8QbV7nG7EFgNK1aJSrsJ7HynXJKJVPLL2Uh", base: B.ETH, quote: B.mSOL, decimals: B.ETH.decimals, version: 4 }, mSOL_USDT_V4: { symbol: "mSOL-USDT", name: "mSOL-USDT V4 LP", mint: "69NCmEW9mGpiWLjAcAWHq51k4ionJZmzgRfRT3wQaCCf", base: B.mSOL, quote: B.USDT, decimals: B.mSOL.decimals, version: 4 }, BTC_mSOL_V4: { symbol: "BTC-mSOL", name: "BTC-mSOL V4 LP", mint: "92bcERNtUmuaJ6mwLSxYHZYSph37jdKxRdoYNxpcYNPp", base: B.BTC, quote: B.mSOL, decimals: B.BTC.decimals, version: 4 }, SLIM_SOL_V4: { symbol: "SLIM-SOL", name: "SLIM-SOL V4 LP", mint: "9X4EK8E59VAVi6ChnNvvd39m6Yg9RtkBbAPq1mDVJT57", base: B.SLIM, quote: B.WSOL, decimals: B.SLIM.decimals, version: 4 }, AURY_USDC_V4: { symbol: "AURY-USDC", name: "AURY-USDC V4 LP", mint: "Gub5dvTy4nzP82qpmpNkBxmRqjtqRddBTBqHSdNcf2oS", base: B.AURY, quote: B.USDC, decimals: B.AURY.decimals, version: 4 }, PRT_SOL_V4: { symbol: "PRT-SOL", name: "PRT-SOL V4 LP", mint: "EcJ8Wgwt1AzSPiDpVr6aaSur8TKAsNTPmmzRACeqT68Z", base: B.PRT, quote: B.WSOL, decimals: B.PRT.decimals, version: 4 }, LIQ_RAY_V4: { symbol: "LIQ-RAY", name: "LIQ-RAY V4 LP", mint: "49YUsDrThJosHSagCn1F59Uc9NRxbr9thVrZikUnQDXy", base: B.LIQ, quote: B.RAY, decimals: B.LIQ.decimals, version: 4 }, SYP_SOL_V4: { symbol: "SYP-SOL", name: "SYP-SOL V4 LP", mint: "KHV6dfj2bDntzJ9z1S26cDfqWfUZdJRFmteLR6LxHwW", base: B.SYP, quote: B.WSOL, decimals: B.SYP.decimals, version: 4 }, SYP_RAY_V4: { symbol: "SYP-RAY", name: "SYP-RAY V4 LP", mint: "FT2KZqxxM8F2h9pZtTF4PyjK88bM4YbuBzd7ZPwQ5wMB", base: B.SYP, quote: B.RAY, decimals: B.SYP.decimals, version: 4 }, SYP_USDC_V4: { symbol: "SYP-USDC", name: "SYP-USDC V4 LP", mint: "2xJGuLAivAR1WkARRA6zP1v4jaA9jV2Qis8JfMNvrVyZ", base: B.SYP, quote: B.USDC, decimals: B.SYP.decimals, version: 4 }, FAB_USDC_V4: { symbol: "FAB-USDC", name: "FAB-USDC V4 LP", mint: "5rTCvZq6BcApsC3VV1EEUuTJfaVd8uYhcGjwTy1By6P8", base: B.FAB, quote: B.USDC, decimals: B.FAB.decimals, version: 4 }, WOOF_RAY_V4: { symbol: "WOOF-RAY", name: "WOOF-RAY V4 LP", mint: "H2FAnazDaGFutcmnrwDxhmdncR1Bd7GG4mhPCSUiamDX", base: B.WOOF, quote: B.RAY, decimals: B.WOOF.decimals, version: 4 }, WOOF_USDC_V4: { symbol: "WOOF-USDC", name: "WOOF-USDC V4 LP", mint: "EFSu5TMc1ijRevaYCxUkS7uGvbhsymDHEaTK3UVdNE3q", base: B.WOOF, quote: B.USDC, decimals: B.WOOF.decimals, version: 4 }, SLND_USDC_V4: { symbol: "SLND-USDC", name: "SLND-USDC V4 LP", mint: "EunE9uDh2cGsyJcsGuGKc6wte7kBn8iye2gzC4w2ePHn", base: B.SLND, quote: B.USDC, decimals: B.SLND.decimals, version: 4 }, FRKT_SOL_V4: { symbol: "FRKT-SOL", name: "FRKT-SOL V4 LP", mint: "HYUKXgpjaxMXHttyrFYtv3z2rdhZ1U9QDH8zEc8BooQC", base: B.FRKT, quote: B.WSOL, decimals: B.FRKT.decimals, version: 4 }, weWETH_SOL_V4: { symbol: "weWETH-SOL", name: "weWETH-SOL V4 LP", mint: "3hbozt2Por7bcrGod8N7kEeJNMocFFjCJrQR16TQGBrE", base: B.weWETH, quote: B.WSOL, decimals: B.weWETH.decimals, version: 4 }, weWETH_USDC_V4: { symbol: "weWETH-USDC", name: "weWETH-USDC V4 LP", mint: "3529SBnMCDW3S3xQ52aABbRHo7PcHvpQA4no8J12L5eK", base: B.weWETH, quote: B.USDC, decimals: B.weWETH.decimals, version: 4 }, weUNI_USDC_V4: { symbol: "weUNI-USDC", name: "weUNI-USDC V4 LP", mint: "EEC4QnT41py39QaYnzQnoYQEtDUDNa6Se8SBDgfPSN2a", base: B.weUNI, quote: B.USDC, decimals: B.weUNI.decimals, version: 4 }, weSUSHI_USDC_V4: { symbol: "weSUSHI-USDC", name: "weSUSHI-USDC V4 LP", mint: "3wVrtQZsiDNp5yTPyfEzQHPU6iuJoMmpnWg6CTt4V8sR", base: B.weSUSHI, quote: B.USDC, decimals: B.weSUSHI.decimals, version: 4 }, CYS_USDC_V4: { symbol: "CYS-USDC", name: "CYS-USDC V4 LP", mint: "GfV3QDzzdVUwCNSdfn6PjhmyJvjw18tn51RingWZYwk3", base: B.CYS, quote: B.USDC, decimals: B.CYS.decimals, version: 4 }, SAMO_USDC_V4: { symbol: "SAMO-USDC", name: "SAMO-USDC V4 LP", mint: "B2PjGEP3vPf1999fUD14pYdxvSDRVBk43hxB2rgthwEY", base: B.SAMO, quote: B.USDC, decimals: B.SAMO.decimals, version: 4 }, ABR_USDC_V4: { symbol: "ABR-USDC", name: "ABR-USDC V4 LP", mint: "ECHfxkf5zjjZFTX95QfFahNyzG7feyEKcfTdjsdrMSGU", base: B.ABR, quote: B.USDC, decimals: B.ABR.decimals, version: 4 }, IN_USDC_V4: { symbol: "IN-USDC", name: "IN-USDC V4 LP", mint: "GbmJtVgg9fRmmmjKUYGMZeSt8wZ47cDDXasg5Y3iF4kz", base: B.IN, quote: B.USDC, decimals: B.IN.decimals, version: 4 }, weDYDX_USDC_V4: { symbol: "weDYDX-USDC", name: "weDYDX-USDC V4 LP", mint: "BjkkMZnnzmgLqzGErzDbkk15ozv48iVKQuunpeM2Hqnk", base: B.weDYDX, quote: B.USDC, decimals: B.weDYDX.decimals, version: 4 }, STARS_USDC_V4: { symbol: "STARS-USDC", name: "STARS-USDC V4 LP", mint: "FJ68q7NChhETcGVdinMbM2FF1Cy79dpmUi6HC83K55Hv", base: B.STARS, quote: B.USDC, decimals: B.STARS.decimals, version: 4 }, weAXS_USDC_V4: { symbol: "weAXS-USDC", name: "weAXS-USDC V4 LP", mint: "6PSoJQ7myQ1BJtbQC6oiWR8HSecQGyoWsPYTZRJo2ci3", base: B.weAXS, quote: B.USDC, decimals: B.weAXS.decimals, version: 4 }, weSHIB_USDC_V4: { symbol: "weSHIB-USDC", name: "weSHIB-USDC V4 LP", mint: "AcjX5pmTMGSgxkdxc3r82r6WMKBvS6eQXXFz5ck5KKUa", base: B.weSHIB, quote: B.USDC, decimals: B.weSHIB.decimals, version: 4 }, SBR_USDC_V4: { symbol: "SBR-USDC", name: "SBR-USDC V4 LP", mint: "9FC8xTFRbgTpuZZYAYnZLxgnQ8r7FwfSBM1SWvGwgF7s", base: B.SBR, quote: B.USDC, decimals: B.SBR.decimals, version: 4 }, OXS_USDC_V4: { symbol: "OXS-USDC", name: "OXS-USDC V4 LP", mint: "et9pdjWm97rbmsJoN183GkFV5qzTGru79GE1Zhe7NTU", base: B.OXS, quote: B.USDC, decimals: B.OXS.decimals, version: 4 }, CWAR_USDC_V4: { symbol: "CWAR-USDC", name: "CWAR-USDC V4 LP", mint: "HjR23bxn2gtRDB2P1Tm3DLepAPPZgazsWJpLG9wqjnYR", base: B.CWAR, quote: B.USDC, decimals: B.CWAR.decimals, version: 4 }, UPS_USDC_V4: { symbol: "UPS-USDC", name: "UPS-USDC V4 LP", mint: "9hSUZdREEsbaYaKY4FouvXr7xyAqtpdHRDoYCb6Mb28a", base: B.UPS, quote: B.USDC, decimals: B.UPS.decimals, version: 4 }, weSAND_USDC_V4: { symbol: "weSAND-USDC", name: "weSAND-USDC V4 LP", mint: "3dADrQa7utyiCsaFeVk9r7oebW1WheowhKo5soBYKBVT", base: B.weSAND, quote: B.USDC, decimals: B.weSAND.decimals, version: 4 }, weMANA_USDC_V4: { symbol: "weMANA-USDC", name: "weMANA-USDC V4 LP", mint: "HpUkVAPRJ5zNRuJ1ZwMXEhbMHL3gSuPb2QuSER9YUd3a", base: B.weMANA, quote: B.USDC, decimals: B.weMANA.decimals, version: 4 }, CAVE_USDC_V4: { symbol: "CAVE-USDC", name: "CAVE-USDC V4 LP", mint: "5Gba1k3fU7Vh7UtAiBmie9vhQNNq1JfEwgn1DPGZ7NKQ", base: B.CAVE, quote: B.USDC, decimals: B.CAVE.decimals, version: 4 }, GENE_USDC_V4: { symbol: "GENE-USDC", name: "GENE-USDC V4 LP", mint: "7GKvfHEXenNiWYbJBKae89mdaMPr5gGMYwZmyC8gBNVG", base: B.GENE, quote: B.USDC, decimals: B.GENE.decimals, version: 4 }, GENE_RAY_V4: { symbol: "GENE-RAY", name: "GENE-RAY V4 LP", mint: "3HzXnc1qZ8mGqun18Ck3KA616XnZNqF1RWbgYE2nGRMA", base: B.GENE, quote: B.RAY, decimals: B.GENE.decimals, version: 4 }, APT_USDC_V4: { symbol: "APT-USDC", name: "APT-USDC V4 LP", mint: "Hk8mDAJFq4E9kF3DtNgPFwzbo5kbeiusNFJgWmo3LoQ5", base: B.APT, quote: B.USDC, decimals: B.APT.decimals, version: 4 }, GOFX_USDC_V4: { symbol: "GOFX-USDC", name: "GOFX-USDC V4 LP", mint: "4svqAwrLPGRDCQuuieYTmtLXF75wiahjeK2rEN9tY1YL", base: B.GOFX, quote: B.USDC, decimals: B.GOFX.decimals, version: 4 }, SONAR_USDC_V4: { symbol: "SONAR-USDC", name: "SONAR-USDC V4 LP", mint: "2tAcfqJ1YYjpGLqwh76kyNt9VaNFDd4fJySfH6SmWfKt", base: B.SONAR, quote: B.USDC, decimals: B.SONAR.decimals, version: 4 }, JSOL_SOL_V4: { symbol: "JSOL-SOL", name: "JSOL-SOL V4 LP", mint: "61z37rpHsU6d3Fq5sUjJ85K6tXGzkoYKDAG3kPJQNDRo", base: B.JSOL, quote: B.WSOL, decimals: B.JSOL.decimals, version: 4 }, JSOL_USDC_V4: { symbol: "JSOL-USDC", name: "JSOL-USDC V4 LP", mint: "3JZqf2VPNxj1kDZQsfzC7myM6spsGQbGuFv1gVfdYosN", base: B.JSOL, quote: B.USDC, decimals: B.JSOL.decimals, version: 4 }, SHILL_USDC_V4: { symbol: "SHILL-USDC", name: "SHILL-USDC V4 LP", mint: "CnUhYBtQEbSBZ76bgxAouVCTCb8rofZzwerVF5z5LREJ", base: B.SHILL, quote: B.USDC, decimals: B.SHILL.decimals, version: 4 }, DFL_USDC_V4: { symbol: "DFL-USDC", name: "DFL-USDC V4 LP", mint: "Fffijd6UVJdQeLVXhenS8YcsnMUdWJqpbBeH42LFkXgS", base: B.DFL, quote: B.USDC, decimals: B.DFL.decimals, version: 4 }, BOKU_USDC_V4: { symbol: "BOKU-USDC", name: "BOKU-USDC V4 LP", mint: "8jjQn5Yagb6Nm2WGAxPW1bcGqrTWpg5adf6QukXEarcP", base: B.BOKU, quote: B.USDC, decimals: B.BOKU.decimals, version: 4 }, MIMO_SOL_V4: { symbol: "MIMO-SOL", name: "MIMO-SOL V4 LP", mint: "HUJ1opSk8AiPfDT47r7n4hTiK2EXgrR3Msy7T8q1BywS", base: B.MIMO, quote: B.WSOL, decimals: B.MIMO.decimals, version: 4 }, wbWBNB_USDC_V4: { symbol: "wbWBNB-USDC", name: "wbWBNB-USDC V4 LP", mint: "FEsEfEJJSfiMQcshUgZ5UigfytfGRQ3z5puyF6DXDp9C", base: B.wbWBNB, quote: B.USDC, decimals: B.wbWBNB.decimals, version: 4 }, wePEOPLE_USDC_V4: { symbol: "wePEOPLE-USDC", name: "wePEOPLE-USDC V4 LP", mint: "3e5ZCKi4etorpV4pv1fSckP5iJD67xcUkx3RtFCZhbzD", base: B.wePEOPLE, quote: B.USDC, decimals: B.wePEOPLE.decimals, version: 4 }, ISOLA_USDT_V4: { symbol: "ISOLA-USDT", name: "ISOLA-USDT V4 LP", mint: "H8s1wQsZpRK61pyLF3XwyQc6E8vNUnwRDhy3TBDCDENQ", base: B.ISOLA, quote: B.USDT, decimals: B.ISOLA.decimals, version: 4 }, SPWN_USDC_V4: { symbol: "SPWN-USDC", name: "SPWN-USDC V4 LP", mint: "B5uyCAQcX6nAjZypLgiivbEKabSptgUb8JK9tkaSnqdW", base: B.SPWN, quote: B.USDC, decimals: B.SPWN.decimals, version: 4 }, STR_USDC_V4: { symbol: "STR-USDC", name: "STR-USDC V4 LP", mint: "8uDVKmVwNmbXHDB7rNKqtpcT9VAsFHTJ5pPYxjyoBbNg", base: B.STR, quote: B.USDC, decimals: B.STR.decimals, version: 4 }, SOLC_USDT_V4: { symbol: "SOLC-USDT", name: "SOLC-USDT V4 LP", mint: "2g9JzTWycLzK4KEBBHsponAtZRee2ii63bRrJ8tefEyt", base: B.SOLC, quote: B.USDT, decimals: B.SOLC.decimals, version: 4 }, VI_USDC_V4: { symbol: "VI-USDC", name: "VI-USDC V4 LP", mint: "3MwHyHCRfVqtH3ABFtdKXdY9dwemr9GGxQFaBkeq6NjY", base: B.VI, quote: B.USDC, decimals: B.VI.decimals, version: 4 }, KKO_USDC_V4: { symbol: "KKO-USDC", name: "KKO-USDC V4 LP", mint: "7xr1Doc1NiMWbUg99YVFqQSLfYXNzo6YvacXUsSgBMNW", base: B.KKO, quote: B.USDC, decimals: B.KKO.decimals, version: 4 }, XTAG_USDC_V4: { symbol: "XTAG-USDC", name: "XTAG-USDC V4 LP", mint: "GCEQbLg4ik5YJ4CMcbtuVqEc4sjLdSGy34rFk1CtGjdg", base: B.XTAG, quote: B.USDC, decimals: B.XTAG.decimals, version: 4 }, TTT_USDC_V4: { symbol: "TTT-USDC", name: "TTT-USDC V4 LP", mint: "84fmrerHGohoRf4iLPDQ1KG4CjSjCRksYWGzjWfCRM8a", base: B.TTT, quote: B.USDC, decimals: B.TTT.decimals, version: 4 }, RUN_USDC_V4: { symbol: "RUN-USDC", name: "RUN-USDC V4 LP", mint: "CjTLvvKSQdEujcSzeZRYgk4w1DpuXBbMppLHaxZyz11Y", base: B.RUN, quote: B.USDC, decimals: B.RUN.decimals, version: 4 }, CRWNY_USDC_V4: { symbol: "CRWNY-USDC", name: "CRWNY-USDC V4 LP", mint: "H3D9Gyi4frRLW6bS9vBthDVDJyzyRJ6XhhpP6PJGWaDC", base: B.CRWNY, quote: B.USDC, decimals: B.CRWNY.decimals, version: 4 }, CRWNY_RAY_V4: { symbol: "CRWNY-RAY", name: "CRWNY-RAY V4 LP", mint: "5Cz9wGStNjiUg81q8t6sJJeckuT2C14CYSfyQbtYirSX", base: B.CRWNY, quote: B.RAY, decimals: B.CRWNY.decimals, version: 4 }, BLOCK_USDC_V4: { symbol: "BLOCK-USDC", name: "BLOCK-USDC V4 LP", mint: "8i44Y23GkkwDYZ5iSkVEqmrXUfwNmwo9grguTDWKM8wg", base: B.BLOCK, quote: B.USDC, decimals: B.BLOCK.decimals, version: 4 }, REAL_USDC_V4: { symbol: "REAL-USDC", name: "REAL-USDC V4 LP", mint: "EN43tp8xdkcM8RYSJ4msFHMPTJRXKhUteVYBDJLwTvr3", base: B.REAL, quote: B.USDC, decimals: B.REAL.decimals, version: 4 }, FRKT_USDC_V4: { symbol: "FRKT-USDC", name: "FRKT-USDC V4 LP", mint: "7MgzqVTGeA4wENme81QPTrPy45NJMKVL9XGwxmNT87cG", base: B.FRKT, quote: B.USDC, decimals: B.FRKT.decimals, version: 4 }, MBS_USDC_V4: { symbol: "MBS-USDC", name: "MBS-USDC V4 LP", mint: "BAgSWaPZpsQKyZJdvB5KyvmCNj6hzczzentt5FhDCVHb", base: B.MBS, quote: B.USDC, decimals: B.MBS.decimals, version: 4 }, PRISM_USDC_V4: { symbol: "PRISM-USDC", name: "PRISM-USDC V4 LP", mint: "3baYkTcudvSFMe25UpZcBfdp4FA5kL2E4pfaeJ8AiYJB", base: B.PRISM, quote: B.USDC, decimals: B.PRISM.decimals, version: 4 }, CHICKS_USDC_V4: { symbol: "CHICKS-USDC", name: "CHICKS-USDC V4 LP", mint: "CPzmcw81a6PDasSXhVLfDRKuTJXZPUqocS9VFf5zCFhs", base: B.CHICKS, quote: B.USDC, decimals: B.CHICKS.decimals, version: 4 }, MEAN_RAY_V4: { symbol: "MEAN-RAY", name: "MEAN-RAY V4 LP", mint: "H9wUyrxpAErmdNVPitpHSXgwoomoh91ggJKPWtQQoCn1", base: B.MEAN, quote: B.RAY, decimals: B.MEAN.decimals, version: 4 }, TINY_USDC_V4: { symbol: "TINY-USDC", name: "TINY-USDC V4 LP", mint: "Hho6ZzRDj49L4z6zog8nQZFaxMSz6FX6wNzVpMeAMen", base: B.TINY, quote: B.USDC, decimals: B.TINY.decimals, version: 4 }, SCY_USDC_V4: { symbol: "SCY-USDC", name: "SCY-USDC V4 LP", mint: "EcYk7t6Vw59HDnY2u6H1KDPkk8juMeA1NpGpHiGk1LDf", base: B.SCY, quote: B.USDC, decimals: B.SCY.decimals, version: 4 } };
var vG = { WSOL: { ...SJ } };
var BG = U0.from("token/util");

class Y$ {
  constructor(J, $ = "UNKNOWN", H = "UNKNOWN") {
    this.decimals = J, this.symbol = $, this.name = H;
  }
}
Y$.SOL = new Y$(bH.decimals, bH.symbol, bH.name);

class r extends Y$ {
  constructor(J, $, H, Q = "UNKNOWN", W = "UNKNOWN") {
    super(H, Q, W);
    this.programId = VH(J), this.mint = VH($);
  }
  equals(J) {
    if (this === J)
      return true;
    return this.mint.equals(J.mint);
  }
}
r.WSOL = new r(m2, SJ.mint, SJ.decimals, bH.symbol, bH.name);
var bZ = E0(EZ(), 1);
var wZ = E0(SZ(), 1);
var Pz = wZ.default;
var rH = Pz;
var nQ = U0.from("entity/fraction");
var _H = rH(pQ);
var nH = rH(bZ.default);
var Nz = { [nJ.ROUND_DOWN]: nH.ROUND_DOWN, [nJ.ROUND_HALF_UP]: nH.ROUND_HALF_UP, [nJ.ROUND_UP]: nH.ROUND_UP };
var gz = { [nJ.ROUND_DOWN]: _H.roundDown, [nJ.ROUND_HALF_UP]: _H.roundHalfUp, [nJ.ROUND_UP]: _H.roundUp };

class y0 {
  constructor(J, $ = k0) {
    this.numerator = H0(J), this.denominator = H0($);
  }
  get quotient() {
    return this.numerator.div(this.denominator);
  }
  invert() {
    return new y0(this.denominator, this.numerator);
  }
  add(J) {
    const $ = J instanceof y0 ? J : new y0(H0(J));
    if (this.denominator.eq($.denominator))
      return new y0(this.numerator.add($.numerator), this.denominator);
    return new y0(this.numerator.mul($.denominator).add($.numerator.mul(this.denominator)), this.denominator.mul($.denominator));
  }
  sub(J) {
    const $ = J instanceof y0 ? J : new y0(H0(J));
    if (this.denominator.eq($.denominator))
      return new y0(this.numerator.sub($.numerator), this.denominator);
    return new y0(this.numerator.mul($.denominator).sub($.numerator.mul(this.denominator)), this.denominator.mul($.denominator));
  }
  mul(J) {
    const $ = J instanceof y0 ? J : new y0(H0(J));
    return new y0(this.numerator.mul($.numerator), this.denominator.mul($.denominator));
  }
  div(J) {
    const $ = J instanceof y0 ? J : new y0(H0(J));
    return new y0(this.numerator.mul($.denominator), this.denominator.mul($.numerator));
  }
  toSignificant(J, $ = { groupSeparator: "" }, H = nJ.ROUND_HALF_UP) {
    nQ.assert(Number.isInteger(J), `${J} is not an integer.`), nQ.assert(J > 0, `${J} is not positive.`), nH.set({ precision: J + 1, rounding: Nz[H] });
    const Q = new nH(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(J);
    return Q.toFormat(Q.decimalPlaces(), $);
  }
  toFixed(J, $ = { groupSeparator: "" }, H = nJ.ROUND_HALF_UP) {
    return nQ.assert(Number.isInteger(J), `${J} is not an integer.`), nQ.assert(J >= 0, `${J} is negative.`), _H.DP = J, _H.RM = gz[H], new _H(this.numerator.toString()).div(this.denominator.toString()).toFormat(J, $);
  }
}
var p$ = U0.from("entity/amount");
var _Z = rH(pQ);

class r0 extends y0 {
  constructor(J, $, H = true) {
    let Q = new eH.default(0);
    const W = XH.pow(new eH.default(J.decimals));
    if (H)
      Q = H0($);
    else {
      let Z = new eH.default(0), Y = new eH.default(0);
      if (typeof $ === "string" || typeof $ === "number" || typeof $ === "bigint") {
        const [z, j] = kz($.toString(), J.decimals);
        Z = H0(z), Y = H0(j);
      }
      Z = Z.mul(W), Q = Z.add(Y);
    }
    super(Q, W);
    this.currency = J;
  }
  get raw() {
    return this.numerator;
  }
  isZero() {
    return this.raw.isZero();
  }
  gt(J) {
    return p$.assert(N$(this.currency, J.currency), "gt currency not equals"), this.raw.gt(J.raw);
  }
  lt(J) {
    return p$.assert(N$(this.currency, J.currency), "lt currency not equals"), this.raw.lt(J.raw);
  }
  add(J) {
    return p$.assert(N$(this.currency, J.currency), "add currency not equals"), new r0(this.currency, this.raw.add(J.raw));
  }
  sub(J) {
    return p$.assert(N$(this.currency, J.currency), "sub currency not equals"), new r0(this.currency, this.raw.sub(J.raw));
  }
  toSignificant(J = this.currency.decimals, $, H = nJ.ROUND_DOWN) {
    return super.toSignificant(J, $, H);
  }
  toFixed(J = this.currency.decimals, $, H = nJ.ROUND_DOWN) {
    return p$.assert(J <= this.currency.decimals, "decimals overflow"), super.toFixed(J, $, H);
  }
  toExact(J = { groupSeparator: "" }) {
    return _Z.DP = this.currency.decimals, new _Z(this.numerator.toString()).div(this.denominator.toString()).toFormat(J);
  }
}

class O0 extends r0 {
  constructor(J, $, H = true) {
    super(J, $, H);
    this.token = J;
  }
  add(J) {
    return p$.assert(N$(this.token, J.token), "add token not equals"), new O0(this.token, this.raw.add(J.raw));
  }
  subtract(J) {
    return p$.assert(N$(this.token, J.token), "sub token not equals"), new O0(this.token, this.raw.sub(J.raw));
  }
}
var PZ = new y0(LZ);

class uJ extends y0 {
  toSignificant(J = 5, $, H) {
    return this.mul(PZ).toSignificant(J, $, H);
  }
  toFixed(J = 2, $, H) {
    return this.mul(PZ).toFixed(J, $, H);
  }
}
var xz = U0.from("entity/price");

class PJ extends y0 {
  constructor(J, $, H, Q) {
    super(Q, $);
    this.baseCurrency = J, this.quoteCurrency = H, this.scalar = new y0(L6(J.decimals), L6(H.decimals));
  }
  get raw() {
    return new y0(this.numerator, this.denominator);
  }
  get adjusted() {
    return super.mul(this.scalar);
  }
  invert() {
    return new PJ(this.quoteCurrency, this.numerator, this.baseCurrency, this.denominator);
  }
  mul(J) {
    xz.assert(N$(this.quoteCurrency, J.baseCurrency), "mul currency not equals");
    const $ = super.mul(J);
    return new PJ(this.baseCurrency, $.denominator, J.quoteCurrency, $.numerator);
  }
  toSignificant(J = this.quoteCurrency.decimals, $, H) {
    return this.adjusted.toSignificant(J, $, H);
  }
  toFixed(J = this.quoteCurrency.decimals, $, H) {
    return this.adjusted.toFixed(J, $, H);
  }
}
var PH = E0(EJ(), 1);
var j0 = E0(pJ(), 1);
var eQ = j0.Layout;
var NZ = j0.Structure;
var K6 = j0.UInt;
var gZ = j0.u8;
var UH = j0.u16;
var h6 = j0.u32;
var kJ = j0.s32;
var kZ = j0.seq;
var p0 = j0.blob;
var E6 = j0.bits;

class NH extends eQ {
  constructor(J, $, H) {
    super(J, H);
    this.blob = p0(J), this.signed = $;
  }
  decode(J, $ = 0) {
    const H = new PH.default(this.blob.decode(J, $), 10, "le");
    if (this.signed)
      return H.fromTwos(this.span * 8).clone();
    return H;
  }
  encode(J, $, H = 0) {
    if (typeof J === "number")
      J = new PH.default(J);
    if (this.signed)
      J = J.toTwos(this.span * 8);
    return this.blob.encode(J.toArrayLike(Buffer, "le", this.span), $, H);
  }
}

class S6 extends eQ {
  constructor(J) {
    super(8, J);
    this._lower = E6(h6(), false), this._upper = E6(h6(), false);
  }
  addBoolean(J) {
    if (this._lower.fields.length < 32)
      this._lower.addBoolean(J);
    else
      this._upper.addBoolean(J);
  }
  decode(J, $ = 0) {
    const H = this._lower.decode(J, $), Q = this._upper.decode(J, $ + this._lower.span);
    return { ...H, ...Q };
  }
  encode(J, $, H = 0) {
    return this._lower.encode(J, $, H) + this._upper.encode(J, $, H + this._lower.span);
  }
}

class w6 extends eQ {
  constructor(J, $, H, Q) {
    super(J.span, Q);
    this.layout = J, this.decoder = $, this.encoder = H;
  }
  decode(J, $) {
    return this.decoder(this.layout.decode(J, $));
  }
  encode(J, $, H) {
    return this.layout.encode(this.encoder(J), $, H);
  }
  getSpan(J, $) {
    return this.layout.getSpan(J, $);
  }
}

class TZ extends NZ {
  decode(J, $) {
    return super.decode(J, $);
  }
}
var MF = e([yJ("mintAuthorityOption"), c("mintAuthority"), P("supply"), o("decimals"), o("isInitialized"), yJ("freezeAuthorityOption"), c("freezeAuthority")]);
var $$ = e([c("mint"), c("owner"), P("amount"), yJ("delegateOption"), c("delegate"), o("state"), yJ("isNativeOption"), P("isNative"), P("delegatedAmount"), yJ("closeAuthorityOption"), c("closeAuthority")]);
var fZ = E0(EJ(), 1);

class _0 {
  static getAssociatedTokenAccount({ mint: J, owner: $, programId: H }) {
    return n0($, J, H).publicKey;
  }
  static makeCreateAssociatedTokenAccountInstruction({ programId: J, mint: $, associatedAccount: H, owner: Q, payer: W, instructionsType: Z }) {
    return Z.push($0.createATA), TQ(W, H, Q, $, J);
  }
  static async makeCreateWrappedNativeAccountInstructions({ connection: J, owner: $, payer: H, amount: Q, commitment: W }) {
    const Z = [], Y = [], z = await J.getMinimumBalanceForRentExemption($$.span, W), j = H0(Q).add(new fZ.default(z)), V = g$({ fromPublicKey: H, programId: m2 });
    return Z.push($SystemProgram.createAccountWithSeed({ fromPubkey: H, basePubkey: H, seed: V.seed, newAccountPubkey: V.publicKey, lamports: j.toNumber(), space: $$.span, programId: m2 })), Y.push($0.createAccount), Z.push(this.makeInitAccountInstruction({ programId: m2, mint: VH(SJ.mint), tokenAccount: V.publicKey, owner: $, instructionTypes: Y })), { address: { newAccount: V.publicKey }, innerTransaction: { instructions: Z, signers: [], lookupTableAddress: [], instructionTypes: Y } };
  }
  static async insertCreateWrappedNativeAccount({ connection: J, owner: $, payer: H, amount: Q, instructions: W, instructionsType: Z, signers: Y, commitment: z }) {
    const j = await this.makeCreateWrappedNativeAccountInstructions({ connection: J, owner: $, payer: H, amount: Q, commitment: z });
    return W.push(...j.innerTransaction.instructions), Y.push(...j.innerTransaction.signers), Z.push(...j.innerTransaction.instructionTypes), j.address.newAccount;
  }
  static makeInitMintInstruction({ programId: J, mint: $, decimals: H, mintAuthority: Q, freezeAuthority: W = null, instructionTypes: Z }) {
    return Z.push($0.initMint), oW($, H, Q, W, J);
  }
  static makeMintToInstruction({ programId: J, mint: $, dest: H, authority: Q, amount: W, multiSigners: Z = [], instructionTypes: Y }) {
    return Y.push($0.mintTo), rW($, H, Q, BigInt(String(W)), Z, J);
  }
  static makeInitAccountInstruction({ programId: J, mint: $, tokenAccount: H, owner: Q, instructionTypes: W }) {
    return W.push($0.initAccount), cW(H, $, Q, J);
  }
  static makeTransferInstruction({ programId: J, source: $, destination: H, owner: Q, amount: W, multiSigners: Z = [], instructionsType: Y }) {
    return Y.push($0.transferAmount), eW($, H, Q, BigInt(String(W)), Z, J);
  }
  static makeCloseAccountInstruction({ programId: J, tokenAccount: $, owner: H, payer: Q, multiSigners: W = [], instructionsType: Z }) {
    return Z.push($0.closeAccount), _Q($, Q, H, W, J);
  }
  static createInitAccountInstruction(J, $, H, Q) {
    const W = [{ pubkey: H, isSigner: false, isWritable: true }, { pubkey: $, isSigner: false, isWritable: false }, { pubkey: Q, isSigner: false, isWritable: false }, { pubkey: $SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }], Z = o("instruction"), Y = Buffer.alloc(Z.span);
    return Z.encode(1, Y), new $TransactionInstruction({ keys: W, programId: J, data: Y });
  }
}
var GH;
(function(J) {
  J[J.V0 = 0] = "V0", J[J.LEGACY = 1] = "LEGACY";
})(GH || (GH = {}));
var $0;
(function(J) {
  J[J.createAccount = 0] = "createAccount", J[J.initAccount = 1] = "initAccount", J[J.createATA = 2] = "createATA", J[J.closeAccount = 3] = "closeAccount", J[J.transferAmount = 4] = "transferAmount", J[J.initMint = 5] = "initMint", J[J.mintTo = 6] = "mintTo", J[J.initMarket = 7] = "initMarket", J[J.util1216OwnerClaim = 8] = "util1216OwnerClaim", J[J.setComputeUnitPrice = 9] = "setComputeUnitPrice", J[J.setComputeUnitLimit = 10] = "setComputeUnitLimit", J[J.clmmCreatePool = 11] = "clmmCreatePool", J[J.clmmOpenPosition = 12] = "clmmOpenPosition", J[J.clmmIncreasePosition = 13] = "clmmIncreasePosition", J[J.clmmDecreasePosition = 14] = "clmmDecreasePosition", J[J.clmmClosePosition = 15] = "clmmClosePosition", J[J.clmmSwapBaseIn = 16] = "clmmSwapBaseIn", J[J.clmmSwapBaseOut = 17] = "clmmSwapBaseOut", J[J.clmmInitReward = 18] = "clmmInitReward", J[J.clmmSetReward = 19] = "clmmSetReward", J[J.clmmCollectReward = 20] = "clmmCollectReward", J[J.ammV4Swap = 21] = "ammV4Swap", J[J.ammV4AddLiquidity = 22] = "ammV4AddLiquidity", J[J.ammV4RemoveLiquidity = 23] = "ammV4RemoveLiquidity", J[J.ammV4SimulatePoolInfo = 24] = "ammV4SimulatePoolInfo", J[J.ammV4SwapBaseIn = 25] = "ammV4SwapBaseIn", J[J.ammV4SwapBaseOut = 26] = "ammV4SwapBaseOut", J[J.ammV4CreatePool = 27] = "ammV4CreatePool", J[J.ammV4InitPool = 28] = "ammV4InitPool", J[J.ammV4CreatePoolV2 = 29] = "ammV4CreatePoolV2", J[J.ammV5AddLiquidity = 30] = "ammV5AddLiquidity", J[J.ammV5RemoveLiquidity = 31] = "ammV5RemoveLiquidity", J[J.ammV5SimulatePoolInfo = 32] = "ammV5SimulatePoolInfo", J[J.ammV5SwapBaseIn = 33] = "ammV5SwapBaseIn", J[J.ammV5SwapBaseOut = 34] = "ammV5SwapBaseOut", J[J.routeSwap = 35] = "routeSwap", J[J.routeSwap1 = 36] = "routeSwap1", J[J.routeSwap2 = 37] = "routeSwap2", J[J.farmV3Deposit = 38] = "farmV3Deposit", J[J.farmV3Withdraw = 39] = "farmV3Withdraw", J[J.farmV3CreateLedger = 40] = "farmV3CreateLedger", J[J.farmV5Deposit = 41] = "farmV5Deposit", J[J.farmV5Withdraw = 42] = "farmV5Withdraw", J[J.farmV5CreateLedger = 43] = "farmV5CreateLedger", J[J.farmV6Deposit = 44] = "farmV6Deposit", J[J.farmV6Withdraw = 45] = "farmV6Withdraw", J[J.farmV6Create = 46] = "farmV6Create", J[J.farmV6Restart = 47] = "farmV6Restart", J[J.farmV6CreatorAddReward = 48] = "farmV6CreatorAddReward", J[J.farmV6CreatorWithdraw = 49] = "farmV6CreatorWithdraw", J[J.test = 50] = "test";
})($0 || ($0 = {}));
var uz = function(J, $, H) {
  const Q = Buffer.concat([J.toBuffer(), Buffer.from($), H.toBuffer()]), W = QZ(Q);
  return new $PublicKey(W);
};

class V$ {
  static _selectTokenAccount(J) {
    const { tokenAccounts: $, programId: H, mint: Q, owner: W, config: Z } = J, { associatedOnly: Y } = { ...{ associatedOnly: true }, ...Z }, z = $.filter(({ accountInfo: V }) => V.mint.equals(Q)).sort((V, U) => V.accountInfo.amount.lt(U.accountInfo.amount) ? 1 : -1), j = _0.getAssociatedTokenAccount({ mint: Q, owner: W, programId: H });
    for (let V of z) {
      const { pubkey: U } = V;
      if (Y) {
        if (j.equals(U))
          return U;
      } else
        return U;
    }
    return null;
  }
  static async _handleTokenAccount(J) {
    const { connection: $, side: H, amount: Q, programId: W, mint: Z, tokenAccount: Y, owner: z, payer: j = z, frontInstructions: V, endInstructions: U, signers: C, bypassAssociatedCheck: q, frontInstructionsType: K, endInstructionsType: w2, checkCreateATAOwner: O } = J, h2 = _0.getAssociatedTokenAccount({ mint: Z, owner: z, programId: W });
    if (r.WSOL.mint.equals(Z)) {
      const b = await _0.insertCreateWrappedNativeAccount({ connection: $, owner: z, payer: j, instructions: V, instructionsType: K, signers: C, amount: Q });
      if (U)
        U.push(_0.makeCloseAccountInstruction({ programId: m2, tokenAccount: b, owner: z, payer: j, instructionsType: w2 ?? [] }));
      return b;
    } else if (!Y || H === "out" && !h2.equals(Y) && !q) {
      const b = _0.makeCreateAssociatedTokenAccountInstruction({ programId: W, mint: Z, associatedAccount: h2, owner: z, payer: j, instructionsType: K });
      if (O) {
        const N = await $.getAccountInfo(h2);
        if (N === null)
          V.push(b);
        else if (N.owner.equals(m2) && _$.decode(N.data).mint.equals(Z) && _$.decode(N.data).owner.equals(z))
          ;
        else
          throw Error(`create ata check error -> mint: ${Z.toString()}, ata: ${h2.toString()}`);
      } else
        V.push(b);
      return h2;
    }
    return Y;
  }
  static async _selectOrCreateTokenAccount(J) {
    const { mint: $, tokenAccounts: H, createInfo: Q, associatedOnly: W, owner: Z, checkCreateATAOwner: Y, programId: z } = J, j = _0.getAssociatedTokenAccount({ mint: $, owner: Z, programId: z }), V = H.filter((U) => U.accountInfo.mint.equals($) && (!W || U.pubkey.equals(j))).sort((U, C) => U.accountInfo.amount.lt(C.accountInfo.amount) ? 1 : -1);
    if (Q === undefined || V.length > 0)
      return V.length > 0 ? V[0].pubkey : undefined;
    if (W) {
      const U = _0.makeCreateAssociatedTokenAccountInstruction({ programId: z, mint: $, associatedAccount: j, owner: Z, payer: Q.payer, instructionsType: Q.frontInstructionsType });
      if (Y) {
        const C = await Q.connection.getAccountInfo(j);
        if (C === null)
          Q.frontInstructions.push(U);
        else if (C.owner.equals(z) && _$.decode(C.data).mint.equals($) && _$.decode(C.data).owner.equals(Z))
          ;
        else
          throw Error(`create ata check error -> mint: ${$.toString()}, ata: ${j.toString()}`);
      } else
        Q.frontInstructions.push(U);
      if ($.equals(r.WSOL.mint) && Q.amount) {
        const C = await _0.insertCreateWrappedNativeAccount({ connection: Q.connection, owner: Z, payer: Q.payer, instructions: Q.frontInstructions, instructionsType: Q.frontInstructionsType, signers: Q.signers, amount: Q.amount ?? 0 });
        if ((Q.endInstructions ?? []).push(_0.makeCloseAccountInstruction({ programId: m2, tokenAccount: C, owner: Z, payer: Q.payer, instructionsType: Q.endInstructionsType ?? [] })), Q.amount)
          Q.frontInstructions.push(_0.makeTransferInstruction({ programId: m2, source: C, destination: j, owner: Z, amount: Q.amount, instructionsType: Q.frontInstructionsType }));
      }
      return (Q.endInstructions ?? []).push(_0.makeCloseAccountInstruction({ programId: z, tokenAccount: j, owner: Z, payer: Q.payer, instructionsType: Q.endInstructionsType ?? [] })), j;
    } else if ($.equals(r.WSOL.mint)) {
      const U = await _0.insertCreateWrappedNativeAccount({ connection: Q.connection, owner: Z, payer: Q.payer, instructions: Q.frontInstructions, instructionsType: Q.frontInstructionsType, signers: Q.signers, amount: Q.amount ?? 0 });
      return (Q.endInstructions ?? []).push(_0.makeCloseAccountInstruction({ programId: m2, tokenAccount: U, owner: Z, payer: Q.payer, instructionsType: Q.endInstructionsType ?? [] })), U;
    } else {
      const U = g$({ fromPublicKey: Z, programId: z }), C = await Q.connection.getMinimumBalanceForRentExemption(_$.span), q = $SystemProgram.createAccountWithSeed({ fromPubkey: Z, basePubkey: Z, seed: U.seed, newAccountPubkey: U.publicKey, lamports: C, space: _$.span, programId: z }), K = _0.createInitAccountInstruction(z, $, U.publicKey, Z);
      return Q.frontInstructions.push(q, K), Q.frontInstructionsType.push($0.createAccount, $0.initAccount), (Q.endInstructions ?? []).push(_0.makeCloseAccountInstruction({ programId: z, tokenAccount: U.publicKey, owner: Z, payer: Q.payer, instructionsType: Q.endInstructionsType ?? [] })), U.publicKey;
    }
  }
}
var aF = { "2immgwYNHBbyVQKVGCEkgWpi53bLwWNRMB5G2nbgYV17": new $AddressLookupTableAccount({ key: new $PublicKey("2immgwYNHBbyVQKVGCEkgWpi53bLwWNRMB5G2nbgYV17"), state: $AddressLookupTableAccount.deserialize(Buffer.from("AQAAAP//////////d49+DAAAAAAAAQZMWvw7GUNJdaccNBVnb57OKakxL2BHLYvhRwVILRsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAABt324ddloZPZy+FGzut5rBy0he1fWzeROoz1hX7/AKkG3fbh7nWP3hhCXbzkbM3athr8TYO5DSf+vfko2KGL/AVKU1D4XciC1hSlVnJ4iilt3x6rq9CmBniISTL07vagBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvDQdRqCgtphMF/imcN7mY5YRx2xE1A3MQ+L4QRaYK9u4GRfZP3LsAd00a+IkCpA22UNQMKdq5BFbJuwuOLqc8zxCTDlqxBG8J0HcxtfogQHDK06ukzfaXiNDKAob1MqBHS9lJxDYCwz8gd5DtFqNSTKG5l1zxIaKpDP/sffi2is1H9aKveyXSu5StXElYRl9SD5As0DHE4N0GLnf84/siiKXVyp4Ez121kLcUui/jLLFZEz/BwZK3Ilf9B9OcsEAeDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu9N9LMnrw/JNO0hqMVB4rk/2ou4AB1loQ7FZoPwut2o4KZB+0p9xnbrQKw038qjpHar+PyDwvxBRcu5hpHw3dguezeWv+IwvgW5icu8EGkhGa9AkFPPJT7VMSFb8xowveU=", "base64")) }) };
var B$ = E0(EJ(), 1);
var tH = 1e4;
var NJ = E0(EJ(), 1);
var $Q = { voterStakeRegistryCreateVoter: Buffer.from([6, 24, 245, 52, 243, 255, 148, 25]), voterStakeRegistryCreateDepositEntry: Buffer.from([185, 131, 167, 186, 159, 125, 19, 67]), voterStakeRegistryDeposit: Buffer.from([242, 35, 198, 137, 82, 225, 242, 182]), voterStakeRegistryWithdraw: Buffer.from([183, 18, 70, 156, 148, 109, 161, 34]), voterStakeRegistryUpdateVoterWeightRecord: Buffer.from([45, 185, 3, 36, 109, 190, 115, 169]) };
var _6 = e([P("state"), P("nonce"), c("lpVault"), c("rewardVault"), c(), c(), P(), P(), P("totalReward"), G0("perShareReward"), P("lastSlot"), P("perSlotReward")]);
var P6 = e([P("state"), P("nonce"), c("lpVault"), c("rewardVaultA"), P("totalRewardA"), G0("perShareRewardA"), P("perSlotRewardA"), o("option"), c("rewardVaultB"), p0(7), P("totalRewardB"), G0("perShareRewardB"), P("perSlotRewardB"), P("lastSlot"), c()]);
var sz = e([P("rewardState"), P("rewardOpenTime"), P("rewardEndTime"), P("rewardLastUpdateTime"), P("totalReward"), P("totalRewardEmissioned"), P("rewardClaimed"), P("rewardPerSecond"), G0("accRewardPerShare"), c("rewardVault"), c("rewardMint"), c("rewardSender"), P("rewardType"), z0(P(), 15, "padding")]);
var az = e([P(), P("state"), P("nonce"), P("validRewardTokenNum"), G0("rewardMultiplier"), P("rewardPeriodMax"), P("rewardPeriodMin"), P("rewardPeriodExtend"), c("lpMint"), c("lpVault"), z0(sz, 5, "rewardInfos"), c("creator"), c(), z0(P(), 32, "padding")]);
var iz = new Proxy(_6, { get(J, $, H) {
  if ($ === "decode")
    return (...Q) => {
      const W = J.decode(...Q);
      return { ...W, version: 3, rewardInfos: [{ rewardVault: W.rewardVault, totalReward: W.totalReward, perSlotReward: W.perSlotReward, perShareReward: W.perShareReward }] };
    };
  else
    return Reflect.get(J, $, H);
} });
var rz = new Proxy(P6, { get(J, $, H) {
  if ($ === "decode")
    return (...Q) => {
      const W = J.decode(...Q);
      return { ...W, version: 5, rewardInfos: [{ rewardVault: W.rewardVaultA, totalReward: W.totalRewardA, perSlotReward: W.perSlotRewardA, perShareReward: W.perShareRewardA }, { rewardVault: W.rewardVaultB, totalReward: W.totalRewardB, perSlotReward: W.perSlotRewardB, perShareReward: W.perShareRewardB }] };
    };
  else
    return Reflect.get(J, $, H);
} });
var kH = new Proxy(az, { get(J, $, H) {
  if ($ === "decode")
    return (...Q) => {
      const W = J.decode(...Q);
      return { ...W, version: 6, rewardInfos: W.rewardInfos.map((Z) => ({ ...Z, rewardType: (Object.entries(DH).find((Y) => String(Y[1]) === Z.rewardType.toString()) ?? ["Standard SPL"])[0] })) };
    };
  else
    return Reflect.get(J, $, H);
} });
var N6 = e([P("state"), c("id"), c("owner"), P("deposited"), z0(P(), 1, "rewardDebts")]);
var HQ = e([P("state"), c("id"), c("owner"), P("deposited"), z0(G0(), 1, "rewardDebts"), P(""), P("voteLockedBalance"), z0(P(), 15)]);
var g6 = e([P("state"), c("id"), c("owner"), P("deposited"), z0(P(), 2, "rewardDebts")]);
var k6 = e([P("state"), c("id"), c("owner"), P("deposited"), z0(G0(), 2, "rewardDebts"), z0(P(), 17)]);
var nz = e([P(), P("state"), c("id"), c("owner"), P("deposited"), z0(G0(), 5, "rewardDebts"), z0(P(), 16)]);
var cZ = { 3: iz, 5: rz, 6: kH };
var sZ = { 3: HQ, 5: k6, 6: nz };
var ez = e([c("mint"), c("grantAuthority"), P("baselineVoteWeightScaledFactor"), P("maxExtraLockupVoteWeightScaledFactor"), P("lockupSaturationSecs"), xZ("digitShift"), z0(o(), 7, "reserved1"), z0(P(), 7, "reserved2")]);
var aZ = e([p0(8), c("governanceProgramId"), c("realm"), c("realmGoverningTokenMint"), c("realmAuthority"), z0(o(), 32, "reserved1"), z0(ez, 4, "votingMints"), tQ("timeOffset"), o("bump"), z0(o(), 7, "reserved2"), z0(P(), 11, "reserved3")]);
var tz = e([tQ("startTime"), tQ("endTime"), o("kind"), z0(o(), 15, "reserved")]);
var oz = e([z0(tz, 1, "lockup"), P("amountDeposited_native"), P("amountInitiallyLockedNative"), cJ("isUsed"), cJ("allowClawback"), o("votingMintConfigIdx"), z0(o(), 29, "reserved")]);
var iZ = e([p0(8), c("voterAuthority"), c("registrar"), z0(oz, 32, "deposits"), o("voterBump"), o("voterWweightRecordBump"), z0(o(), 94, "reserved")]);
var M0 = U0.from("Farm");
var DH = { "Standard SPL": 0, "Option tokens": 1 };

class aJ extends V$ {
  static getStateLayout(J) {
    const $ = cZ[J];
    return M0.assertArgument(!!$, "invalid version", "version", J), $;
  }
  static getLedgerLayout(J) {
    const $ = sZ[J];
    return M0.assertArgument(!!$, "invalid version", "version", J), $;
  }
  static getLayouts(J) {
    return { state: this.getStateLayout(J), ledger: this.getLedgerLayout(J) };
  }
  static getAssociatedAuthority({ programId: J, poolId: $ }) {
    return h0([$.toBuffer()], J);
  }
  static getAssociatedLedgerAccount({ programId: J, poolId: $, owner: H, version: Q }) {
    const { publicKey: W } = h0([$.toBuffer(), H.toBuffer(), Buffer.from(Q === 6 ? "farmer_info_associated_seed" : "staker_info_v2_associated_seed", "utf-8")], J);
    return W;
  }
  static getAssociatedLedgerPoolAccount({ programId: J, poolId: $, mint: H, type: Q }) {
    const { publicKey: W } = h0([$.toBuffer(), H.toBuffer(), Buffer.from(Q === "lpVault" ? "lp_vault_associated_seed" : Q === "rewardVault" ? "reward_vault_associated_seed" : "", "utf-8")], J);
    return W;
  }
  static makeDepositInstruction(J) {
    const { poolKeys: $ } = J, { version: H } = $;
    if (H === 3)
      return this.makeDepositInstructionV3(J);
    else if (H === 5)
      return this.makeDepositInstructionV5(J);
    else if (H === 6)
      return this.makeDepositInstructionV6(J);
    return M0.throwArgumentError("invalid version", "poolKeys.version", H);
  }
  static makeDepositInstructionV3({ poolKeys: J, userKeys: $, amount: H }) {
    M0.assertArgument(J.rewardInfos.length === 1, "lengths not equal 1", "poolKeys.rewardInfos", J.rewardInfos), M0.assertArgument($.rewardTokenAccounts.length === 1, "lengths not equal 1", "userKeys.rewardTokenAccounts", $.rewardTokenAccounts);
    const Q = e([o("instruction"), P("amount")]), W = Buffer.alloc(Q.span);
    Q.encode({ instruction: 10, amount: H0(H) }, W);
    const Z = [y2(J.id, false), d2(J.authority, false), y2($.ledger, false), d2($.owner, true), y2($.lpTokenAccount, false), y2(J.lpVault, false), y2($.rewardTokenAccounts[0], false), y2(J.rewardInfos[0].rewardVault, false), d2($SYSVAR_CLOCK_PUBKEY, false), d2(m2, false)];
    if ($.auxiliaryLedgers)
      for (let Y of $.auxiliaryLedgers)
        Z.push(y2(Y, false));
    return { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: Z, data: W })], signers: [], lookupTableAddress: [], instructionTypes: [$0.farmV3Deposit] } };
  }
  static makeDepositInstructionV5({ poolKeys: J, userKeys: $, amount: H }) {
    M0.assertArgument($.rewardTokenAccounts.length === J.rewardInfos.length, "lengths not equal with poolKeys.rewardInfos", "userKeys.rewardTokenAccounts", $.rewardTokenAccounts);
    const Q = e([o("instruction"), P("amount")]), W = Buffer.alloc(Q.span);
    Q.encode({ instruction: 11, amount: H0(H) }, W);
    const Z = [y2(J.id, false), d2(J.authority, false), y2($.ledger, false), d2($.owner, true), y2($.lpTokenAccount, false), y2(J.lpVault, false), y2($.rewardTokenAccounts[0], false), y2(J.rewardInfos[0].rewardVault, false), d2($SYSVAR_CLOCK_PUBKEY, false), d2(m2, false)];
    for (let Y = 1;Y < J.rewardInfos.length; Y++)
      Z.push(y2($.rewardTokenAccounts[Y], false)), Z.push(y2(J.rewardInfos[Y].rewardVault, false));
    if ($.auxiliaryLedgers)
      for (let Y of $.auxiliaryLedgers)
        Z.push(y2(Y, false));
    return { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: Z, data: W })], signers: [], lookupTableAddress: [], instructionTypes: [$0.farmV5Deposit] } };
  }
  static makeDepositInstructionV6({ poolKeys: J, userKeys: $, amount: H }) {
    M0.assertArgument($.rewardTokenAccounts.length !== 0, "lengths equal zero", "userKeys.rewardTokenAccounts", $.rewardTokenAccounts), M0.assertArgument($.rewardTokenAccounts.length === J.rewardInfos.length, "lengths not equal with poolKeys.rewardInfos", "userKeys.rewardTokenAccounts", $.rewardTokenAccounts);
    const Q = e([o("instruction"), P("amount")]), W = Buffer.alloc(Q.span);
    Q.encode({ instruction: 1, amount: H0(H) }, W);
    const Z = [d2(m2, false), d2(t0, false), y2(J.id, false), d2(J.authority, false), y2(J.lpVault, false), y2($.ledger, false), d2($.owner, true), y2($.lpTokenAccount, false)];
    for (let Y = 0;Y < J.rewardInfos.length; Y++)
      Z.push(y2(J.rewardInfos[Y].rewardVault, false)), Z.push(y2($.rewardTokenAccounts[Y], false));
    return { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: Z, data: W })], signers: [], lookupTableAddress: [], instructionTypes: [$0.farmV6Deposit] } };
  }
  static makeWithdrawInstruction(J) {
    const { poolKeys: $ } = J, { version: H } = $;
    if (H === 3)
      return this.makeWithdrawInstructionV3(J);
    else if (H === 5)
      return this.makeWithdrawInstructionV5(J);
    else if (H === 6)
      return this.makeWithdrawInstructionV6(J);
    return M0.throwArgumentError("invalid version", "poolKeys.version", H);
  }
  static makeWithdrawInstructionV3({ poolKeys: J, userKeys: $, amount: H }) {
    M0.assertArgument(J.rewardInfos.length === 1, "lengths not equal 1", "poolKeys.rewardInfos", J.rewardInfos), M0.assertArgument($.rewardTokenAccounts.length === 1, "lengths not equal 1", "userKeys.rewardTokenAccounts", $.rewardTokenAccounts);
    const Q = e([o("instruction"), P("amount")]), W = Buffer.alloc(Q.span);
    Q.encode({ instruction: 11, amount: H0(H) }, W);
    const Z = [y2(J.id, false), d2(J.authority, false), y2($.ledger, false), d2($.owner, true), y2($.lpTokenAccount, false), y2(J.lpVault, false), y2($.rewardTokenAccounts[0], false), y2(J.rewardInfos[0].rewardVault, false), d2($SYSVAR_CLOCK_PUBKEY, false), d2(m2, false)];
    if ($.auxiliaryLedgers)
      for (let Y of $.auxiliaryLedgers)
        Z.push(y2(Y, false));
    return { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: Z, data: W })], signers: [], lookupTableAddress: [], instructionTypes: [$0.farmV5Deposit] } };
  }
  static makeWithdrawInstructionV5({ poolKeys: J, userKeys: $, amount: H }) {
    M0.assertArgument($.rewardTokenAccounts.length === J.rewardInfos.length, "lengths not equal with params.poolKeys.rewardInfos", "userKeys.rewardTokenAccounts", $.rewardTokenAccounts);
    const Q = e([o("instruction"), P("amount")]), W = Buffer.alloc(Q.span);
    Q.encode({ instruction: 12, amount: H0(H) }, W);
    const Z = [y2(J.id, false), d2(J.authority, false), y2($.ledger, false), d2($.owner, true), y2($.lpTokenAccount, false), y2(J.lpVault, false), y2($.rewardTokenAccounts[0], false), y2(J.rewardInfos[0].rewardVault, false), d2($SYSVAR_CLOCK_PUBKEY, false), d2(m2, false)];
    for (let Y = 1;Y < J.rewardInfos.length; Y++)
      Z.push(y2($.rewardTokenAccounts[Y], false)), Z.push(y2(J.rewardInfos[Y].rewardVault, false));
    if ($.auxiliaryLedgers)
      for (let Y of $.auxiliaryLedgers)
        Z.push(y2(Y, false));
    return { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: Z, data: W })], signers: [], lookupTableAddress: [], instructionTypes: [$0.farmV5Withdraw] } };
  }
  static makeWithdrawInstructionV6({ poolKeys: J, userKeys: $, amount: H }) {
    M0.assertArgument($.rewardTokenAccounts.length !== 0, "lengths equal zero", "userKeys.rewardTokenAccounts", $.rewardTokenAccounts), M0.assertArgument($.rewardTokenAccounts.length === J.rewardInfos.length, "lengths not equal with params.poolKeys.rewardInfos", "userKeys.rewardTokenAccounts", $.rewardTokenAccounts);
    const Q = e([o("instruction"), P("amount")]), W = Buffer.alloc(Q.span);
    Q.encode({ instruction: 2, amount: H0(H) }, W);
    const Z = [d2(m2, false), y2(J.id, false), d2(J.authority, false), y2(J.lpVault, false), y2($.ledger, false), d2($.owner, true), y2($.lpTokenAccount, false)];
    for (let Y = 0;Y < J.rewardInfos.length; Y++)
      Z.push(y2(J.rewardInfos[Y].rewardVault, false)), Z.push(y2($.rewardTokenAccounts[Y], false));
    return { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: Z, data: W })], signers: [], lookupTableAddress: [], instructionTypes: [$0.farmV6Withdraw] } };
  }
  static makeCreateAssociatedLedgerAccountInstruction(J) {
    const { poolKeys: $ } = J, { version: H } = $;
    if (H === 3)
      return this.makeCreateAssociatedLedgerAccountInstructionV3(J);
    else if (H === 5)
      return this.makeCreateAssociatedLedgerAccountInstructionV5(J);
    return M0.throwArgumentError("invalid version", "poolKeys.version", H);
  }
  static makeCreateAssociatedLedgerAccountInstructionV3({ poolKeys: J, userKeys: $ }) {
    const H = e([o("instruction")]), Q = Buffer.alloc(H.span);
    H.encode({ instruction: 9 }, Q);
    const W = [y2(J.id, false), y2($.ledger, false), d2($.owner, true), d2(t0, false), d2($SYSVAR_RENT_PUBKEY, false)];
    return { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: W, data: Q })], signers: [], lookupTableAddress: [], instructionTypes: [$0.farmV3CreateLedger] } };
  }
  static makeCreateAssociatedLedgerAccountInstructionV5({ poolKeys: J, userKeys: $ }) {
    const H = e([o("instruction")]), Q = Buffer.alloc(H.span);
    H.encode({ instruction: 10 }, Q);
    const W = [y2(J.id, false), y2($.ledger, false), d2($.owner, true), d2(t0, false), d2($SYSVAR_RENT_PUBKEY, false)];
    return { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: W, data: Q })], signers: [], lookupTableAddress: [], instructionTypes: [$0.farmV5CreateLedger] } };
  }
  static makeCreateFarmInstruction({ connection: J, userKeys: $, poolInfo: H }) {
    const { version: Q } = H;
    if (Q === 6)
      return this.makeCreateFarmInstructionV6({ connection: J, userKeys: $, poolInfo: H });
    return M0.throwArgumentError("invalid version", "version", Q);
  }
  static async makeCreateFarmInstructionV6({ connection: J, userKeys: $, poolInfo: H }) {
    const Q = $.payer ?? $.owner, W = g$({ fromPublicKey: Q, programId: H.programId }), Z = await J.getMinimumBalanceForRentExemption(kH.span), Y = [], z = [], j = [], V = [], U = [];
    Y.push($SystemProgram.createAccountWithSeed({ fromPubkey: Q, basePubkey: Q, seed: W.seed, newAccountPubkey: W.publicKey, lamports: Z, space: kH.span, programId: H.programId }));
    const { publicKey: C, nonce: q } = aJ.getAssociatedAuthority({ programId: H.programId, poolId: W.publicKey }), K = aJ.getAssociatedLedgerPoolAccount({ programId: H.programId, poolId: W.publicKey, mint: H.lpMint, type: "lpVault" }), w2 = [], O = [];
    for (let A of H.rewardInfos) {
      M0.assertArgument(A.rewardOpenTime < A.rewardEndTime, "start time error", "rewardInfo.rewardOpenTime", A.rewardOpenTime), M0.assertArgument(DH[A.rewardType] !== undefined, "reward type error", "rewardInfo.rewardType", A.rewardType), M0.assertArgument(H0(A.rewardPerSecond).gt(J0), "rewardPerSecond error", "rewardInfo.rewardPerSecond", A.rewardPerSecond), w2.push({ isSet: new NJ.default(1), rewardPerSecond: H0(A.rewardPerSecond), rewardOpenTime: H0(A.rewardOpenTime), rewardEndTime: H0(A.rewardEndTime), rewardType: H0(DH[A.rewardType]) });
      let I;
      if (A.rewardMint.equals($PublicKey.default))
        I = await _0.insertCreateWrappedNativeAccount({ connection: J, owner: $.owner, payer: $.payer ?? $.owner, instructions: Y, signers: U, amount: H0(A.rewardEndTime).sub(H0(A.rewardOpenTime)).mul(H0(A.rewardPerSecond)), instructionsType: j }), z.push(_0.makeCloseAccountInstruction({ programId: m2, tokenAccount: I, owner: $.owner, payer: $.payer ?? $.owner, instructionsType: V }));
      else
        I = this._selectTokenAccount({ programId: m2, tokenAccounts: $.tokenAccounts, mint: A.rewardMint, owner: $.owner, config: { associatedOnly: false } });
      M0.assertArgument(I !== null, "cannot found target token accounts", "tokenAccounts", $.tokenAccounts);
      const T = A.rewardMint.equals($PublicKey.default) ? r.WSOL.mint : A.rewardMint;
      O.push({ rewardMint: T, rewardVault: aJ.getAssociatedLedgerPoolAccount({ programId: H.programId, poolId: W.publicKey, mint: T, type: "rewardVault" }), userRewardToken: I });
    }
    const h2 = this._selectTokenAccount({ programId: m2, tokenAccounts: $.tokenAccounts, mint: H.lockInfo.lockMint, owner: $.owner, config: { associatedOnly: false } });
    M0.assertArgument(h2 !== null, "cannot found lock vault", "tokenAccounts", $.tokenAccounts);
    const b = e([P("isSet"), P("rewardPerSecond"), P("rewardOpenTime"), P("rewardEndTime"), P("rewardType")]), N = e([o("instruction"), P("nonce"), z0(b, 5, "rewardTimeInfo")]), x = Buffer.alloc(N.span);
    N.encode({ instruction: 0, nonce: new NJ.default(q), rewardTimeInfo: w2 }, x);
    const k = [d2(m2, false), d2(t0, false), d2($SYSVAR_RENT_PUBKEY, false), y2(W.publicKey, false), d2(C, false), y2(K, false), d2(H.lpMint, false), y2(H.lockInfo.lockVault, false), d2(H.lockInfo.lockMint, false), y2(h2 ?? $PublicKey.default, false), d2($.owner, true)];
    for (let A of O)
      k.push(...[{ pubkey: A.rewardMint, isSigner: false, isWritable: false }, { pubkey: A.rewardVault, isSigner: false, isWritable: true }, { pubkey: A.userRewardToken, isSigner: false, isWritable: true }]);
    const g = new $TransactionInstruction({ programId: H.programId, keys: k, data: x });
    return { address: { farmId: W.publicKey }, innerTransaction: { instructions: [...Y, g, ...z], signers: U, lookupTableAddress: [], instructionTypes: [...j, $0.farmV6Create, ...V] } };
  }
  static makeCreatorWithdrawFarmRewardInstruction(J) {
    const { poolKeys: $ } = J, { version: H } = $;
    if (H === 6)
      return this.makeCreatorWithdrawFarmRewardInstructionV6(J);
    return M0.throwArgumentError("invalid version", "version", H);
  }
  static makeCreatorWithdrawFarmRewardInstructionV6({ poolKeys: J, userKeys: $, withdrawMint: H }) {
    const Q = J.rewardInfos.find((V) => V.rewardMint.equals(H.equals($PublicKey.default) ? r.WSOL.mint : H));
    M0.assertArgument(Q !== undefined, "withdraw mint error", "poolKeys.rewardInfos", J.rewardInfos);
    const W = Q?.rewardVault ?? $PublicKey.default, Z = e([o("instruction")]), Y = Buffer.alloc(Z.span);
    Z.encode({ instruction: 5 }, Y);
    const z = [d2(m2, false), y2(J.id, false), d2(J.authority, false), d2(J.lpVault, false), y2(W, false), y2($.userRewardToken, false), d2($.owner, true)], j = new $TransactionInstruction({ programId: J.programId, keys: z, data: Y });
    return { address: {}, innerTransaction: { instructions: [j], signers: [], lookupTableAddress: [], instructionTypes: [$0.farmV6CreatorWithdraw] } };
  }
  static async fetchMultipleInfoAndUpdate({ connection: J, pools: $, owner: H, config: Q, chainTime: W }) {
    let Z = false, Y = false;
    const z = [], j = {};
    for (let q of $) {
      if (j[q.id.toString()] = q, q.version === 6)
        Y = true;
      else
        Z = true;
      if (z.push({ pubkey: q.id, version: q.version, key: "state", poolId: q.id }), z.push({ pubkey: q.lpVault, version: q.version, key: "lpVault", poolId: q.id }), H)
        z.push({ pubkey: this.getAssociatedLedgerAccount({ programId: q.programId, poolId: q.id, owner: H, version: q.version }), version: q.version, key: "ledger", poolId: q.id });
    }
    const V = {}, U = await FH(J, z, Q);
    for (let { pubkey: q, version: K, key: w2, poolId: O, accountInfo: h2 } of U) {
      const b = O.toBase58();
      if (w2 === "state") {
        const N = this.getStateLayout(K);
        if (!h2 || !h2.data || h2.data.length !== N.span)
          return M0.throwArgumentError("invalid farm state account info", "pools.id", q);
        V[b] = { ...V[b], ...{ apiPoolInfo: j[b] }, ...{ state: N.decode(h2.data) } };
      } else if (w2 === "lpVault") {
        if (!h2 || !h2.data || h2.data.length !== $$.span)
          return M0.throwArgumentError("invalid farm lp vault account info", "pools.lpVault", q);
        V[b] = { ...V[b], ...{ lpVault: $$.decode(h2.data) } };
      } else if (w2 === "ledger") {
        const N = this.getLedgerLayout(K);
        if (h2 && h2.data)
          M0.assertArgument(h2.data.length === N.span, "invalid farm ledger account info", "ledger", q), V[b] = { ...V[b], ...{ ledger: N.decode(h2.data) } };
      }
    }
    const C = Y || Z ? await J.getSlot() : 0;
    for (let q of Object.keys(V)) {
      if (V[q] === undefined)
        continue;
      V[q].state = aJ.updatePoolInfo(V[q].state, V[q].lpVault, C, W);
    }
    for (let [q, { state: K, ledger: w2 }] of Object.entries(V))
      if (w2) {
        let O;
        if (K.version === 6)
          O = K.rewardMultiplier;
        else
          O = K.rewardInfos.length === 1 ? XH.pow(new NJ.default(9)) : XH.pow(new NJ.default(15));
        const h2 = K.rewardInfos.map((b, N) => {
          const x = w2.rewardDebts[N];
          return w2.deposited.mul(K.version === 6 ? b.accRewardPerShare : b.perShareReward).div(O).sub(x);
        });
        V[q].wrapped = { ...V[q].wrapped, pendingRewards: h2 };
      }
    return V;
  }
  static updatePoolInfo(J, $, H, Q) {
    if (J.version === 3 || J.version === 5) {
      if (J.lastSlot.gte(new NJ.default(H)))
        return J;
      const W = new NJ.default(H).sub(J.lastSlot);
      J.lastSlot = new NJ.default(H);
      for (let Z of J.rewardInfos) {
        if ($.amount.eq(new NJ.default(0)))
          continue;
        const Y = Z.perSlotReward.mul(W);
        Z.perShareReward = Z.perShareReward.add(Y.mul(new NJ.default(10).pow(new NJ.default(J.version === 3 ? 9 : 15))).div($.amount)), Z.totalReward = Z.totalReward.add(Y);
      }
    } else if (J.version === 6)
      for (let W of J.rewardInfos) {
        if (W.rewardState.eq(new NJ.default(0)))
          continue;
        const Z = NJ.default.min(new NJ.default(Q), W.rewardEndTime);
        if (W.rewardOpenTime.gte(Z))
          continue;
        let z = Z.sub(W.rewardLastUpdateTime).mul(W.rewardPerSecond);
        const j = W.totalReward.sub(W.totalRewardEmissioned);
        if (j.lt(z))
          z = j, W.rewardLastUpdateTime = W.rewardLastUpdateTime.add(j.div(W.rewardPerSecond));
        else
          W.rewardLastUpdateTime = Z;
        if ($.amount.eq(new NJ.default(0)))
          continue;
        W.accRewardPerShare = W.accRewardPerShare.add(z.mul(J.rewardMultiplier).div($.amount)), W.totalRewardEmissioned = W.totalRewardEmissioned.add(z);
      }
    return J;
  }
  static makeCreatorWithdrawFarmRewardInstructionSimple(J) {
    const { poolKeys: $ } = J, { version: H } = $;
    if (H === 6)
      return this.makeCreatorWithdrawFarmRewardInstructionV6Simple(J);
    return M0.throwArgumentError("invalid version", "version", H);
  }
  static async makeCreatorWithdrawFarmRewardInstructionV6Simple({ connection: J, poolKeys: $, userKeys: H, withdrawMint: Q, makeTxVersion: W, lookupTableCache: Z, computeBudgetConfig: Y }) {
    const z = [], j = [], V = [], U = [], C = [];
    let q;
    if (Q.equals($PublicKey.default))
      q = await _0.insertCreateWrappedNativeAccount({ connection: J, owner: H.owner, payer: H.payer ?? H.owner, instructions: z, signers: C, amount: 0, instructionsType: V }), j.push(_0.makeCloseAccountInstruction({ programId: m2, tokenAccount: q, owner: H.owner, payer: H.payer ?? H.owner, instructionsType: U }));
    else {
      const w2 = this._selectTokenAccount({ programId: m2, tokenAccounts: H.tokenAccounts, mint: Q, owner: H.owner });
      if (w2 === null)
        q = n0(H.owner, Q, m2).publicKey, z.push(_0.makeCreateAssociatedTokenAccountInstruction({ programId: m2, mint: Q, associatedAccount: q, owner: H.owner, payer: H.payer ?? H.owner, instructionsType: V }));
      else
        q = w2;
    }
    const K = this.makeCreatorWithdrawFarmRewardInstructionV6({ poolKeys: $, userKeys: { userRewardToken: q, owner: H.owner, payer: H.payer }, withdrawMint: Q });
    return { address: {}, innerTransactions: await L0({ connection: J, makeTxVersion: W, computeBudgetConfig: Y, payer: H.payer ?? H.owner, innerTransaction: [{ instructionTypes: V, instructions: z, signers: C }, K.innerTransaction, { instructionTypes: U, instructions: j, signers: [] }], lookupTableCache: Z }) };
  }
  static makeCreateFarmInstructionSimple(J) {
    const { version: $ } = J.poolInfo;
    if ($ === 6)
      return this.makeCreateFarmInstructionV6Simple(J);
    return M0.throwArgumentError("invalid version", "version", $);
  }
  static async makeCreateFarmInstructionV6Simple({ connection: J, userKeys: $, poolInfo: H, makeTxVersion: Q, lookupTableCache: W, computeBudgetConfig: Z }) {
    const Y = $.payer ?? $.owner, z = g$({ fromPublicKey: Y, programId: H.programId }), j = await J.getMinimumBalanceForRentExemption(kH.span), V = [], U = [], C = [], q = [], K = [];
    V.push($SystemProgram.createAccountWithSeed({ fromPubkey: Y, basePubkey: Y, seed: z.seed, newAccountPubkey: z.publicKey, lamports: j, space: kH.span, programId: H.programId }));
    const { publicKey: w2, nonce: O } = aJ.getAssociatedAuthority({ programId: H.programId, poolId: z.publicKey }), h2 = aJ.getAssociatedLedgerPoolAccount({ programId: H.programId, poolId: z.publicKey, mint: H.lpMint, type: "lpVault" }), b = [], N = [];
    for (let u of H.rewardInfos) {
      M0.assertArgument(u.rewardOpenTime < u.rewardEndTime, "start time error", "rewardInfo.rewardOpenTime", u.rewardOpenTime), M0.assertArgument(DH[u.rewardType] !== undefined, "reward type error", "rewardInfo.rewardType", u.rewardType), M0.assertArgument(H0(u.rewardPerSecond).gt(J0), "rewardPerSecond error", "rewardInfo.rewardPerSecond", u.rewardPerSecond), b.push({ isSet: new NJ.default(1), rewardPerSecond: H0(u.rewardPerSecond), rewardOpenTime: H0(u.rewardOpenTime), rewardEndTime: H0(u.rewardEndTime), rewardType: H0(DH[u.rewardType]) });
      let a;
      if (u.rewardMint.equals($PublicKey.default))
        a = await _0.insertCreateWrappedNativeAccount({ connection: J, owner: $.owner, payer: $.payer ?? $.owner, instructions: V, signers: K, amount: H0(u.rewardEndTime).sub(H0(u.rewardOpenTime)).mul(H0(u.rewardPerSecond)), instructionsType: C }), U.push(_0.makeCloseAccountInstruction({ programId: m2, tokenAccount: a, owner: $.owner, payer: $.payer ?? $.owner, instructionsType: q }));
      else
        a = this._selectTokenAccount({ programId: m2, tokenAccounts: $.tokenAccounts, mint: u.rewardMint, owner: $.owner, config: { associatedOnly: false } });
      if (M0.assertArgument(a !== null, "cannot found target token accounts", "tokenAccounts", $.tokenAccounts), a === null)
        throw Error("cannot found target token accounts");
      const n = u.rewardMint.equals($PublicKey.default) ? r.WSOL.mint : u.rewardMint;
      N.push({ rewardMint: n, rewardVault: aJ.getAssociatedLedgerPoolAccount({ programId: H.programId, poolId: z.publicKey, mint: n, type: "rewardVault" }), userRewardToken: a });
    }
    const x = this._selectTokenAccount({ programId: m2, tokenAccounts: $.tokenAccounts, mint: H.lockInfo.lockMint, owner: $.owner, config: { associatedOnly: false } });
    M0.assertArgument(x !== null, "cannot found lock vault", "tokenAccounts", $.tokenAccounts);
    const k = e([P("isSet"), P("rewardPerSecond"), P("rewardOpenTime"), P("rewardEndTime"), P("rewardType")]), g = e([o("instruction"), P("nonce"), z0(k, 5, "rewardTimeInfo")]), A = Buffer.alloc(g.span);
    g.encode({ instruction: 0, nonce: new NJ.default(O), rewardTimeInfo: b }, A);
    const I = [d2(m2, false), d2(t0, false), d2($SYSVAR_RENT_PUBKEY, false), y2(z.publicKey, false), d2(w2, false), y2(h2, false), d2(H.lpMint, false), y2(H.lockInfo.lockVault, false), d2(H.lockInfo.lockMint, false), y2(x ?? $PublicKey.default, false), d2($.owner, true)];
    for (let u of N)
      I.push(...[{ pubkey: u.rewardMint, isSigner: false, isWritable: false }, { pubkey: u.rewardVault, isSigner: false, isWritable: true }, { pubkey: u.userRewardToken, isSigner: false, isWritable: true }]);
    const T = new $TransactionInstruction({ programId: H.programId, keys: I, data: A });
    return { address: { farmId: z.publicKey }, innerTransactions: await L0({ connection: J, makeTxVersion: Q, computeBudgetConfig: Z, payer: $.payer ?? $.owner, innerTransaction: [{ instructionTypes: C, instructions: V, signers: K }, { instructionTypes: [$0.farmV6Create], instructions: [T], signers: [] }, { instructionTypes: q, instructions: U, signers: [] }], lookupTableCache: W }) };
  }
  static makeRestartFarmInstructionSimple(J) {
    const { poolKeys: $ } = J, { version: H } = $;
    if (H === 6)
      return this.makeRestartFarmInstructionV6Simple(J);
    return M0.throwArgumentError("invalid version", "version", H);
  }
  static async makeRestartFarmInstructionV6Simple({ connection: J, poolKeys: $, userKeys: H, newRewardInfo: Q, makeTxVersion: W, lookupTableCache: Z, computeBudgetConfig: Y }) {
    M0.assertArgument(Q.rewardOpenTime < Q.rewardEndTime, "start time error", "newRewardInfo", Q);
    const z = Q.rewardMint.equals($PublicKey.default) ? r.WSOL.mint : Q.rewardMint, j = $.rewardInfos.find((k) => k.rewardMint.equals(z));
    M0.assertArgument(j, "configuration does not exist", "rewardInfo", j);
    const V = j?.rewardVault ?? $PublicKey.default, U = [], C = [], q = [], K = [], w2 = [];
    let O;
    if (Q.rewardMint.equals($PublicKey.default))
      O = await _0.insertCreateWrappedNativeAccount({ connection: J, owner: H.owner, payer: H.payer ?? H.owner, instructions: U, signers: w2, amount: H0(Q.rewardEndTime).sub(H0(Q.rewardOpenTime)).mul(H0(Q.rewardPerSecond)), instructionsType: q }), C.push(_0.makeCloseAccountInstruction({ programId: m2, tokenAccount: O, owner: H.owner, payer: H.payer ?? H.owner, instructionsType: K }));
    else
      O = this._selectTokenAccount({ programId: m2, tokenAccounts: H.tokenAccounts, mint: Q.rewardMint, owner: H.owner, config: { associatedOnly: false } });
    if (M0.assertArgument(O !== null, "cannot found target token accounts", "tokenAccounts", H.tokenAccounts), O === null)
      throw Error("cannot found target token accounts");
    const h2 = e([o("instruction"), P("rewardReopenTime"), P("rewardEndTime"), P("rewardPerSecond")]), b = Buffer.alloc(h2.span);
    h2.encode({ instruction: 3, rewardReopenTime: H0(Q.rewardOpenTime), rewardEndTime: H0(Q.rewardEndTime), rewardPerSecond: H0(Q.rewardPerSecond) }, b);
    const N = [d2(m2, false), y2($.id, false), d2($.lpVault, false), y2(V, false), y2(O, false), d2(H.owner, true)], x = new $TransactionInstruction({ programId: $.programId, keys: N, data: b });
    return { address: {}, innerTransactions: await L0({ connection: J, makeTxVersion: W, computeBudgetConfig: Y, payer: H.payer ?? H.owner, innerTransaction: [{ instructionTypes: q, instructions: U, signers: w2 }, { instructionTypes: [$0.farmV6Restart], instructions: [x], signers: [] }, { instructionTypes: K, instructions: C, signers: [] }], lookupTableCache: Z }) };
  }
  static makeFarmCreatorAddRewardTokenInstructionSimple(J) {
    const { poolKeys: $ } = J, { version: H } = $;
    if (H === 6)
      return this.makeFarmCreatorAddRewardTokenInstructionV6Simple(J);
    return M0.throwArgumentError("invalid version", "version", H);
  }
  static async makeFarmCreatorAddRewardTokenInstructionV6Simple({ connection: J, poolKeys: $, userKeys: H, newRewardInfo: Q, makeTxVersion: W, lookupTableCache: Z, computeBudgetConfig: Y }) {
    const z = aJ.getAssociatedLedgerPoolAccount({ programId: $.programId, poolId: $.id, mint: Q.rewardMint.equals($PublicKey.default) ? r.WSOL.mint : Q.rewardMint, type: "rewardVault" }), j = [], V = [], U = [], C = [], q = [];
    let K;
    if (Q.rewardMint.equals($PublicKey.default))
      K = await _0.insertCreateWrappedNativeAccount({ connection: J, owner: H.owner, payer: H.payer ?? H.owner, instructions: j, signers: q, amount: H0(Q.rewardEndTime).sub(H0(Q.rewardOpenTime)).mul(H0(Q.rewardPerSecond)), instructionsType: U }), V.push(_0.makeCloseAccountInstruction({ programId: m2, tokenAccount: K, owner: H.owner, payer: H.payer ?? H.owner, instructionsType: C }));
    else
      K = this._selectTokenAccount({ programId: m2, tokenAccounts: H.tokenAccounts, mint: Q.rewardMint, owner: H.owner, config: { associatedOnly: false } });
    if (M0.assertArgument(K !== null, "cannot found target token accounts", "tokenAccounts", H.tokenAccounts), K === null)
      throw Error("cannot found target token accounts");
    const w2 = Q.rewardMint.equals($PublicKey.default) ? r.WSOL.mint : Q.rewardMint, O = e([o("instruction"), P("isSet"), P("rewardPerSecond"), P("rewardOpenTime"), P("rewardEndTime"), P("rewardType")]), h2 = Buffer.alloc(O.span);
    O.encode({ instruction: 4, isSet: new NJ.default(1), rewardPerSecond: H0(Q.rewardPerSecond), rewardOpenTime: H0(Q.rewardOpenTime), rewardEndTime: H0(Q.rewardEndTime), rewardType: H0(DH[Q.rewardType]) }, h2);
    const b = [d2(m2, false), d2(t0, false), d2($SYSVAR_RENT_PUBKEY, false), y2($.id, false), d2($.authority, false), d2(w2, false), y2(z, false), y2(K, false), d2(H.owner, true)], N = new $TransactionInstruction({ programId: $.programId, keys: b, data: h2 });
    return { address: {}, innerTransactions: await L0({ connection: J, makeTxVersion: W, computeBudgetConfig: Y, payer: H.payer ?? H.owner, innerTransaction: [{ instructionTypes: U, instructions: j, signers: q }, { instructionTypes: [$0.farmV6CreatorAddReward], instructions: [N], signers: [] }, { instructionTypes: C, instructions: V, signers: [] }], lookupTableCache: Z }) };
  }
  static async makeDepositInstructionSimple({ connection: J, poolKeys: $, fetchPoolInfo: H, ownerInfo: Q, amount: W, associatedOnly: Z = true, checkCreateATAOwner: Y = false, makeTxVersion: z, lookupTableCache: j, computeBudgetConfig: V }) {
    const U = {};
    for (let T of Q.tokenAccounts)
      if (Z) {
        if (n0(Q.wallet, T.accountInfo.mint, T.programId).publicKey.equals(T.pubkey))
          U[T.accountInfo.mint.toString()] = T.pubkey;
      } else
        U[T.accountInfo.mint.toString()] = T.pubkey;
    const C = [], q = [], K = [], w2 = [], O = [], { lpVault: h2, apiPoolInfo: b, ledger: N } = H, x = h2.mint, k = U[x.toString()];
    M0.assertArgument(k, "you don't have any lp", "lp zero", U);
    const g = [];
    for (let T of b.rewardInfos) {
      const u = Q.useSOLBalance && T.rewardMint.equals(r.WSOL.mint), a = U[T.rewardMint.toString()] ?? await this._selectOrCreateTokenAccount({ programId: m2, mint: T.rewardMint, tokenAccounts: u ? [] : Q.tokenAccounts, owner: Q.wallet, createInfo: { connection: J, payer: Q.feePayer, amount: 0, frontInstructions: C, frontInstructionsType: K, endInstructions: u ? q : [], endInstructionsType: u ? w2 : [], signers: O }, associatedOnly: u ? false : Z, checkCreateATAOwner: Y });
      U[T.rewardMint.toString()] = a, g.push(a);
    }
    const A = await aJ.getAssociatedLedgerAccount({ programId: new $PublicKey(b.programId), poolId: new $PublicKey(b.id), owner: Q.wallet, version: b.version });
    if (b.version < 6 && !N) {
      const T = aJ.makeCreateAssociatedLedgerAccountInstruction({ poolKeys: $, userKeys: { owner: Q.wallet, ledger: A } });
      C.push(...T.innerTransaction.instructions), K.push(...T.innerTransaction.instructionTypes);
    }
    const I = aJ.makeDepositInstruction({ poolKeys: $, userKeys: { ledger: A, lpTokenAccount: k, owner: Q.wallet, rewardTokenAccounts: g }, amount: W });
    return { address: I.address, innerTransactions: await L0({ connection: J, makeTxVersion: z, computeBudgetConfig: V, payer: Q.feePayer, innerTransaction: [{ instructionTypes: K, instructions: C, signers: O }, I.innerTransaction, { instructionTypes: w2, instructions: q, signers: [] }], lookupTableCache: j }) };
  }
  static async makeWithdrawInstructionSimple({ connection: J, fetchPoolInfo: $, ownerInfo: H, amount: Q, associatedOnly: W = true, checkCreateATAOwner: Z = false, makeTxVersion: Y, lookupTableCache: z, computeBudgetConfig: j }) {
    const V = {};
    for (let u of H.tokenAccounts)
      if (W) {
        if (n0(H.wallet, u.accountInfo.mint, u.programId).publicKey.equals(u.pubkey))
          V[u.accountInfo.mint.toString()] = u.pubkey;
      } else
        V[u.accountInfo.mint.toString()] = u.pubkey;
    const U = [], C = [], q = [], K = [], w2 = [], O = [], h2 = [], { lpVault: b, wrapped: N, apiPoolInfo: x } = $;
    if (N === undefined)
      throw Error("no lp");
    const k = b.mint, g = H.useSOLBalance && k.equals(r.WSOL.mint), A = V[k.toString()] ?? await this._selectOrCreateTokenAccount({ programId: m2, mint: k, tokenAccounts: g ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.feePayer, amount: 0, frontInstructions: U, frontInstructionsType: q, signers: h2 }, associatedOnly: g ? false : W, checkCreateATAOwner: Z });
    V[k.toString()] = A;
    const I = [];
    for (let u of x.rewardInfos) {
      const a = H.useSOLBalance && u.rewardMint.equals(r.WSOL.mint), n = V[u.rewardMint.toString()] ?? await this._selectOrCreateTokenAccount({ programId: m2, mint: u.rewardMint, tokenAccounts: a ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.feePayer, amount: 0, frontInstructions: U, frontInstructionsType: q, endInstructions: a ? C : [], endInstructionsType: a ? K : [], signers: h2 }, associatedOnly: a ? false : W, checkCreateATAOwner: Z });
      V[u.rewardMint.toString()] = n, I.push(n);
    }
    const T = this.makeWithdrawInstruction({ poolKeys: x, userKeys: { ledger: this.getAssociatedLedgerAccount({ programId: x.programId, poolId: x.id, owner: H.wallet, version: x.version }), lpTokenAccount: A, rewardTokenAccounts: I, owner: H.wallet }, amount: Q });
    return w2.push(...T.innerTransaction.instructions), O.push(...T.innerTransaction.instructionTypes), { address: {}, innerTransactions: await L0({ connection: J, makeTxVersion: Y, computeBudgetConfig: j, payer: H.feePayer, innerTransaction: [{ instructionTypes: q, instructions: U, signers: h2 }, { instructionTypes: O, instructions: w2, signers: [] }, { instructionTypes: K, instructions: C, signers: [] }], lookupTableCache: z }) };
  }
  static async makeHarvestAllRewardInstructionSimple({ connection: J, fetchPoolInfos: $, ownerInfo: H, associatedOnly: Q = true, checkCreateATAOwner: W = false, makeTxVersion: Z, lookupTableCache: Y, computeBudgetConfig: z }) {
    const j = {};
    for (let O of H.tokenAccounts)
      if (Q) {
        if (n0(H.wallet, O.accountInfo.mint, O.programId).publicKey.equals(O.pubkey))
          j[O.accountInfo.mint.toString()] = O.pubkey;
      } else
        j[O.accountInfo.mint.toString()] = O.pubkey;
    const V = [], U = [], C = [], q = [], K = [], w2 = [];
    for (let { lpVault: O, wrapped: h2, apiPoolInfo: b, ledger: N } of Object.values($)) {
      if (h2 === undefined || N === undefined || !(h2.pendingRewards.find((T) => T.gt(J0)) !== undefined || N.deposited.isZero()))
        continue;
      const x = O.mint, k = H.useSOLBalance && x.equals(r.WSOL.mint), g = j[x.toString()] ?? await this._selectOrCreateTokenAccount({ programId: m2, mint: x, tokenAccounts: k ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.feePayer, amount: 0, frontInstructions: V, frontInstructionsType: C, signers: w2 }, associatedOnly: k ? false : Q, checkCreateATAOwner: W });
      j[x.toString()] = g;
      const A = [];
      for (let T of b.rewardInfos) {
        const u = H.useSOLBalance && T.rewardMint.equals(r.WSOL.mint), a = j[T.rewardMint.toString()] ?? await this._selectOrCreateTokenAccount({ programId: m2, mint: T.rewardMint, tokenAccounts: u ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.feePayer, amount: 0, frontInstructions: V, frontInstructionsType: C, endInstructions: u ? U : [], endInstructionsType: u ? q : [], signers: w2 }, associatedOnly: u ? false : Q, checkCreateATAOwner: W });
        j[T.rewardMint.toString()] = a, A.push(a);
      }
      const I = this.makeWithdrawInstruction({ poolKeys: b, userKeys: { ledger: this.getAssociatedLedgerAccount({ programId: b.programId, poolId: b.id, owner: H.wallet, version: b.version }), lpTokenAccount: g, rewardTokenAccounts: A, owner: H.wallet }, amount: 0 });
      K.push(I.innerTransaction);
    }
    return { address: {}, innerTransactions: await L0({ connection: J, makeTxVersion: Z, computeBudgetConfig: z, payer: H.feePayer, innerTransaction: [{ instructionTypes: C, instructions: V, signers: w2 }, ...K, { instructionTypes: q, instructions: U, signers: [] }], lookupTableCache: Y }) };
  }
  static async makeV1InfoToV2PdaAndHarvestSimple({ connection: J, wallet: $, tokenAccounts: H, programIdV3: Q, programIdV5: W, makeTxVersion: Z, lookupTableCache: Y, computeBudgetConfig: z }) {
    const j = {};
    for (let g of H) {
      const A = g.accountInfo.mint, I = n0($, A, g.programId).publicKey;
      if (I.equals(g.pubkey))
        j[A.toString()] = I;
      if (j[A.toString()] === undefined)
        j[A.toString()] = g.pubkey;
    }
    const V = await J.getProgramAccounts(Q, { filters: [{ memcmp: { offset: 40, bytes: $.toString() } }] }), U = await J.getProgramAccounts(W, { filters: [{ memcmp: { offset: 40, bytes: $.toString() } }] }), C = {}, q = {};
    for (let g of V) {
      const I = (g.account.data.length === N6.span ? N6 : HQ).decode(g.account.data), T = I.id.toString(), u = this.getAssociatedLedgerAccount({ programId: Q, poolId: I.id, owner: $, version: 3 });
      if (C[T] === undefined)
        C[T] = { pda: undefined, other: [] };
      if (u.equals(g.pubkey))
        C[T].pda = g.pubkey;
      else
        C[T].other.push(g.pubkey);
    }
    for (let g of U) {
      const I = (g.account.data.length === g6.span ? g6 : k6).decode(g.account.data), T = I.id.toString(), u = this.getAssociatedLedgerAccount({ programId: W, poolId: I.id, owner: $, version: 5 });
      if (q[T] === undefined)
        q[T] = { pda: undefined, other: [] };
      if (u.equals(g.pubkey))
        q[T].pda = g.pubkey;
      else
        q[T].other.push(g.pubkey);
    }
    const K = [...Object.entries(C).filter((g) => g[1].other.length > 0).map((g) => g[0]), ...Object.entries(q).filter((g) => g[1].other.length > 0).map((g) => g[0])], w2 = await J.getMultipleAccountsInfo(K.map((g) => new $PublicKey(g))), O = {};
    for (let g = 0;g < K.length; g++) {
      const A = K[g], I = w2[g];
      if (I === null)
        continue;
      O[A] = I.data;
    }
    const h2 = [], b = [], N = [], x = [], k = [];
    for (let [g, A] of Object.entries(C)) {
      if (A.other.length === 0)
        continue;
      if (O[g] === undefined)
        continue;
      const I = _6.decode(O[g]), [T, u] = await J.getMultipleAccountsInfo([I.lpVault, I.rewardVault]);
      if (T === null || u === null)
        throw Error("get lp and reward info error");
      const a = $$.decode(T.data), n = $$.decode(u.data);
      let Z0 = j[a.mint.toString()];
      if (Z0 === undefined)
        Z0 = await this._selectOrCreateTokenAccount({ programId: T.owner, mint: a.mint, tokenAccounts: [], owner: $, createInfo: { connection: J, payer: $, amount: 0, frontInstructions: h2, frontInstructionsType: b, endInstructions: [], endInstructionsType: [], signers: [] }, associatedOnly: true, checkCreateATAOwner: true }), j[a.mint.toString()] = Z0;
      let _ = j[n.mint.toString()];
      if (_ === undefined)
        _ = await this._selectOrCreateTokenAccount({ programId: u.owner, mint: n.mint, tokenAccounts: [], owner: $, createInfo: { connection: J, payer: $, amount: 0, frontInstructions: h2, frontInstructionsType: b, endInstructions: n.mint.toString() === SJ.mint ? x : [], endInstructionsType: n.mint.toString() === SJ.mint ? k : [], signers: [] }, associatedOnly: true, checkCreateATAOwner: true }), j[n.mint.toString()] = _;
      if (A.pda === undefined) {
        const v = this.makeCreateAssociatedLedgerAccountInstructionV3({ poolKeys: { programId: Q, id: new $PublicKey(g) }, userKeys: { ledger: this.getAssociatedLedgerAccount({ programId: Q, poolId: new $PublicKey(g), owner: $, version: 3 }), owner: $ } });
        N.push(v.innerTransaction);
      }
      const G = this.makeDepositInstructionV3({ amount: 0, userKeys: { ledger: this.getAssociatedLedgerAccount({ programId: Q, poolId: new $PublicKey(g), owner: $, version: 3 }), owner: $, lpTokenAccount: Z0, rewardTokenAccounts: [_], auxiliaryLedgers: A.other }, poolKeys: { programId: Q, id: new $PublicKey(g), authority: this.getAssociatedAuthority({ programId: Q, poolId: new $PublicKey(g) }).publicKey, lpVault: I.lpVault, rewardInfos: [{ rewardVault: I.rewardVault }] } });
      N.push(G.innerTransaction);
    }
    for (let [g, A] of Object.entries(q)) {
      if (A.other.length === 0)
        continue;
      if (O[g] === undefined)
        continue;
      const I = P6.decode(O[g]), [T, u, a] = await J.getMultipleAccountsInfo([I.lpVault, I.rewardVaultA, I.rewardVaultB]);
      if (T === null || u === null || a === null)
        throw Error("get lp and reward A / B info error");
      const n = $$.decode(T.data), Z0 = $$.decode(u.data), _ = $$.decode(a.data);
      let G = j[n.mint.toString()];
      if (G === undefined)
        G = await this._selectOrCreateTokenAccount({ programId: T.owner, mint: n.mint, tokenAccounts: [], owner: $, createInfo: { connection: J, payer: $, amount: 0, frontInstructions: h2, frontInstructionsType: b, endInstructions: [], endInstructionsType: [], signers: [] }, associatedOnly: true, checkCreateATAOwner: true }), j[n.mint.toString()] = G;
      let v = j[Z0.mint.toString()];
      if (v === undefined)
        v = await this._selectOrCreateTokenAccount({ programId: u.owner, mint: Z0.mint, tokenAccounts: [], owner: $, createInfo: { connection: J, payer: $, amount: 0, frontInstructions: h2, frontInstructionsType: b, endInstructions: Z0.mint.toString() === SJ.mint ? x : [], endInstructionsType: Z0.mint.toString() === SJ.mint ? k : [], signers: [] }, associatedOnly: true, checkCreateATAOwner: true }), j[Z0.mint.toString()] = v;
      let X = j[_.mint.toString()];
      if (X === undefined)
        X = await this._selectOrCreateTokenAccount({ programId: a.owner, mint: _.mint, tokenAccounts: [], owner: $, createInfo: { connection: J, payer: $, amount: 0, frontInstructions: h2, frontInstructionsType: b, endInstructions: _.mint.toString() === SJ.mint ? x : [], endInstructionsType: _.mint.toString() === SJ.mint ? k : [], signers: [] }, associatedOnly: true, checkCreateATAOwner: true }), j[_.mint.toString()] = X;
      if (A.pda === undefined) {
        const M = this.makeCreateAssociatedLedgerAccountInstructionV5({ poolKeys: { programId: W, id: new $PublicKey(g) }, userKeys: { ledger: this.getAssociatedLedgerAccount({ programId: W, poolId: new $PublicKey(g), owner: $, version: 5 }), owner: $ } });
        N.push(M.innerTransaction);
      }
      const D = this.makeDepositInstructionV5({ amount: 0, userKeys: { ledger: this.getAssociatedLedgerAccount({ programId: W, poolId: new $PublicKey(g), owner: $, version: 5 }), owner: $, lpTokenAccount: G, rewardTokenAccounts: [v, X], auxiliaryLedgers: A.other }, poolKeys: { programId: W, id: new $PublicKey(g), authority: this.getAssociatedAuthority({ programId: W, poolId: new $PublicKey(g) }).publicKey, lpVault: I.lpVault, rewardInfos: [{ rewardVault: I.rewardVaultA }, { rewardVault: I.rewardVaultB }] } });
      N.push(D.innerTransaction);
    }
    return { address: {}, innerTransactions: await L0({ connection: J, makeTxVersion: Z, computeBudgetConfig: z, payer: $, innerTransaction: [{ instructionTypes: b.slice(0, 10), instructions: h2.slice(0, 10), signers: [] }, ...h2.length > 10 ? [{ instructionTypes: b.slice(10), instructions: h2.slice(10), signers: [] }] : [], ...N, { instructionTypes: k, instructions: x, signers: [] }], lookupTableCache: Y }) };
  }
  static async makeDepositTokenInstruction({ connection: J, programId: $, governanceProgramId: H, voteWeightAddinProgramId: Q, realm: W, communityTokenMint: Z, owner: Y, poolId: z }) {
    const j = x6(Q, W, Z).publicKey, V = this.getAssociatedLedgerAccount({ programId: $, poolId: z, owner: Y, version: 3 }), U = await J.getAccountInfo(V);
    if (U === null)
      throw Error("user is not staker");
    const C = HQ.decode(U.data), q = C.deposited.sub(C.voteLockedBalance);
    if (q.eq(J0))
      throw Error("user do not has new stake amount");
    const K = A6($, z).publicKey, w2 = T6($, z).publicKey, { publicKey: O, nonce: h2 } = f6(Q, j, Y), b = n0(O, K, m2).publicKey, { publicKey: N, nonce: x } = y6(Q, j, Y), k = I6(H, W, Z, Y).publicKey, g = [], A = n0(Y, K, m2).publicKey;
    if (await J.getAccountInfo(A) === null)
      g.push(_0.makeCreateAssociatedTokenAccountInstruction({ programId: m2, mint: K, associatedAccount: A, owner: Y, payer: Y, instructionsType: [] }));
    if (await J.getAccountInfo(O) === null) {
      const n = IZ(H, W, Y, Z, Y, k);
      g.push(n, mZ(Q, j, O, N, Y, Y, h2, x));
    }
    const { index: u, isInit: a } = await nZ(J, j, O, K);
    if (!a)
      g.push(dZ(Q, j, O, b, Y, Y, K, u, 0, undefined, 0, false));
    return g.push(pZ(Q, j, O, b, A, Y, V, z, K, w2, $, u, q), lZ(Q, j, O, N)), { address: {}, innerTransaction: { instructions: g, signers: [], lookupTableAddress: [], instructionTypes: Array(g.length).fill($0.test) } };
  }
  static async makeWithdrawTokenInstruction({ connection: J, programId: $, governanceProgramId: H, voteWeightAddinProgramId: Q, realm: W, communityTokenMint: Z, owner: Y, poolId: z }) {
    const j = x6(Q, W, Z).publicKey, V = this.getAssociatedLedgerAccount({ programId: $, poolId: z, owner: Y, version: 3 }), U = await J.getAccountInfo(V);
    if (U === null)
      throw Error("user is not staker");
    const C = HQ.decode(U.data);
    if (C.voteLockedBalance.eq(J0))
      throw Error("user has vote locked balance = 0");
    const q = A6($, z).publicKey, K = T6($, z).publicKey, { publicKey: w2 } = f6(Q, j, Y), O = n0(w2, q, m2).publicKey, { publicKey: h2 } = y6(Q, j, Y), b = I6(H, W, Z, Y).publicKey, N = [], { index: x, isInit: k } = await nZ(J, j, w2, q);
    if (!k)
      throw Error("deposit entry index check error");
    return N.push(uZ(Q, j, w2, Y, b, h2, O, n0(Y, q, m2).publicKey, V, z, q, K, $, x, C.voteLockedBalance)), { address: {}, innerTransaction: { instructions: N, signers: [], lookupTableAddress: [], instructionTypes: Array(N.length).fill($0.test) } };
  }
}
var AX = [{ id: "AvbVWpBi2e4C9HPmZgShGdPoNydG4Yw8GJvG9HUcLgce", lp: t.RAY_USDT_V4, version: 3 }, { id: "4EwbZo8BZXP5313z5A2H11MRBP15M5n6YxfmkjXESKAW", lp: B.RAY, version: 3 }, { id: "XnRBbNMf6YcWvC1u2vBXXuMcagmRBRLu1y84mpqnKwW", lp: t.xCOPE_USDC_V4, version: 5 }, { id: "8xhjCzfzVcP79jE7jXR2xtNaSL6aJYoDRLVT9FMjpRTC", lp: t.STEP_USDC_V4, version: 5 }, { id: "Ef1gD9JMzWF6PNw2uc4744zouh57GyWAeVTjHHbQ2nsu", lp: t.MEDIA_USDC_V4, version: 5 }, { id: "AxVvbT9fDFEkmdLwKUJRY5HsG2RXAZbe1dRAgJ2bDDwg", lp: t.COPE_USDC_V4, version: 5 }, { id: "D4pYuD4tbir9KBsb7Kr63v9e86JY2UoUZeFK9eHKQFZM", lp: t.MER_USDC_V4, version: 5 }, { id: "BLy8KuRck5bcJkQdMDLSZnL1Ka4heAZSGiwTJfEfY727", lp: t.ROPE_USDC_V4, version: 5 }, { id: "JAP8SFagJBm6vt2LoFGNeSJ1hKDZ2p3yXb3CvBx11How", lp: t.ALEPH_USDC_V4, version: 5 }, { id: "7U8Z6TWQMtsMcHV2htALnF9VQonnD1MrVm17YtmGEGEw", lp: t.TULIP_USDC_V4, version: 5 }, { id: "31QSh1TwgoA9GbvkgfEEwKEm11t8CR4KiQr6WCyJr7EN", lp: t.SNY_USDC_V4, version: 5 }, { id: "EEe8b72w5q6T86nYRNJdFcY25tznPzrd1jGjuxZ7f9mX", lp: t.BOP_RAY_V4, version: 5 }, { id: "5PVVwSqwzkCvuiKEZwWkM35ApBnoWqF8XopsVZjPwA8z", lp: t.SLRS_USDC_V4, version: 5 }, { id: "Bw932pURVJRYjEJwRZGWjfUNpeyz18kjMNdb833eMxoj", lp: t.SAMO_RAY_V4, version: 5 }, { id: "BRM5bdX2mjmFGg2RAent1Whd61o9asQD16BXsC6QvEni", lp: t.LIKE_USDC_V4, version: 5 }, { id: "HUDr9BDaAGqi37xbQHzxCyXvfMCKPTPNF8g9c9bPu1Fu", lp: t.RAY_SOL_V4, version: 3 }, { id: "CHYrUBX2RKX8iBg7gYTkccoGNBzP44LdaazMHCLcdEgS", lp: t.RAY_USDC_V4, version: 3 }, { id: "B6fbnZZ7sbKHR18ffEDD5Nncgp54iKN1GbCgjTRdqhS1", lp: t.RAY_ETH_V4, version: 3 }, { id: "5DFbcYNLLy5SJiBpCCDzNSs7cWCsUbYnCkLXzcPQiKnR", lp: t.RAY_SRM_V4, version: 3 }, { id: "GzEDEkHSFFfxKMu3Toww1nrEjtbQGJKRPNRK1Pfd59Zn", lp: t.MNGO_USDC_V4, version: 5 }, { id: "CM9XTJfXEHceGPXhmXxheR87Ng9CZ4jiBoTVQHhs9DVN", lp: t.COPE_RAY_V4, version: 5 }, { id: "AMcVWK66iexwwCHn8drxywdNr2UgH3vmRzLXQFdErGmL", lp: t.LIKE_RAY_V4, version: 5 }, { id: "DJfvL6srBht8XFMWYuuKHYGainqvwXyA5icVsDne3pwN", lp: t.MEDIA_RAY_V4, version: 5 }, { id: "21xhrT4j8QnaBvj3QjhP5kZu8sXJMCE7hzHKGtWEkdKr", lp: t.MER_RAY_V4, version: 5 }, { id: "J61AnYYSwjtJ4wDqEqqWSBuZbiR2SDDrtF7FFobutM6a", lp: t.SLRS_RAY_V4, version: 5 }, { id: "JEC3P83x2GEijYDwXiksuh5H6YrQt5xW6MC2GDKkMoe", lp: t.SNY_RAY_V4, version: 5 }, { id: "BmbG9hv5PazcW3rYWvatA6HpNPkozEdkWBiU64pZxuwr", lp: t.TULIP_RAY_V4, version: 5 }, { id: "4wvZ9SwWaHKTpshQbCSKQoPosZp9KGwUzuQdESi39qPn", lp: t.ALEPH_RAY_V4, version: 5 }, { id: "BnYoq5y2MoH4TsBHeEZrEPowhwebHxQq7nJW1vTjPTWu", lp: t.RAY_SRM_V4, version: 5 }, { id: "93wRz2LeQ3TJoair827VTng62MjCzYDgJjG9Q5GmQ3Pd", lp: t.ATLAS_USDC_V4, version: 5 }, { id: "7qcihXTsRW5wS5BgK7iuD84W43ECByoJP45R3hu2r6mF", lp: t.POLIS_USDC_V4, version: 5 }, { id: "BHHhNLdJn69K1XPJcpcw4MBY3TPetpLxhj8s4K4ydsDV", lp: t.ATLAS_RAY_V4, version: 5 }, { id: "HHm8Pgnzc56fTUYkicPv4DqGYp5fcPZFV1V1uhixSrMk", lp: t.POLIS_RAY_V4, version: 5 }, { id: "8GBa1cK1NxevoxiRNK6YW9tWuo2xftcA3as9Cu4nhFL7", lp: t.GRAPE_USDC_V4, version: 5 }, { id: "HzxveT6pUMwYByqnScvTbpUv4avzkUDrDpS9D7DToEry", lp: t.LARIX_USDC_V4, version: 5 }, { id: "Fbwy4XWMjXuP1nXg4xph4RJ9E9twVXeknXokF38PVgG1", lp: t.LARIX_RAY_V4, version: 5 }, { id: "5gzQgxaKAU13SZeffmjjE2y9HwMJ42FxQkqJhJ5nqHeh", lp: t.stSOL_USDC_V4, version: 5 }, { id: "914jyHBQFiroKFVCpKkzjGSaZyr4gMwgxE7snbNfGjnL", lp: t.BTC_mSOL_V4, version: 5 }, { id: "54vUWjEmg9wfCsZF7wwq2HJu5BU3cfDFAQQQgXPECcwE", lp: t.ETH_mSOL_V4, version: 5 }, { id: "HxhxYASqdLcR6yehT9hB9HUpgcF1R2t9HtkHdngGZ2Dh", lp: t.mSOL_USDT_V4, version: 5 }, { id: "97N6tPMVCrAunC9embwTcffye9xC95fA5y3LauhNZ444", lp: t.MNDE_mSOL_V4, version: 5 }, { id: "DjtZxyFBgifzpaZEzfsWXogNX5zUCnTRXJqarGe9CiSv", lp: t.mSOL_USDC_V4, version: 5 }, { id: "7wNhbTS6XQczXs52wcVmfiodRMPfycB3YaG52dWWY6SD", lp: t.mSOL_RAY_V4, version: 5 }, { id: "CzKUrVbP7hH8EjcHNc55ZFW33rJyLQ2r52bxCzaGTpz", lp: t.LIQ_USDC_V4, version: 5 }, { id: "5XdeFdcJoCAPMfgYndMPcsijFBKFp2cPSCjrCZzmpTE5", lp: t.LIQ_RAY_V4, version: 5 }, { id: "Gf3qFzKnGvMCVMQZERW2Qso5uEYxd9B9kWZZHsrMmmHj", lp: t.SYP_RAY_V4, version: 5 }, { id: "2pQQnoNpm5LoG6sZs5toNBXi4m1Pj3ExXdggPQYyiP2x", lp: t.SYP_SOL_V4, version: 5 }, { id: "Byt2kL5qi45pMpdAsNNciKZ8HLp7oU5jizCbyARLtQJy", lp: t.SYP_USDC_V4, version: 5 }, { id: "8W2TqGCiFiqR1JD4sbW8uTRjV2HvFjLhkZ2tAQTYE4Gc", lp: t.WOOF_RAY_V4, version: 5 }, { id: "FgApVk6mASrkuWNxmsFvsaAYkFKqdiwMTvYZK36A2DaC", lp: t.KIN_RAY_V4, version: 5 }, { id: "AwUDfg4NYbLQRAcFipoJwyZTpqNvw5v6C7EypryL12Y6", lp: t.STARS_USDC_V4, version: 5 }, { id: "Gi3Z6TXeH1ZhCCbwg6oJL8SE4LcmxmGRNhhfA6NZhwTK", lp: t.weWETH_SOL_V4, version: 5 }, { id: "8JJSdD1ca5SDtGCEm3yBbQKek2FvJ1EbNt9q2ET3E9Jt", lp: t.weWETH_USDC_V4, version: 5 }, { id: "6X495xkPWkw9SQFYf7yL1K8QooZyaeEQ6u7yMWNNZxNV", lp: t.weUNI_USDC_V4, version: 5 }, { id: "AuyqPBiY6sNUpH6jx415NGcdvNdYbkbYsyVabUqEVdkj", lp: t.weSUSHI_USDC_V4, version: 5 }, { id: "7fe8QcJ6W2kHKL1h1HMYYJoGXz2LUcwCjkxX6MX35orK", lp: t.weAXS_USDC_V4, version: 5 }, { id: "C8BjS9DGDvC2zS3n6fTvm1rjPbA33uZ7CAvEUZ3tg7aM", lp: t.weDYDX_USDC_V4, version: 5 }, { id: "CZZnmfvSgNVUiDBG4wN2NNcaYbsKDN4kLsc3SN8DMw6i", lp: t.weSHIB_USDC_V4, version: 5 }, { id: "FAKzZoGVCEBDRuHN4gDswAx7PsocCorDqH6dQaxnyorT", lp: t.weSAND_USDC_V4, version: 5 }, { id: "EBS8tc4proQE2Fj6HxU4piiZP8oiDrvyJUijDCX7P7QN", lp: t.weMANA_USDC_V4, version: 5 }, { id: "6AxxjJhAz6APspTQM4vVCHgfzEyZgBTCogJLdai7bXYE", lp: t.wbWBNB_USDC_V4, version: 5 }, { id: "3HGPRHH3XFFu972MR1EdS65qc1nN9sM7miZtFTi6QcEd", lp: t.wePEOPLE_USDC_V4, version: 5 }, { id: "27bysJaX5eu5Urb5kftR66otiVc6DKK7TnifKwnpNzYu", lp: t.SRM_USDC_V4, version: 5 }, { id: "FDnxy4NkJVG3GNMMrtUZmUmoYeYE34YRDwCYTi1yBTM", lp: t.CAVE_USDC_V4, version: 5 }, { id: "DDRNVVJBEXEemcprVVUcrTbYnR88JyN6jjT2ypgAQHC8", lp: t.GENE_USDC_V4, version: 5 }, { id: "GVfLbXA3dpEHPvc4do9HvMZ8TACxm3x54BVrHPMEixcr", lp: t.GENE_RAY_V4, version: 5 }, { id: "7NZ18KhsSdJBQkJEJwhEHfdaPRNdbMd17CMoxsKxavEo", lp: t.CWAR_USDC_V4, version: 5 }, { id: "5Mdq5o3KKPyeVVBsbnivVk9qCATjfEQ22oysXVsd2DvJ", lp: t.SONAR_USDC_V4, version: 5 }, { id: "7W8BKbMgcVpGYvTgEK758pJgDRZJ9WafKfgkV1XCkP33", lp: t.APT_USDC_V4, version: 5 }, { id: "CgokwBwwdYsgo8hbUMtJ3GoNM3bVjvMcmaPrVvCw4sBi", lp: t.SHILL_USDC_V4, version: 5 }, { id: "AWbmotuJS7NLBmra9ctbfVR1BnoHmiG1HGW6hm49TuRZ", lp: t.DFL_USDC_V4, version: 5 }, { id: "665VvECKsLpXN4fLy8GYbyQpGJRNkxRx56X93U9FVSbv", lp: t.BOKU_USDC_V4, version: 5 }, { id: "7yk1XUWmZpWMCoFpUT985z61UNTypyBGgZF3JpKgcwmL", lp: t.MIMO_SOL_V4, version: 5 }, { id: "E5L4Bx3Lsif7bDb9XMWi5guHUt4kkYpbqQ4CbmnRjHs1", lp: t.XTAG_USDC_V4, version: 5 }, { id: "HtvQ5AEvu8sDM7C1oB4r5fJ5E2Q1wsJ4TADwNMqR9ccF", lp: t.TTT_USDC_V4, version: 5 }, { id: "GUzaohfNuFbBqQTnPgPSNciv3aUvriXYjQduRE3ZkqFw", lp: t.SOL_USDC_V4, version: 5 }, { id: "5r878BSWPtoXgnqaeFJi7BCycKZ5CodBB2vS9SeiV8q", lp: t.SOL_USDT_V4, version: 5 }, { id: "3J3SYLeFZWKnUCsrPzikw9bcD9vRs7YNGfmg7ZSg3tsK", lp: t.RUN_USDC_V4, version: 5 }, { id: "BYmeWrwA4ixvJhNrxWzQsA3Fsz6EtUDJTo39WYZ6o1FS", lp: t.CRWNY_RAY_V4, version: 5 }, { id: "6VNF4rF7ESUohzNeRf3aTg61dyFjbab749RGUHCTDFQL", lp: t.CRWNY_USDC_V4, version: 5 }, { id: "7RQDGZ1cvHcREu211R35WSKHFjTxM5dmJHeFAWag29BA", lp: t.REAL_USDC_V4, version: 5 }, { id: "ELovJ3jDKMiWhCUCdZzPfTeVmQwhj4cvYuGwS8FfhEtJ", lp: t.BLOCK_USDC_V4, version: 5 }, { id: "36Rf8dzq5gy4Ew2bLQEgKoCKVTku4EJPLqFYG6mzFrkr", lp: t.FRKT_SOL_V4, version: 5 }, { id: "HXpQJeAcBCKfGY6YhZgBocZGgV4xApPVK7r8CPXfvCin", lp: t.FRKT_USDC_V4, version: 5 }, { id: "Eqn7unnxmneDuTuXQ7EAN1wBkHMFD4LgCCAkCdPA9KbV", lp: t.MBS_USDC_V4, version: 5 }, { id: "DtU5pZB99rVtxe5qe5hQa2rRpw7poFiqaHvMAbPgT2TM", lp: t.PRISM_USDC_V4, version: 5 }, { id: "Gue2c9J2aRtY3aJ1HEwabQznwg2MUt9d9kUyr6otujR", lp: t.CHICKS_USDC_V4, version: 5 }, { id: "Ej7iBkW79EdF26RxaRQfGo58PqRdzHzRmE4C2e3z3dPY", lp: t.MEAN_RAY_V4, version: 5 }, { id: "Bd1hAsMAghtCjK38Ut4m938Ep7zyEp2TydQ7G35nPvUj", lp: t.TINY_USDC_V4, version: 5 }, { id: "2G7qTQzw3KXm7WEMJf2izqFQWh8CLZ1wFbQVP5qo3ME9", lp: t.SCY_USDC_V4, version: 5 }];
var J9 = e([P("status"), P("nonce"), P("maxOrder"), P("depth"), P("baseDecimal"), P("quoteDecimal"), P("state"), P("resetFlag"), P("minSize"), P("volMaxCutRatio"), P("amountWaveRatio"), P("baseLotSize"), P("quoteLotSize"), P("minPriceMultiplier"), P("maxPriceMultiplier"), P("systemDecimalValue"), P("minSeparateNumerator"), P("minSeparateDenominator"), P("tradeFeeNumerator"), P("tradeFeeDenominator"), P("pnlNumerator"), P("pnlDenominator"), P("swapFeeNumerator"), P("swapFeeDenominator"), P("baseNeedTakePnl"), P("quoteNeedTakePnl"), P("quoteTotalPnl"), P("baseTotalPnl"), P("poolOpenTime"), P("punishPcAmount"), P("punishCoinAmount"), P("orderbookToInitTime"), G0("swapBaseInAmount"), G0("swapQuoteOutAmount"), P("swapBase2QuoteFee"), G0("swapQuoteInAmount"), G0("swapBaseOutAmount"), P("swapQuote2BaseFee"), c("baseVault"), c("quoteVault"), c("baseMint"), c("quoteMint"), c("lpMint"), c("openOrders"), c("marketId"), c("marketProgramId"), c("targetOrders"), c("withdrawQueue"), c("lpVault"), c("owner"), P("lpReserve"), z0(P(), 3, "padding")]);
var $9 = e([P("accountType"), P("status"), P("nonce"), P("maxOrder"), P("depth"), P("baseDecimal"), P("quoteDecimal"), P("state"), P("resetFlag"), P("minSize"), P("volMaxCutRatio"), P("amountWaveRatio"), P("baseLotSize"), P("quoteLotSize"), P("minPriceMultiplier"), P("maxPriceMultiplier"), P("systemDecimalsValue"), P("abortTradeFactor"), P("priceTickMultiplier"), P("priceTick"), P("minSeparateNumerator"), P("minSeparateDenominator"), P("tradeFeeNumerator"), P("tradeFeeDenominator"), P("pnlNumerator"), P("pnlDenominator"), P("swapFeeNumerator"), P("swapFeeDenominator"), P("baseNeedTakePnl"), P("quoteNeedTakePnl"), P("quoteTotalPnl"), P("baseTotalPnl"), P("poolOpenTime"), P("punishPcAmount"), P("punishCoinAmount"), P("orderbookToInitTime"), G0("swapBaseInAmount"), G0("swapQuoteOutAmount"), G0("swapQuoteInAmount"), G0("swapBaseOutAmount"), P("swapQuote2BaseFee"), P("swapBase2QuoteFee"), c("baseVault"), c("quoteVault"), c("baseMint"), c("quoteMint"), c("lpMint"), c("modelDataAccount"), c("openOrders"), c("marketId"), c("marketProgramId"), c("targetOrders"), c("owner"), z0(P(), 64, "padding")]);
var m6 = { 4: J9, 5: $9 };
var TJ = E0(EJ(), 1);
var f0 = E0(EJ(), 1);
var xJ = function(J) {
  var $, H, Q, W = J.length - 1, Z = "", Y = J[0];
  if (W > 0) {
    Z += Y;
    for ($ = 1;$ < W; $++) {
      if (Q = J[$] + "", H = X0 - Q.length, H)
        Z += l$(H);
      Z += Q;
    }
    if (Y = J[$], Q = Y + "", H = X0 - Q.length, H)
      Z += l$(H);
  } else if (Y === 0)
    return "0";
  for (;Y % 10 === 0; )
    Y /= 10;
  return Z + Y;
};
var eJ = function(J, $, H) {
  if (J !== ~~J || J < $ || J > H)
    throw Error(c$ + J);
};
var QQ = function(J, $, H, Q) {
  var W, Z, Y, z;
  for (Z = J[0];Z >= 10; Z /= 10)
    --$;
  if (--$ < 0)
    $ += X0, W = 0;
  else
    W = Math.ceil(($ + 1) / X0), $ %= X0;
  if (Z = bJ(10, X0 - $), z = J[W] % Z | 0, Q == null)
    if ($ < 3) {
      if ($ == 0)
        z = z / 100 | 0;
      else if ($ == 1)
        z = z / 10 | 0;
      Y = H < 4 && z == 99999 || H > 3 && z == 49999 || z == 50000 || z == 0;
    } else
      Y = (H < 4 && z + 1 == Z || H > 3 && z + 1 == Z / 2) && (J[W + 1] / Z / 100 | 0) == bJ(10, $ - 2) - 1 || (z == Z / 2 || z == 0) && (J[W + 1] / Z / 100 | 0) == 0;
  else if ($ < 4) {
    if ($ == 0)
      z = z / 1000 | 0;
    else if ($ == 1)
      z = z / 100 | 0;
    else if ($ == 2)
      z = z / 10 | 0;
    Y = (Q || H < 4) && z == 9999 || !Q && H > 3 && z == 4999;
  } else
    Y = ((Q || H < 4) && z + 1 == Z || !Q && H > 3 && z + 1 == Z / 2) && (J[W + 1] / Z / 1000 | 0) == bJ(10, $ - 3) - 1;
  return Y;
};
var oQ = function(J, $, H) {
  var Q, W = [0], Z, Y = 0, z = J.length;
  for (;Y < z; ) {
    for (Z = W.length;Z--; )
      W[Z] *= $;
    W[0] += d6.indexOf(J.charAt(Y++));
    for (Q = 0;Q < W.length; Q++)
      if (W[Q] > H - 1) {
        if (W[Q + 1] === undefined)
          W[Q + 1] = 0;
        W[Q + 1] += W[Q] / H | 0, W[Q] %= H;
      }
  }
  return W.reverse();
};
var z9 = function(J, $) {
  var H, Q, W;
  if ($.isZero())
    return $;
  if (Q = $.d.length, Q < 32)
    H = Math.ceil(Q / 3), W = (1 / Z8(4, H)).toString();
  else
    H = 16, W = "2.3283064365386962890625e-10";
  J.precision += H, $ = AH(J, 1, $.times(W), new J(1));
  for (var Z = H;Z--; ) {
    var Y = $.times($);
    $ = Y.times(Y).minus(Y).times(8).plus(1);
  }
  return J.precision -= H, $;
};
var V0 = function(J, $, H, Q) {
  var W, Z, Y, z, j, V, U, C, q, K = J.constructor;
  J:
    if ($ != null) {
      if (C = J.d, !C)
        return J;
      for (W = 1, z = C[0];z >= 10; z /= 10)
        W++;
      if (Z = $ - W, Z < 0)
        Z += X0, Y = $, U = C[q = 0], j = U / bJ(10, W - Y - 1) % 10 | 0;
      else if (q = Math.ceil((Z + 1) / X0), z = C.length, q >= z)
        if (Q) {
          for (;z++ <= q; )
            C.push(0);
          U = j = 0, W = 1, Z %= X0, Y = Z - X0 + 1;
        } else
          break J;
      else {
        U = z = C[q];
        for (W = 1;z >= 10; z /= 10)
          W++;
        Z %= X0, Y = Z - X0 + W, j = Y < 0 ? 0 : U / bJ(10, W - Y - 1) % 10 | 0;
      }
      if (Q = Q || $ < 0 || C[q + 1] !== undefined || (Y < 0 ? U : U % bJ(10, W - Y - 1)), V = H < 4 ? (j || Q) && (H == 0 || H == (J.s < 0 ? 3 : 2)) : j > 5 || j == 5 && (H == 4 || Q || H == 6 && (Z > 0 ? Y > 0 ? U / bJ(10, W - Y) : 0 : C[q - 1]) % 10 & 1 || H == (J.s < 0 ? 8 : 7)), $ < 1 || !C[0]) {
        if (C.length = 0, V)
          $ -= J.e + 1, C[0] = bJ(10, (X0 - $ % X0) % X0), J.e = -$ || 0;
        else
          C[0] = J.e = 0;
        return J;
      }
      if (Z == 0)
        C.length = q, z = 1, q--;
      else
        C.length = q + 1, z = bJ(10, X0 - Z), C[q] = Y > 0 ? (U / bJ(10, W - Y) % bJ(10, Y) | 0) * z : 0;
      if (V)
        for (;; )
          if (q == 0) {
            for (Z = 1, Y = C[0];Y >= 10; Y /= 10)
              Z++;
            Y = C[0] += z;
            for (z = 1;Y >= 10; Y /= 10)
              z++;
            if (Z != z) {
              if (J.e++, C[0] == F$)
                C[0] = 1;
            }
            break;
          } else {
            if (C[q] += z, C[q] != F$)
              break;
            C[q--] = 0, z = 1;
          }
      for (Z = C.length;C[--Z] === 0; )
        C.pop();
    }
  if (C0) {
    if (J.e > K.maxE)
      J.d = null, J.e = NaN;
    else if (J.e < K.minE)
      J.e = 0, J.d = [0];
  }
  return J;
};
var M$ = function(J, $, H) {
  if (!J.isFinite())
    return jY(J);
  var Q, W = J.e, Z = xJ(J.d), Y = Z.length;
  if ($) {
    if (H && (Q = H - Y) > 0)
      Z = Z.charAt(0) + "." + Z.slice(1) + l$(Q);
    else if (Y > 1)
      Z = Z.charAt(0) + "." + Z.slice(1);
    Z = Z + (J.e < 0 ? "e" : "e+") + J.e;
  } else if (W < 0) {
    if (Z = "0." + l$(-W - 1) + Z, H && (Q = H - Y) > 0)
      Z += l$(Q);
  } else if (W >= Y) {
    if (Z += l$(W + 1 - Y), H && (Q = H - W - 1) > 0)
      Z = Z + "." + l$(Q);
  } else {
    if ((Q = W + 1) < Y)
      Z = Z.slice(0, Q) + "." + Z.slice(Q);
    if (H && (Q = H - Y) > 0) {
      if (W + 1 === Y)
        Z += ".";
      Z += l$(Q);
    }
  }
  return Z;
};
var W8 = function(J, $) {
  var H = J[0];
  for ($ *= X0;H >= 10; H /= 10)
    $++;
  return $;
};
var H8 = function(J, $, H) {
  if ($ > Y9) {
    if (C0 = true, H)
      J.precision = H;
    throw Error($Y);
  }
  return V0(new J(J8), $, 1, true);
};
var G$ = function(J, $, H) {
  if ($ > l6)
    throw Error($Y);
  return V0(new J($8), $, H, true);
};
var ZY = function(J) {
  var $ = J.length - 1, H = $ * X0 + 1;
  if ($ = J[$], $) {
    for (;$ % 10 == 0; $ /= 10)
      H--;
    for ($ = J[0];$ >= 10; $ /= 10)
      H++;
  }
  return H;
};
var l$ = function(J) {
  var $ = "";
  for (;J--; )
    $ += "0";
  return $;
};
var YY = function(J, $, H, Q) {
  var W, Z = new J(1), Y = Math.ceil(Q / X0 + 4);
  C0 = false;
  for (;; ) {
    if (H % 2) {
      if (Z = Z.times($), tZ(Z.d, Y))
        W = true;
    }
    if (H = IJ(H / 2), H === 0) {
      if (H = Z.d.length - 1, W && Z.d[H] === 0)
        ++Z.d[H];
      break;
    }
    $ = $.times($), tZ($.d, Y);
  }
  return C0 = true, Z;
};
var eZ = function(J) {
  return J.d[J.d.length - 1] & 1;
};
var zY = function(J, $, H) {
  var Q, W = new J($[0]), Z = 0;
  for (;++Z < $.length; )
    if (Q = new J($[Z]), !Q.s) {
      W = Q;
      break;
    } else if (W[H](Q))
      W = Q;
  return W;
};
var u6 = function(J, $) {
  var H, Q, W, Z, Y, z, j, V = 0, U = 0, C = 0, q = J.constructor, K = q.rounding, w2 = q.precision;
  if (!J.d || !J.d[0] || J.e > 17)
    return new q(J.d ? !J.d[0] ? 1 : J.s < 0 ? 0 : Infinity : J.s ? J.s < 0 ? 0 : J : NaN);
  if ($ == null)
    C0 = false, j = w2;
  else
    j = $;
  z = new q(0.03125);
  while (J.e > -2)
    J = J.times(z), C += 5;
  Q = Math.log(bJ(2, C)) / Math.LN10 * 2 + 5 | 0, j += Q, H = Z = Y = new q(1), q.precision = j;
  for (;; ) {
    if (Z = V0(Z.times(J), j, 1), H = H.times(++U), z = Y.plus(I0(Z, H, j, 1)), xJ(z.d).slice(0, j) === xJ(Y.d).slice(0, j)) {
      W = C;
      while (W--)
        Y = V0(Y.times(Y), j, 1);
      if ($ == null)
        if (V < 3 && QQ(Y.d, j - Q, K, V))
          q.precision = j += 10, H = Z = z = new q(1), U = 0, V++;
        else
          return V0(Y, q.precision = w2, K, C0 = true);
      else
        return q.precision = w2, Y;
    }
    Y = z;
  }
};
var u$ = function(J, $) {
  var H, Q, W, Z, Y, z, j, V, U, C, q, K = 1, w2 = 10, O = J, h2 = O.d, b = O.constructor, N = b.rounding, x = b.precision;
  if (O.s < 0 || !h2 || !h2[0] || !O.e && h2[0] == 1 && h2.length == 1)
    return new b(h2 && !h2[0] ? (-Infinity) : O.s != 1 ? NaN : h2 ? 0 : O);
  if ($ == null)
    C0 = false, U = x;
  else
    U = $;
  if (b.precision = U += w2, H = xJ(h2), Q = H.charAt(0), Math.abs(Z = O.e) < 1500000000000000) {
    while (Q < 7 && Q != 1 || Q == 1 && H.charAt(1) > 3)
      O = O.times(J), H = xJ(O.d), Q = H.charAt(0), K++;
    if (Z = O.e, Q > 1)
      O = new b("0." + H), Z++;
    else
      O = new b(Q + "." + H.slice(1));
  } else
    return V = H8(b, U + 2, x).times(Z + ""), O = u$(new b(Q + "." + H.slice(1)), U - w2).plus(V), b.precision = x, $ == null ? V0(O, x, N, C0 = true) : O;
  C = O, j = Y = O = I0(O.minus(1), O.plus(1), U, 1), q = V0(O.times(O), U, 1), W = 3;
  for (;; ) {
    if (Y = V0(Y.times(q), U, 1), V = j.plus(I0(Y, new b(W), U, 1)), xJ(V.d).slice(0, U) === xJ(j.d).slice(0, U)) {
      if (j = j.times(2), Z !== 0)
        j = j.plus(H8(b, U + 2, x).times(Z + ""));
      if (j = I0(j, new b(K), U, 1), $ == null)
        if (QQ(j.d, U - w2, N, z))
          b.precision = U += w2, V = Y = O = I0(C.minus(1), C.plus(1), U, 1), q = V0(O.times(O), U, 1), W = z = 1;
        else
          return V0(j, b.precision = x, N, C0 = true);
      else
        return b.precision = x, j;
    }
    j = V, W += 2;
  }
};
var jY = function(J) {
  return String(J.s * J.s / 0);
};
var c6 = function(J, $) {
  var H, Q, W;
  if ((H = $.indexOf(".")) > -1)
    $ = $.replace(".", "");
  if ((Q = $.search(/e/i)) > 0) {
    if (H < 0)
      H = Q;
    H += +$.slice(Q + 1), $ = $.substring(0, Q);
  } else if (H < 0)
    H = $.length;
  for (Q = 0;$.charCodeAt(Q) === 48; Q++)
    ;
  for (W = $.length;$.charCodeAt(W - 1) === 48; --W)
    ;
  if ($ = $.slice(Q, W), $) {
    if (W -= Q, J.e = H = H - Q - 1, J.d = [], Q = (H + 1) % X0, H < 0)
      Q += X0;
    if (Q < W) {
      if (Q)
        J.d.push(+$.slice(0, Q));
      for (W -= X0;Q < W; )
        J.d.push(+$.slice(Q, Q += X0));
      $ = $.slice(Q), Q = X0 - $.length;
    } else
      Q -= W;
    for (;Q--; )
      $ += "0";
    if (J.d.push(+$), C0) {
      if (J.e > J.constructor.maxE)
        J.d = null, J.e = NaN;
      else if (J.e < J.constructor.minE)
        J.e = 0, J.d = [0];
    }
  } else
    J.e = 0, J.d = [0];
  return J;
};
var j9 = function(J, $) {
  var H, Q, W, Z, Y, z, j, V, U;
  if ($.indexOf("_") > -1) {
    if ($ = $.replace(/(\d)_(?=\d)/g, "$1"), WY.test($))
      return c6(J, $);
  } else if ($ === "Infinity" || $ === "NaN") {
    if (!+$)
      J.s = NaN;
    return J.e = NaN, J.d = null, J;
  }
  if (Q9.test($))
    H = 16, $ = $.toLowerCase();
  else if (H9.test($))
    H = 2;
  else if (W9.test($))
    H = 8;
  else
    throw Error(c$ + $);
  if (Z = $.search(/p/i), Z > 0)
    j = +$.slice(Z + 1), $ = $.substring(2, Z);
  else
    $ = $.slice(2);
  if (Z = $.indexOf("."), Y = Z >= 0, Q = J.constructor, Y)
    $ = $.replace(".", ""), z = $.length, Z = z - Z, W = YY(Q, new Q(H), Z, Z * 2);
  V = oQ($, H, F$), U = V.length - 1;
  for (Z = U;V[Z] === 0; --Z)
    V.pop();
  if (Z < 0)
    return new Q(J.s * 0);
  if (J.e = W8(V, U), J.d = V, C0 = false, Y)
    J = I0(J, W, z * 4);
  if (j)
    J = J.times(Math.abs(j) < 54 ? bJ(2, j) : WQ.pow(2, j));
  return C0 = true, J;
};
var V9 = function(J, $) {
  var H, Q = $.d.length;
  if (Q < 3)
    return $.isZero() ? $ : AH(J, 2, $, $);
  H = 1.4 * Math.sqrt(Q), H = H > 16 ? 16 : H | 0, $ = $.times(1 / Z8(5, H)), $ = AH(J, 2, $, $);
  var W, Z = new J(5), Y = new J(16), z = new J(20);
  for (;H--; )
    W = $.times($), $ = $.times(Z.plus(W.times(Y.times(W).minus(z))));
  return $;
};
var AH = function(J, $, H, Q, W) {
  var Z, Y, z, j, V = 1, U = J.precision, C = Math.ceil(U / X0);
  C0 = false, j = H.times(H), z = new J(Q);
  for (;; ) {
    if (Y = I0(z.times(j), new J($++ * $++), U, 1), z = W ? Q.plus(Y) : Q.minus(Y), Q = I0(Y.times(j), new J($++ * $++), U, 1), Y = z.plus(Q), Y.d[C] !== undefined) {
      for (Z = C;Y.d[Z] === z.d[Z] && Z--; )
        ;
      if (Z == -1)
        break;
    }
    Z = z, z = Q, Q = Y, Y = Z, V++;
  }
  return C0 = true, Y.d.length = C + 1, Y;
};
var Z8 = function(J, $) {
  var H = J;
  while (--$)
    H *= J;
  return H;
};
var VY = function(J, $) {
  var H, Q = $.s < 0, W = G$(J, J.precision, 1), Z = W.times(0.5);
  if ($ = $.abs(), $.lte(Z))
    return k$ = Q ? 4 : 1, $;
  if (H = $.divToInt(W), H.isZero())
    k$ = Q ? 3 : 2;
  else {
    if ($ = $.minus(H.times(W)), $.lte(Z))
      return k$ = eZ(H) ? Q ? 2 : 3 : Q ? 4 : 1, $;
    k$ = eZ(H) ? Q ? 1 : 4 : Q ? 3 : 2;
  }
  return $.minus(W).abs();
};
var s6 = function(J, $, H, Q) {
  var W, Z, Y, z, j, V, U, C, q, K = J.constructor, w2 = H !== undefined;
  if (w2)
    if (eJ(H, 1, s$), Q === undefined)
      Q = K.rounding;
    else
      eJ(Q, 0, 8);
  else
    H = K.precision, Q = K.rounding;
  if (!J.isFinite())
    U = jY(J);
  else {
    if (U = M$(J), Y = U.indexOf("."), w2) {
      if (W = 2, $ == 16)
        H = H * 4 - 3;
      else if ($ == 8)
        H = H * 3 - 2;
    } else
      W = $;
    if (Y >= 0)
      U = U.replace(".", ""), q = new K(1), q.e = U.length - Y, q.d = oQ(M$(q), 10, W), q.e = q.d.length;
    C = oQ(U, 10, W), Z = j = C.length;
    for (;C[--j] == 0; )
      C.pop();
    if (!C[0])
      U = w2 ? "0p+0" : "0";
    else {
      if (Y < 0)
        Z--;
      else
        J = new K(J), J.d = C, J.e = Z, J = I0(J, q, H, Q, 0, W), C = J.d, Z = J.e, V = JY;
      if (Y = C[H], z = W / 2, V = V || C[H + 1] !== undefined, V = Q < 4 ? (Y !== undefined || V) && (Q === 0 || Q === (J.s < 0 ? 3 : 2)) : Y > z || Y === z && (Q === 4 || V || Q === 6 && C[H - 1] & 1 || Q === (J.s < 0 ? 8 : 7)), C.length = H, V) {
        for (;++C[--H] > W - 1; )
          if (C[H] = 0, !H)
            ++Z, C.unshift(1);
      }
      for (j = C.length;!C[j - 1]; --j)
        ;
      for (Y = 0, U = "";Y < j; Y++)
        U += d6.charAt(C[Y]);
      if (w2) {
        if (j > 1)
          if ($ == 16 || $ == 8) {
            Y = $ == 16 ? 4 : 3;
            for (--j;j % Y; j++)
              U += "0";
            C = oQ(U, W, $);
            for (j = C.length;!C[j - 1]; --j)
              ;
            for (Y = 1, U = "1.";Y < j; Y++)
              U += d6.charAt(C[Y]);
          } else
            U = U.charAt(0) + "." + U.slice(1);
        U = U + (Z < 0 ? "p" : "p+") + Z;
      } else if (Z < 0) {
        for (;++Z; )
          U = "0" + U;
        U = "0." + U;
      } else if (++Z > j)
        for (Z -= j;Z--; )
          U += "0";
      else if (Z < j)
        U = U.slice(0, Z) + "." + U.slice(Z);
    }
    U = ($ == 16 ? "0x" : $ == 2 ? "0b" : $ == 8 ? "0o" : "") + U;
  }
  return J.s < 0 ? "-" + U : U;
};
var tZ = function(J, $) {
  if (J.length > $)
    return J.length = $, true;
};
var G9 = function(J) {
  return new this(J).abs();
};
var F9 = function(J) {
  return new this(J).acos();
};
var X9 = function(J) {
  return new this(J).acosh();
};
var U9 = function(J, $) {
  return new this(J).plus($);
};
var D9 = function(J) {
  return new this(J).asin();
};
var q9 = function(J) {
  return new this(J).asinh();
};
var v9 = function(J) {
  return new this(J).atan();
};
var C9 = function(J) {
  return new this(J).atanh();
};
var R9 = function(J, $) {
  J = new this(J), $ = new this($);
  var H, Q = this.precision, W = this.rounding, Z = Q + 4;
  if (!J.s || !$.s)
    H = new this(NaN);
  else if (!J.d && !$.d)
    H = G$(this, Z, 1).times($.s > 0 ? 0.25 : 0.75), H.s = J.s;
  else if (!$.d || J.isZero())
    H = $.s < 0 ? G$(this, Q, W) : new this(0), H.s = J.s;
  else if (!J.d || $.isZero())
    H = G$(this, Z, 1).times(0.5), H.s = J.s;
  else if ($.s < 0)
    this.precision = Z, this.rounding = 1, H = this.atan(I0(J, $, Z, 1)), $ = G$(this, Z, 1), this.precision = Q, this.rounding = W, H = J.s < 0 ? H.minus($) : H.plus($);
  else
    H = this.atan(I0(J, $, Z, 1));
  return H;
};
var B9 = function(J) {
  return new this(J).cbrt();
};
var M9 = function(J) {
  return V0(J = new this(J), J.e + 1, 2);
};
var O9 = function(J, $, H) {
  return new this(J).clamp($, H);
};
var L9 = function(J) {
  if (!J || typeof J !== "object")
    throw Error(Q8 + "Object expected");
  var $, H, Q, W = J.defaults === true, Z = ["precision", 1, s$, "rounding", 0, 8, "toExpNeg", -xH, 0, "toExpPos", 0, xH, "maxE", 0, xH, "minE", -xH, 0, "modulo", 0, 9];
  for ($ = 0;$ < Z.length; $ += 3) {
    if (H = Z[$], W)
      this[H] = p6[H];
    if ((Q = J[H]) !== undefined)
      if (IJ(Q) === Q && Q >= Z[$ + 1] && Q <= Z[$ + 2])
        this[H] = Q;
      else
        throw Error(c$ + H + ": " + Q);
  }
  if (H = "crypto", W)
    this[H] = p6[H];
  if ((Q = J[H]) !== undefined)
    if (Q === true || Q === false || Q === 0 || Q === 1)
      if (Q)
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[H] = true;
        else
          throw Error(HY);
      else
        this[H] = false;
    else
      throw Error(c$ + H + ": " + Q);
  return this;
};
var K9 = function(J) {
  return new this(J).cos();
};
var h9 = function(J) {
  return new this(J).cosh();
};
var GY = function(J) {
  var $, H, Q;
  function W(Z) {
    var Y, z, j, V = this;
    if (!(V instanceof W))
      return new W(Z);
    if (V.constructor = W, oZ(Z)) {
      if (V.s = Z.s, C0)
        if (!Z.d || Z.e > W.maxE)
          V.e = NaN, V.d = null;
        else if (Z.e < W.minE)
          V.e = 0, V.d = [0];
        else
          V.e = Z.e, V.d = Z.d.slice();
      else
        V.e = Z.e, V.d = Z.d ? Z.d.slice() : Z.d;
      return;
    }
    if (j = typeof Z, j === "number") {
      if (Z === 0) {
        V.s = 1 / Z < 0 ? -1 : 1, V.e = 0, V.d = [0];
        return;
      }
      if (Z < 0)
        Z = -Z, V.s = -1;
      else
        V.s = 1;
      if (Z === ~~Z && Z < 1e7) {
        for (Y = 0, z = Z;z >= 10; z /= 10)
          Y++;
        if (C0)
          if (Y > W.maxE)
            V.e = NaN, V.d = null;
          else if (Y < W.minE)
            V.e = 0, V.d = [0];
          else
            V.e = Y, V.d = [Z];
        else
          V.e = Y, V.d = [Z];
        return;
      } else if (Z * 0 !== 0) {
        if (!Z)
          V.s = NaN;
        V.e = NaN, V.d = null;
        return;
      }
      return c6(V, Z.toString());
    } else if (j !== "string")
      throw Error(c$ + Z);
    if ((z = Z.charCodeAt(0)) === 45)
      Z = Z.slice(1), V.s = -1;
    else {
      if (z === 43)
        Z = Z.slice(1);
      V.s = 1;
    }
    return WY.test(Z) ? c6(V, Z) : j9(V, Z);
  }
  if (W.prototype = s2, W.ROUND_UP = 0, W.ROUND_DOWN = 1, W.ROUND_CEIL = 2, W.ROUND_FLOOR = 3, W.ROUND_HALF_UP = 4, W.ROUND_HALF_DOWN = 5, W.ROUND_HALF_EVEN = 6, W.ROUND_HALF_CEIL = 7, W.ROUND_HALF_FLOOR = 8, W.EUCLID = 9, W.config = W.set = L9, W.clone = GY, W.isDecimal = oZ, W.abs = G9, W.acos = F9, W.acosh = X9, W.add = U9, W.asin = D9, W.asinh = q9, W.atan = v9, W.atanh = C9, W.atan2 = R9, W.cbrt = B9, W.ceil = M9, W.clamp = O9, W.cos = K9, W.cosh = h9, W.div = E9, W.exp = S9, W.floor = w9, W.hypot = b9, W.ln = _9, W.log = P9, W.log10 = g9, W.log2 = N9, W.max = k9, W.min = x9, W.mod = A9, W.mul = T9, W.pow = f9, W.random = y9, W.round = I9, W.sign = m9, W.sin = d9, W.sinh = p9, W.sqrt = l9, W.sub = u9, W.sum = c9, W.tan = s9, W.tanh = a9, W.trunc = i9, J === undefined)
    J = {};
  if (J) {
    if (J.defaults !== true) {
      Q = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for ($ = 0;$ < Q.length; )
        if (!J.hasOwnProperty(H = Q[$++]))
          J[H] = this[H];
    }
  }
  return W.config(J), W;
};
var E9 = function(J, $) {
  return new this(J).div($);
};
var S9 = function(J) {
  return new this(J).exp();
};
var w9 = function(J) {
  return V0(J = new this(J), J.e + 1, 3);
};
var b9 = function() {
  var J, $, H = new this(0);
  C0 = false;
  for (J = 0;J < arguments.length; )
    if ($ = new this(arguments[J++]), !$.d) {
      if ($.s)
        return C0 = true, new this(Infinity);
      H = $;
    } else if (H.d)
      H = H.plus($.times($));
  return C0 = true, H.sqrt();
};
var oZ = function(J) {
  return J instanceof WQ || J && J.toStringTag === QY || false;
};
var _9 = function(J) {
  return new this(J).ln();
};
var P9 = function(J, $) {
  return new this(J).log($);
};
var N9 = function(J) {
  return new this(J).log(2);
};
var g9 = function(J) {
  return new this(J).log(10);
};
var k9 = function() {
  return zY(this, arguments, "lt");
};
var x9 = function() {
  return zY(this, arguments, "gt");
};
var A9 = function(J, $) {
  return new this(J).mod($);
};
var T9 = function(J, $) {
  return new this(J).mul($);
};
var f9 = function(J, $) {
  return new this(J).pow($);
};
var y9 = function(J) {
  var $, H, Q, W, Z = 0, Y = new this(1), z = [];
  if (J === undefined)
    J = this.precision;
  else
    eJ(J, 1, s$);
  if (Q = Math.ceil(J / X0), !this.crypto)
    for (;Z < Q; )
      z[Z++] = Math.random() * 1e7 | 0;
  else if (crypto.getRandomValues) {
    $ = crypto.getRandomValues(new Uint32Array(Q));
    for (;Z < Q; )
      if (W = $[Z], W >= 4290000000)
        $[Z] = crypto.getRandomValues(new Uint32Array(1))[0];
      else
        z[Z++] = W % 1e7;
  } else if (crypto.randomBytes) {
    $ = crypto.randomBytes(Q *= 4);
    for (;Z < Q; )
      if (W = $[Z] + ($[Z + 1] << 8) + ($[Z + 2] << 16) + (($[Z + 3] & 127) << 24), W >= 2140000000)
        crypto.randomBytes(4).copy($, Z);
      else
        z.push(W % 1e7), Z += 4;
    Z = Q / 4;
  } else
    throw Error(HY);
  if (Q = z[--Z], J %= X0, Q && J)
    W = bJ(10, X0 - J), z[Z] = (Q / W | 0) * W;
  for (;z[Z] === 0; Z--)
    z.pop();
  if (Z < 0)
    H = 0, z = [0];
  else {
    H = -1;
    for (;z[0] === 0; H -= X0)
      z.shift();
    for (Q = 1, W = z[0];W >= 10; W /= 10)
      Q++;
    if (Q < X0)
      H -= X0 - Q;
  }
  return Y.e = H, Y.d = z, Y;
};
var I9 = function(J) {
  return V0(J = new this(J), J.e + 1, this.rounding);
};
var m9 = function(J) {
  return J = new this(J), J.d ? J.d[0] ? J.s : 0 * J.s : J.s || NaN;
};
var d9 = function(J) {
  return new this(J).sin();
};
var p9 = function(J) {
  return new this(J).sinh();
};
var l9 = function(J) {
  return new this(J).sqrt();
};
var u9 = function(J, $) {
  return new this(J).sub($);
};
var c9 = function() {
  var J = 0, $ = arguments, H = new this($[J]);
  C0 = false;
  for (;H.s && ++J < $.length; )
    H = H.plus($[J]);
  return C0 = true, V0(H, this.precision, this.rounding);
};
var s9 = function(J) {
  return new this(J).tan();
};
var a9 = function(J) {
  return new this(J).tanh();
};
var i9 = function(J) {
  return V0(J = new this(J), J.e + 1, 1);
};
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var xH = 9000000000000000;
var s$ = 1e9;
var d6 = "0123456789abcdef";
var J8 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var $8 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var p6 = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -xH, maxE: xH, crypto: false };
var JY;
var k$;
var C0 = true;
var Q8 = "[DecimalError] ";
var c$ = Q8 + "Invalid argument: ";
var $Y = Q8 + "Precision limit exceeded";
var HY = Q8 + "crypto unavailable";
var QY = "[object Decimal]";
var IJ = Math.floor;
var bJ = Math.pow;
var H9 = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var Q9 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var W9 = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var WY = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var F$ = 1e7;
var X0 = 7;
var Z9 = 9007199254740991;
var Y9 = J8.length - 1;
var l6 = $8.length - 1;
var s2 = { toStringTag: QY };
s2.absoluteValue = s2.abs = function() {
  var J = new this.constructor(this);
  if (J.s < 0)
    J.s = 1;
  return V0(J);
};
s2.ceil = function() {
  return V0(new this.constructor(this), this.e + 1, 2);
};
s2.clampedTo = s2.clamp = function(J, $) {
  var H, Q = this, W = Q.constructor;
  if (J = new W(J), $ = new W($), !J.s || !$.s)
    return new W(NaN);
  if (J.gt($))
    throw Error(c$ + $);
  return H = Q.cmp(J), H < 0 ? J : Q.cmp($) > 0 ? $ : new W(Q);
};
s2.comparedTo = s2.cmp = function(J) {
  var $, H, Q, W, Z = this, Y = Z.d, z = (J = new Z.constructor(J)).d, j = Z.s, V = J.s;
  if (!Y || !z)
    return !j || !V ? NaN : j !== V ? j : Y === z ? 0 : !Y ^ j < 0 ? 1 : -1;
  if (!Y[0] || !z[0])
    return Y[0] ? j : z[0] ? -V : 0;
  if (j !== V)
    return j;
  if (Z.e !== J.e)
    return Z.e > J.e ^ j < 0 ? 1 : -1;
  Q = Y.length, W = z.length;
  for ($ = 0, H = Q < W ? Q : W;$ < H; ++$)
    if (Y[$] !== z[$])
      return Y[$] > z[$] ^ j < 0 ? 1 : -1;
  return Q === W ? 0 : Q > W ^ j < 0 ? 1 : -1;
};
s2.cosine = s2.cos = function() {
  var J, $, H = this, Q = H.constructor;
  if (!H.d)
    return new Q(NaN);
  if (!H.d[0])
    return new Q(1);
  return J = Q.precision, $ = Q.rounding, Q.precision = J + Math.max(H.e, H.sd()) + X0, Q.rounding = 1, H = z9(Q, VY(Q, H)), Q.precision = J, Q.rounding = $, V0(k$ == 2 || k$ == 3 ? H.neg() : H, J, $, true);
};
s2.cubeRoot = s2.cbrt = function() {
  var J, $, H, Q, W, Z, Y, z, j, V, U = this, C = U.constructor;
  if (!U.isFinite() || U.isZero())
    return new C(U);
  if (C0 = false, Z = U.s * bJ(U.s * U, 0.3333333333333333), !Z || Math.abs(Z) == Infinity) {
    if (H = xJ(U.d), J = U.e, Z = (J - H.length + 1) % 3)
      H += Z == 1 || Z == -2 ? "0" : "00";
    if (Z = bJ(H, 0.3333333333333333), J = IJ((J + 1) / 3) - (J % 3 == (J < 0 ? -1 : 2)), Z == Infinity)
      H = "5e" + J;
    else
      H = Z.toExponential(), H = H.slice(0, H.indexOf("e") + 1) + J;
    Q = new C(H), Q.s = U.s;
  } else
    Q = new C(Z.toString());
  Y = (J = C.precision) + 3;
  for (;; )
    if (z = Q, j = z.times(z).times(z), V = j.plus(U), Q = I0(V.plus(U).times(z), V.plus(j), Y + 2, 1), xJ(z.d).slice(0, Y) === (H = xJ(Q.d)).slice(0, Y))
      if (H = H.slice(Y - 3, Y + 1), H == "9999" || !W && H == "4999") {
        if (!W) {
          if (V0(z, J + 1, 0), z.times(z).times(z).eq(U)) {
            Q = z;
            break;
          }
        }
        Y += 4, W = 1;
      } else {
        if (!+H || !+H.slice(1) && H.charAt(0) == "5")
          V0(Q, J + 1, 1), $ = !Q.times(Q).times(Q).eq(U);
        break;
      }
  return C0 = true, V0(Q, J, C.rounding, $);
};
s2.decimalPlaces = s2.dp = function() {
  var J, $ = this.d, H = NaN;
  if ($) {
    if (J = $.length - 1, H = (J - IJ(this.e / X0)) * X0, J = $[J], J)
      for (;J % 10 == 0; J /= 10)
        H--;
    if (H < 0)
      H = 0;
  }
  return H;
};
s2.dividedBy = s2.div = function(J) {
  return I0(this, new this.constructor(J));
};
s2.dividedToIntegerBy = s2.divToInt = function(J) {
  var $ = this, H = $.constructor;
  return V0(I0($, new H(J), 0, 1, 1), H.precision, H.rounding);
};
s2.equals = s2.eq = function(J) {
  return this.cmp(J) === 0;
};
s2.floor = function() {
  return V0(new this.constructor(this), this.e + 1, 3);
};
s2.greaterThan = s2.gt = function(J) {
  return this.cmp(J) > 0;
};
s2.greaterThanOrEqualTo = s2.gte = function(J) {
  var $ = this.cmp(J);
  return $ == 1 || $ === 0;
};
s2.hyperbolicCosine = s2.cosh = function() {
  var J, $, H, Q, W, Z = this, Y = Z.constructor, z = new Y(1);
  if (!Z.isFinite())
    return new Y(Z.s ? Infinity : NaN);
  if (Z.isZero())
    return z;
  if (H = Y.precision, Q = Y.rounding, Y.precision = H + Math.max(Z.e, Z.sd()) + 4, Y.rounding = 1, W = Z.d.length, W < 32)
    J = Math.ceil(W / 3), $ = (1 / Z8(4, J)).toString();
  else
    J = 16, $ = "2.3283064365386962890625e-10";
  Z = AH(Y, 1, Z.times($), new Y(1), true);
  var j, V = J, U = new Y(8);
  for (;V--; )
    j = Z.times(Z), Z = z.minus(j.times(U.minus(j.times(U))));
  return V0(Z, Y.precision = H, Y.rounding = Q, true);
};
s2.hyperbolicSine = s2.sinh = function() {
  var J, $, H, Q, W = this, Z = W.constructor;
  if (!W.isFinite() || W.isZero())
    return new Z(W);
  if ($ = Z.precision, H = Z.rounding, Z.precision = $ + Math.max(W.e, W.sd()) + 4, Z.rounding = 1, Q = W.d.length, Q < 3)
    W = AH(Z, 2, W, W, true);
  else {
    J = 1.4 * Math.sqrt(Q), J = J > 16 ? 16 : J | 0, W = W.times(1 / Z8(5, J)), W = AH(Z, 2, W, W, true);
    var Y, z = new Z(5), j = new Z(16), V = new Z(20);
    for (;J--; )
      Y = W.times(W), W = W.times(z.plus(Y.times(j.times(Y).plus(V))));
  }
  return Z.precision = $, Z.rounding = H, V0(W, $, H, true);
};
s2.hyperbolicTangent = s2.tanh = function() {
  var J, $, H = this, Q = H.constructor;
  if (!H.isFinite())
    return new Q(H.s);
  if (H.isZero())
    return new Q(H);
  return J = Q.precision, $ = Q.rounding, Q.precision = J + 7, Q.rounding = 1, I0(H.sinh(), H.cosh(), Q.precision = J, Q.rounding = $);
};
s2.inverseCosine = s2.acos = function() {
  var J, $ = this, H = $.constructor, Q = $.abs().cmp(1), W = H.precision, Z = H.rounding;
  if (Q !== -1)
    return Q === 0 ? $.isNeg() ? G$(H, W, Z) : new H(0) : new H(NaN);
  if ($.isZero())
    return G$(H, W + 4, Z).times(0.5);
  return H.precision = W + 6, H.rounding = 1, $ = $.asin(), J = G$(H, W + 4, Z).times(0.5), H.precision = W, H.rounding = Z, J.minus($);
};
s2.inverseHyperbolicCosine = s2.acosh = function() {
  var J, $, H = this, Q = H.constructor;
  if (H.lte(1))
    return new Q(H.eq(1) ? 0 : NaN);
  if (!H.isFinite())
    return new Q(H);
  return J = Q.precision, $ = Q.rounding, Q.precision = J + Math.max(Math.abs(H.e), H.sd()) + 4, Q.rounding = 1, C0 = false, H = H.times(H).minus(1).sqrt().plus(H), C0 = true, Q.precision = J, Q.rounding = $, H.ln();
};
s2.inverseHyperbolicSine = s2.asinh = function() {
  var J, $, H = this, Q = H.constructor;
  if (!H.isFinite() || H.isZero())
    return new Q(H);
  return J = Q.precision, $ = Q.rounding, Q.precision = J + 2 * Math.max(Math.abs(H.e), H.sd()) + 6, Q.rounding = 1, C0 = false, H = H.times(H).plus(1).sqrt().plus(H), C0 = true, Q.precision = J, Q.rounding = $, H.ln();
};
s2.inverseHyperbolicTangent = s2.atanh = function() {
  var J, $, H, Q, W = this, Z = W.constructor;
  if (!W.isFinite())
    return new Z(NaN);
  if (W.e >= 0)
    return new Z(W.abs().eq(1) ? W.s / 0 : W.isZero() ? W : NaN);
  if (J = Z.precision, $ = Z.rounding, Q = W.sd(), Math.max(Q, J) < 2 * -W.e - 1)
    return V0(new Z(W), J, $, true);
  return Z.precision = H = Q - W.e, W = I0(W.plus(1), new Z(1).minus(W), H + J, 1), Z.precision = J + 4, Z.rounding = 1, W = W.ln(), Z.precision = J, Z.rounding = $, W.times(0.5);
};
s2.inverseSine = s2.asin = function() {
  var J, $, H, Q, W = this, Z = W.constructor;
  if (W.isZero())
    return new Z(W);
  if ($ = W.abs().cmp(1), H = Z.precision, Q = Z.rounding, $ !== -1) {
    if ($ === 0)
      return J = G$(Z, H + 4, Q).times(0.5), J.s = W.s, J;
    return new Z(NaN);
  }
  return Z.precision = H + 6, Z.rounding = 1, W = W.div(new Z(1).minus(W.times(W)).sqrt().plus(1)).atan(), Z.precision = H, Z.rounding = Q, W.times(2);
};
s2.inverseTangent = s2.atan = function() {
  var J, $, H, Q, W, Z, Y, z, j, V = this, U = V.constructor, C = U.precision, q = U.rounding;
  if (!V.isFinite()) {
    if (!V.s)
      return new U(NaN);
    if (C + 4 <= l6)
      return Y = G$(U, C + 4, q).times(0.5), Y.s = V.s, Y;
  } else if (V.isZero())
    return new U(V);
  else if (V.abs().eq(1) && C + 4 <= l6)
    return Y = G$(U, C + 4, q).times(0.25), Y.s = V.s, Y;
  U.precision = z = C + 10, U.rounding = 1, H = Math.min(28, z / X0 + 2 | 0);
  for (J = H;J; --J)
    V = V.div(V.times(V).plus(1).sqrt().plus(1));
  C0 = false, $ = Math.ceil(z / X0), Q = 1, j = V.times(V), Y = new U(V), W = V;
  for (;J !== -1; )
    if (W = W.times(j), Z = Y.minus(W.div(Q += 2)), W = W.times(j), Y = Z.plus(W.div(Q += 2)), Y.d[$] !== undefined)
      for (J = $;Y.d[J] === Z.d[J] && J--; )
        ;
  if (H)
    Y = Y.times(2 << H - 1);
  return C0 = true, V0(Y, U.precision = C, U.rounding = q, true);
};
s2.isFinite = function() {
  return !!this.d;
};
s2.isInteger = s2.isInt = function() {
  return !!this.d && IJ(this.e / X0) > this.d.length - 2;
};
s2.isNaN = function() {
  return !this.s;
};
s2.isNegative = s2.isNeg = function() {
  return this.s < 0;
};
s2.isPositive = s2.isPos = function() {
  return this.s > 0;
};
s2.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
s2.lessThan = s2.lt = function(J) {
  return this.cmp(J) < 0;
};
s2.lessThanOrEqualTo = s2.lte = function(J) {
  return this.cmp(J) < 1;
};
s2.logarithm = s2.log = function(J) {
  var $, H, Q, W, Z, Y, z, j, V = this, U = V.constructor, C = U.precision, q = U.rounding, K = 5;
  if (J == null)
    J = new U(10), $ = true;
  else {
    if (J = new U(J), H = J.d, J.s < 0 || !H || !H[0] || J.eq(1))
      return new U(NaN);
    $ = J.eq(10);
  }
  if (H = V.d, V.s < 0 || !H || !H[0] || V.eq(1))
    return new U(H && !H[0] ? (-Infinity) : V.s != 1 ? NaN : H ? 0 : Infinity);
  if ($)
    if (H.length > 1)
      Z = true;
    else {
      for (W = H[0];W % 10 === 0; )
        W /= 10;
      Z = W !== 1;
    }
  if (C0 = false, z = C + K, Y = u$(V, z), Q = $ ? H8(U, z + 10) : u$(J, z), j = I0(Y, Q, z, 1), QQ(j.d, W = C, q))
    do
      if (z += 10, Y = u$(V, z), Q = $ ? H8(U, z + 10) : u$(J, z), j = I0(Y, Q, z, 1), !Z) {
        if (+xJ(j.d).slice(W + 1, W + 15) + 1 == 100000000000000)
          j = V0(j, C + 1, 0);
        break;
      }
    while (QQ(j.d, W += 10, q));
  return C0 = true, V0(j, C, q);
};
s2.minus = s2.sub = function(J) {
  var $, H, Q, W, Z, Y, z, j, V, U, C, q, K = this, w2 = K.constructor;
  if (J = new w2(J), !K.d || !J.d) {
    if (!K.s || !J.s)
      J = new w2(NaN);
    else if (K.d)
      J.s = -J.s;
    else
      J = new w2(J.d || K.s !== J.s ? K : NaN);
    return J;
  }
  if (K.s != J.s)
    return J.s = -J.s, K.plus(J);
  if (V = K.d, q = J.d, z = w2.precision, j = w2.rounding, !V[0] || !q[0]) {
    if (q[0])
      J.s = -J.s;
    else if (V[0])
      J = new w2(K);
    else
      return new w2(j === 3 ? -0 : 0);
    return C0 ? V0(J, z, j) : J;
  }
  if (H = IJ(J.e / X0), U = IJ(K.e / X0), V = V.slice(), Z = U - H, Z) {
    if (C = Z < 0, C)
      $ = V, Z = -Z, Y = q.length;
    else
      $ = q, H = U, Y = V.length;
    if (Q = Math.max(Math.ceil(z / X0), Y) + 2, Z > Q)
      Z = Q, $.length = 1;
    $.reverse();
    for (Q = Z;Q--; )
      $.push(0);
    $.reverse();
  } else {
    if (Q = V.length, Y = q.length, C = Q < Y, C)
      Y = Q;
    for (Q = 0;Q < Y; Q++)
      if (V[Q] != q[Q]) {
        C = V[Q] < q[Q];
        break;
      }
    Z = 0;
  }
  if (C)
    $ = V, V = q, q = $, J.s = -J.s;
  Y = V.length;
  for (Q = q.length - Y;Q > 0; --Q)
    V[Y++] = 0;
  for (Q = q.length;Q > Z; ) {
    if (V[--Q] < q[Q]) {
      for (W = Q;W && V[--W] === 0; )
        V[W] = F$ - 1;
      --V[W], V[Q] += F$;
    }
    V[Q] -= q[Q];
  }
  for (;V[--Y] === 0; )
    V.pop();
  for (;V[0] === 0; V.shift())
    --H;
  if (!V[0])
    return new w2(j === 3 ? -0 : 0);
  return J.d = V, J.e = W8(V, H), C0 ? V0(J, z, j) : J;
};
s2.modulo = s2.mod = function(J) {
  var $, H = this, Q = H.constructor;
  if (J = new Q(J), !H.d || !J.s || J.d && !J.d[0])
    return new Q(NaN);
  if (!J.d || H.d && !H.d[0])
    return V0(new Q(H), Q.precision, Q.rounding);
  if (C0 = false, Q.modulo == 9)
    $ = I0(H, J.abs(), 0, 3, 1), $.s *= J.s;
  else
    $ = I0(H, J, 0, Q.modulo, 1);
  return $ = $.times(J), C0 = true, H.minus($);
};
s2.naturalExponential = s2.exp = function() {
  return u6(this);
};
s2.naturalLogarithm = s2.ln = function() {
  return u$(this);
};
s2.negated = s2.neg = function() {
  var J = new this.constructor(this);
  return J.s = -J.s, V0(J);
};
s2.plus = s2.add = function(J) {
  var $, H, Q, W, Z, Y, z, j, V, U, C = this, q = C.constructor;
  if (J = new q(J), !C.d || !J.d) {
    if (!C.s || !J.s)
      J = new q(NaN);
    else if (!C.d)
      J = new q(J.d || C.s === J.s ? C : NaN);
    return J;
  }
  if (C.s != J.s)
    return J.s = -J.s, C.minus(J);
  if (V = C.d, U = J.d, z = q.precision, j = q.rounding, !V[0] || !U[0]) {
    if (!U[0])
      J = new q(C);
    return C0 ? V0(J, z, j) : J;
  }
  if (Z = IJ(C.e / X0), Q = IJ(J.e / X0), V = V.slice(), W = Z - Q, W) {
    if (W < 0)
      H = V, W = -W, Y = U.length;
    else
      H = U, Q = Z, Y = V.length;
    if (Z = Math.ceil(z / X0), Y = Z > Y ? Z + 1 : Y + 1, W > Y)
      W = Y, H.length = 1;
    H.reverse();
    for (;W--; )
      H.push(0);
    H.reverse();
  }
  if (Y = V.length, W = U.length, Y - W < 0)
    W = Y, H = U, U = V, V = H;
  for ($ = 0;W; )
    $ = (V[--W] = V[W] + U[W] + $) / F$ | 0, V[W] %= F$;
  if ($)
    V.unshift($), ++Q;
  for (Y = V.length;V[--Y] == 0; )
    V.pop();
  return J.d = V, J.e = W8(V, Q), C0 ? V0(J, z, j) : J;
};
s2.precision = s2.sd = function(J) {
  var $, H = this;
  if (J !== undefined && J !== !!J && J !== 1 && J !== 0)
    throw Error(c$ + J);
  if (H.d) {
    if ($ = ZY(H.d), J && H.e + 1 > $)
      $ = H.e + 1;
  } else
    $ = NaN;
  return $;
};
s2.round = function() {
  var J = this, $ = J.constructor;
  return V0(new $(J), J.e + 1, $.rounding);
};
s2.sine = s2.sin = function() {
  var J, $, H = this, Q = H.constructor;
  if (!H.isFinite())
    return new Q(NaN);
  if (H.isZero())
    return new Q(H);
  return J = Q.precision, $ = Q.rounding, Q.precision = J + Math.max(H.e, H.sd()) + X0, Q.rounding = 1, H = V9(Q, VY(Q, H)), Q.precision = J, Q.rounding = $, V0(k$ > 2 ? H.neg() : H, J, $, true);
};
s2.squareRoot = s2.sqrt = function() {
  var J, $, H, Q, W, Z, Y = this, z = Y.d, j = Y.e, V = Y.s, U = Y.constructor;
  if (V !== 1 || !z || !z[0])
    return new U(!V || V < 0 && (!z || z[0]) ? NaN : z ? Y : Infinity);
  if (C0 = false, V = Math.sqrt(+Y), V == 0 || V == Infinity) {
    if ($ = xJ(z), ($.length + j) % 2 == 0)
      $ += "0";
    if (V = Math.sqrt($), j = IJ((j + 1) / 2) - (j < 0 || j % 2), V == Infinity)
      $ = "5e" + j;
    else
      $ = V.toExponential(), $ = $.slice(0, $.indexOf("e") + 1) + j;
    Q = new U($);
  } else
    Q = new U(V.toString());
  H = (j = U.precision) + 3;
  for (;; )
    if (Z = Q, Q = Z.plus(I0(Y, Z, H + 2, 1)).times(0.5), xJ(Z.d).slice(0, H) === ($ = xJ(Q.d)).slice(0, H))
      if ($ = $.slice(H - 3, H + 1), $ == "9999" || !W && $ == "4999") {
        if (!W) {
          if (V0(Z, j + 1, 0), Z.times(Z).eq(Y)) {
            Q = Z;
            break;
          }
        }
        H += 4, W = 1;
      } else {
        if (!+$ || !+$.slice(1) && $.charAt(0) == "5")
          V0(Q, j + 1, 1), J = !Q.times(Q).eq(Y);
        break;
      }
  return C0 = true, V0(Q, j, U.rounding, J);
};
s2.tangent = s2.tan = function() {
  var J, $, H = this, Q = H.constructor;
  if (!H.isFinite())
    return new Q(NaN);
  if (H.isZero())
    return new Q(H);
  return J = Q.precision, $ = Q.rounding, Q.precision = J + 10, Q.rounding = 1, H = H.sin(), H.s = 1, H = I0(H, new Q(1).minus(H.times(H)).sqrt(), J + 10, 0), Q.precision = J, Q.rounding = $, V0(k$ == 2 || k$ == 4 ? H.neg() : H, J, $, true);
};
s2.times = s2.mul = function(J) {
  var $, H, Q, W, Z, Y, z, j, V, U = this, C = U.constructor, q = U.d, K = (J = new C(J)).d;
  if (J.s *= U.s, !q || !q[0] || !K || !K[0])
    return new C(!J.s || q && !q[0] && !K || K && !K[0] && !q ? NaN : !q || !K ? J.s / 0 : J.s * 0);
  if (H = IJ(U.e / X0) + IJ(J.e / X0), j = q.length, V = K.length, j < V)
    Z = q, q = K, K = Z, Y = j, j = V, V = Y;
  Z = [], Y = j + V;
  for (Q = Y;Q--; )
    Z.push(0);
  for (Q = V;--Q >= 0; ) {
    $ = 0;
    for (W = j + Q;W > Q; )
      z = Z[W] + K[Q] * q[W - Q - 1] + $, Z[W--] = z % F$ | 0, $ = z / F$ | 0;
    Z[W] = (Z[W] + $) % F$ | 0;
  }
  for (;!Z[--Y]; )
    Z.pop();
  if ($)
    ++H;
  else
    Z.shift();
  return J.d = Z, J.e = W8(Z, H), C0 ? V0(J, C.precision, C.rounding) : J;
};
s2.toBinary = function(J, $) {
  return s6(this, 2, J, $);
};
s2.toDecimalPlaces = s2.toDP = function(J, $) {
  var H = this, Q = H.constructor;
  if (H = new Q(H), J === undefined)
    return H;
  if (eJ(J, 0, s$), $ === undefined)
    $ = Q.rounding;
  else
    eJ($, 0, 8);
  return V0(H, J + H.e + 1, $);
};
s2.toExponential = function(J, $) {
  var H, Q = this, W = Q.constructor;
  if (J === undefined)
    H = M$(Q, true);
  else {
    if (eJ(J, 0, s$), $ === undefined)
      $ = W.rounding;
    else
      eJ($, 0, 8);
    Q = V0(new W(Q), J + 1, $), H = M$(Q, true, J + 1);
  }
  return Q.isNeg() && !Q.isZero() ? "-" + H : H;
};
s2.toFixed = function(J, $) {
  var H, Q, W = this, Z = W.constructor;
  if (J === undefined)
    H = M$(W);
  else {
    if (eJ(J, 0, s$), $ === undefined)
      $ = Z.rounding;
    else
      eJ($, 0, 8);
    Q = V0(new Z(W), J + W.e + 1, $), H = M$(Q, false, J + Q.e + 1);
  }
  return W.isNeg() && !W.isZero() ? "-" + H : H;
};
s2.toFraction = function(J) {
  var $, H, Q, W, Z, Y, z, j, V, U, C, q, K = this, w2 = K.d, O = K.constructor;
  if (!w2)
    return new O(K);
  if (V = H = new O(1), Q = j = new O(0), $ = new O(Q), Z = $.e = ZY(w2) - K.e - 1, Y = Z % X0, $.d[0] = bJ(10, Y < 0 ? X0 + Y : Y), J == null)
    J = Z > 0 ? $ : V;
  else {
    if (z = new O(J), !z.isInt() || z.lt(V))
      throw Error(c$ + z);
    J = z.gt($) ? Z > 0 ? $ : V : z;
  }
  C0 = false, z = new O(xJ(w2)), U = O.precision, O.precision = Z = w2.length * X0 * 2;
  for (;; ) {
    if (C = I0(z, $, 0, 1, 1), W = H.plus(C.times(Q)), W.cmp(J) == 1)
      break;
    H = Q, Q = W, W = V, V = j.plus(C.times(W)), j = W, W = $, $ = z.minus(C.times(W)), z = W;
  }
  return W = I0(J.minus(H), Q, 0, 1, 1), j = j.plus(W.times(V)), H = H.plus(W.times(Q)), j.s = V.s = K.s, q = I0(V, Q, Z, 1).minus(K).abs().cmp(I0(j, H, Z, 1).minus(K).abs()) < 1 ? [V, Q] : [j, H], O.precision = U, C0 = true, q;
};
s2.toHexadecimal = s2.toHex = function(J, $) {
  return s6(this, 16, J, $);
};
s2.toNearest = function(J, $) {
  var H = this, Q = H.constructor;
  if (H = new Q(H), J == null) {
    if (!H.d)
      return H;
    J = new Q(1), $ = Q.rounding;
  } else {
    if (J = new Q(J), $ === undefined)
      $ = Q.rounding;
    else
      eJ($, 0, 8);
    if (!H.d)
      return J.s ? H : J;
    if (!J.d) {
      if (J.s)
        J.s = H.s;
      return J;
    }
  }
  if (J.d[0])
    C0 = false, H = I0(H, J, 0, $, 1).times(J), C0 = true, V0(H);
  else
    J.s = H.s, H = J;
  return H;
};
s2.toNumber = function() {
  return +this;
};
s2.toOctal = function(J, $) {
  return s6(this, 8, J, $);
};
s2.toPower = s2.pow = function(J) {
  var $, H, Q, W, Z, Y, z = this, j = z.constructor, V = +(J = new j(J));
  if (!z.d || !J.d || !z.d[0] || !J.d[0])
    return new j(bJ(+z, V));
  if (z = new j(z), z.eq(1))
    return z;
  if (Q = j.precision, Z = j.rounding, J.eq(1))
    return V0(z, Q, Z);
  if ($ = IJ(J.e / X0), $ >= J.d.length - 1 && (H = V < 0 ? -V : V) <= Z9)
    return W = YY(j, z, H, Q), J.s < 0 ? new j(1).div(W) : V0(W, Q, Z);
  if (Y = z.s, Y < 0) {
    if ($ < J.d.length - 1)
      return new j(NaN);
    if ((J.d[$] & 1) == 0)
      Y = 1;
    if (z.e == 0 && z.d[0] == 1 && z.d.length == 1)
      return z.s = Y, z;
  }
  if (H = bJ(+z, V), $ = H == 0 || !isFinite(H) ? IJ(V * (Math.log("0." + xJ(z.d)) / Math.LN10 + z.e + 1)) : new j(H + "").e, $ > j.maxE + 1 || $ < j.minE - 1)
    return new j($ > 0 ? Y / 0 : 0);
  if (C0 = false, j.rounding = z.s = 1, H = Math.min(12, ($ + "").length), W = u6(J.times(u$(z, Q + H)), Q), W.d) {
    if (W = V0(W, Q + 5, 1), QQ(W.d, Q, Z)) {
      if ($ = Q + 10, W = V0(u6(J.times(u$(z, $ + H)), $), $ + 5, 1), +xJ(W.d).slice(Q + 1, Q + 15) + 1 == 100000000000000)
        W = V0(W, Q + 1, 0);
    }
  }
  return W.s = Y, C0 = true, j.rounding = Z, V0(W, Q, Z);
};
s2.toPrecision = function(J, $) {
  var H, Q = this, W = Q.constructor;
  if (J === undefined)
    H = M$(Q, Q.e <= W.toExpNeg || Q.e >= W.toExpPos);
  else {
    if (eJ(J, 1, s$), $ === undefined)
      $ = W.rounding;
    else
      eJ($, 0, 8);
    Q = V0(new W(Q), J, $), H = M$(Q, J <= Q.e || Q.e <= W.toExpNeg, J);
  }
  return Q.isNeg() && !Q.isZero() ? "-" + H : H;
};
s2.toSignificantDigits = s2.toSD = function(J, $) {
  var H = this, Q = H.constructor;
  if (J === undefined)
    J = Q.precision, $ = Q.rounding;
  else if (eJ(J, 1, s$), $ === undefined)
    $ = Q.rounding;
  else
    eJ($, 0, 8);
  return V0(new Q(H), J, $);
};
s2.toString = function() {
  var J = this, $ = J.constructor, H = M$(J, J.e <= $.toExpNeg || J.e >= $.toExpPos);
  return J.isNeg() && !J.isZero() ? "-" + H : H;
};
s2.truncated = s2.trunc = function() {
  return V0(new this.constructor(this), this.e + 1, 1);
};
s2.valueOf = s2.toJSON = function() {
  var J = this, $ = J.constructor, H = M$(J, J.e <= $.toExpNeg || J.e >= $.toExpPos);
  return J.isNeg() ? "-" + H : H;
};
var I0 = function() {
  function J(Q, W, Z) {
    var Y, z = 0, j = Q.length;
    for (Q = Q.slice();j--; )
      Y = Q[j] * W + z, Q[j] = Y % Z | 0, z = Y / Z | 0;
    if (z)
      Q.unshift(z);
    return Q;
  }
  function $(Q, W, Z, Y) {
    var z, j;
    if (Z != Y)
      j = Z > Y ? 1 : -1;
    else
      for (z = j = 0;z < Z; z++)
        if (Q[z] != W[z]) {
          j = Q[z] > W[z] ? 1 : -1;
          break;
        }
    return j;
  }
  function H(Q, W, Z, Y) {
    var z = 0;
    for (;Z--; )
      Q[Z] -= z, z = Q[Z] < W[Z] ? 1 : 0, Q[Z] = z * Y + Q[Z] - W[Z];
    for (;!Q[0] && Q.length > 1; )
      Q.shift();
  }
  return function(Q, W, Z, Y, z, j) {
    var V, U, C, q, K, w2, O, h2, b, N, x, k, g, A, I, T, u, a, n, Z0, _ = Q.constructor, G = Q.s == W.s ? 1 : -1, v = Q.d, X = W.d;
    if (!v || !v[0] || !X || !X[0])
      return new _(!Q.s || !W.s || (v ? X && v[0] == X[0] : !X) ? NaN : v && v[0] == 0 || !X ? G * 0 : G / 0);
    if (j)
      K = 1, U = Q.e - W.e;
    else
      j = F$, K = X0, U = IJ(Q.e / K) - IJ(W.e / K);
    n = X.length, u = v.length, b = new _(G), N = b.d = [];
    for (C = 0;X[C] == (v[C] || 0); C++)
      ;
    if (X[C] > (v[C] || 0))
      U--;
    if (Z == null)
      A = Z = _.precision, Y = _.rounding;
    else if (z)
      A = Z + (Q.e - W.e) + 1;
    else
      A = Z;
    if (A < 0)
      N.push(1), w2 = true;
    else {
      if (A = A / K + 2 | 0, C = 0, n == 1) {
        q = 0, X = X[0], A++;
        for (;(C < u || q) && A--; C++)
          I = q * j + (v[C] || 0), N[C] = I / X | 0, q = I % X | 0;
        w2 = q || C < u;
      } else {
        if (q = j / (X[0] + 1) | 0, q > 1)
          X = J(X, q, j), v = J(v, q, j), n = X.length, u = v.length;
        T = n, x = v.slice(0, n), k = x.length;
        for (;k < n; )
          x[k++] = 0;
        if (Z0 = X.slice(), Z0.unshift(0), a = X[0], X[1] >= j / 2)
          ++a;
        do {
          if (q = 0, V = $(X, x, n, k), V < 0) {
            if (g = x[0], n != k)
              g = g * j + (x[1] || 0);
            if (q = g / a | 0, q > 1) {
              if (q >= j)
                q = j - 1;
              if (O = J(X, q, j), h2 = O.length, k = x.length, V = $(O, x, h2, k), V == 1)
                q--, H(O, n < h2 ? Z0 : X, h2, j);
            } else {
              if (q == 0)
                V = q = 1;
              O = X.slice();
            }
            if (h2 = O.length, h2 < k)
              O.unshift(0);
            if (H(x, O, k, j), V == -1) {
              if (k = x.length, V = $(X, x, n, k), V < 1)
                q++, H(x, n < k ? Z0 : X, k, j);
            }
            k = x.length;
          } else if (V === 0)
            q++, x = [0];
          if (N[C++] = q, V && x[0])
            x[k++] = v[T] || 0;
          else
            x = [v[T]], k = 1;
        } while ((T++ < u || x[0] !== undefined) && A--);
        w2 = x[0] !== undefined;
      }
      if (!N[0])
        N.shift();
    }
    if (K == 1)
      b.e = U, JY = w2;
    else {
      for (C = 1, q = N[0];q >= 10; q /= 10)
        C++;
      b.e = C + U * K - 1, V0(b, z ? Z + b.e + 1 : Z, Y, w2);
    }
    return b;
  };
}();
s2[Symbol.for("nodejs.util.inspect.custom")] = s2.toString;
s2[Symbol.toStringTag] = "Decimal";
var WQ = s2.constructor = GY(p6);
J8 = new WQ(J8);
$8 = new WQ($8);
var F0 = WQ;
var U$ = { createPool: [233, 146, 209, 142, 207, 104, 64, 188], initReward: [95, 135, 192, 196, 242, 129, 230, 68], setRewardEmissions: [112, 52, 167, 75, 32, 201, 211, 137], openPosition: [77, 184, 74, 214, 112, 86, 241, 199], closePosition: [123, 134, 81, 0, 49, 68, 98, 98], increaseLiquidity: [133, 29, 89, 223, 69, 238, 176, 10], decreaseLiquidity: [58, 127, 188, 62, 79, 82, 196, 96], swap: [43, 4, 237, 11, 26, 201, 30, 98], collectReward: [18, 237, 166, 197, 34, 16, 213, 144] };
var NY = E0(EJ(), 1);
var x$ = E0(EJ(), 1);
var A$ = new x$.default(-1);
var O$ = new x$.default(1).shln(64);
var Y8 = new x$.default(1).shln(128);
var i6 = O$.sub(k0);
var YQ = 64;
var OY = Y8.subn(1);
var AJ = -443636;
var mJ = -AJ;
var L$ = new x$.default("4295048016");
var K$ = new x$.default("79226673521066979257578248091");
var LY = 16;
var KY = "59543866431248";
var hY = "184467440737095516";
var EY = "15793534762490258745";
var z8 = new x$.default(10).pow(new x$.default(6));
var ZQ;
(function(J) {
  J[J.rate_500 = 500] = "rate_500", J[J.rate_3000 = 3000] = "rate_3000", J[J.rate_10000 = 1e4] = "rate_10000";
})(ZQ || (ZQ = {}));
var tX = { [ZQ.rate_500]: 10, [ZQ.rate_3000]: 60, [ZQ.rate_10000]: 200 };
var j8 = new x$.default("18446744073700000000");
var WU = Buffer.from("amm_config", "utf8");
var r9 = Buffer.from("pool", "utf8");
var n9 = Buffer.from("pool_vault", "utf8");
var e9 = Buffer.from("pool_reward_vault", "utf8");
var bY = Buffer.from("position", "utf8");
var t9 = Buffer.from("tick_array", "utf8");
var o9 = Buffer.from("operation", "utf8");
var Jj = Buffer.from("pool_tick_array_bitmap_extension", "utf8");
var $j = 15;

class P0 {
  static async getTickArrays(J, $, H, Q, W, Z, Y) {
    const z = [], j = v0.getTickArrayStartIndexByTick(Q, W), V = v0.getInitializedTickArrayInRange(Z, Y, W, j, Math.floor($j / 2));
    for (let q = 0;q < V.length; q++) {
      const { publicKey: K } = m0($, H, V[q]);
      z.push(K);
    }
    const U = (await J$(J, z)).map((q) => q !== null ? jQ.decode(q.data) : null), C = {};
    for (let q = 0;q < z.length; q++) {
      const K = U[q];
      if (K === null)
        continue;
      C[K.startTickIndex] = { ...K, address: z[q] };
    }
    return C;
  }
  static nextInitializedTick(J, $, H, Q, W, Z) {
    let { initializedTick: Y, tickArrayAddress: z, tickArrayStartTickIndex: j } = this.nextInitializedTickInOneArray(J, $, H, Q, W, Z);
    while (Y == null || Y.liquidityGross.lten(0)) {
      if (j = v0.getNextTickArrayStartIndex(j, W, Z), this.checkIsValidStartIndex(j, W))
        throw new Error("No enough initialized tickArray");
      const V = H[j];
      if (V === undefined)
        continue;
      const { nextTick: U, tickArrayAddress: C, tickArrayStartTickIndex: q } = this.firstInitializedTickInOneArray(J, $, V, Z);
      [Y, z, j] = [U, C, q];
    }
    if (Y == null)
      throw new Error("No invaild tickArray cache");
    return { nextTick: Y, tickArrayAddress: z, tickArrayStartTickIndex: j };
  }
  static nextInitializedTickArray(J, $, H, Q, W) {
    const Z = Math.floor(J / P0.tickCount($)), Y = H ? v0.searchLowBitFromStart(Q, W, Z - 1, 1, $) : v0.searchHightBitFromStart(Q, W, Z + 1, 1, $);
    return Y.length > 0 ? { isExist: true, nextStartIndex: Y[0] } : { isExist: false, nextStartIndex: 0 };
  }
  static firstInitializedTickInOneArray(J, $, H, Q) {
    let W = undefined;
    if (Q) {
      let Y = _J - 1;
      while (Y >= 0) {
        const z = H.ticks[Y];
        if (z.liquidityGross.gtn(0)) {
          W = z;
          break;
        }
        Y = Y - 1;
      }
    } else {
      let Y = 0;
      while (Y < _J) {
        const z = H.ticks[Y];
        if (z.liquidityGross.gtn(0)) {
          W = z;
          break;
        }
        Y = Y + 1;
      }
    }
    const { publicKey: Z } = m0(J, $, H.startTickIndex);
    return { nextTick: W, tickArrayAddress: Z, tickArrayStartTickIndex: H.startTickIndex };
  }
  static nextInitializedTickInOneArray(J, $, H, Q, W, Z) {
    const Y = v0.getTickArrayStartIndexByTick(Q, W);
    let z = Math.floor((Q - Y) / W);
    const j = H[Y];
    if (j == null)
      return { initializedTick: undefined, tickArrayAddress: undefined, tickArrayStartTickIndex: Y };
    let V = undefined;
    if (Z)
      while (z >= 0) {
        const C = j.ticks[z];
        if (C.liquidityGross.gtn(0)) {
          V = C;
          break;
        }
        z = z - 1;
      }
    else {
      z = z + 1;
      while (z < _J) {
        const C = j.ticks[z];
        if (C.liquidityGross.gtn(0)) {
          V = C;
          break;
        }
        z = z + 1;
      }
    }
    const { publicKey: U } = m0(J, $, Y);
    return { initializedTick: V, tickArrayAddress: U, tickArrayStartTickIndex: j.startTickIndex };
  }
  static getArrayStartIndex(J, $) {
    const H = this.tickCount($);
    return Math.floor(J / H) * H;
  }
  static checkIsValidStartIndex(J, $) {
    if (v0.checkIsOutOfBoundary(J)) {
      if (J > mJ)
        return false;
      const H = v0.getTickArrayStartIndexByTick(AJ, $);
      return J == H;
    }
    return J % this.tickCount($) == 0;
  }
  static tickCount(J) {
    return _J * J;
  }
}
var _J = 60;
var qH = 512;

class v0 {
  static getTickArrayAddressByTick(J, $, H, Q) {
    const W = v0.getTickArrayStartIndexByTick(H, Q), { publicKey: Z } = m0(J, $, W);
    return Z;
  }
  static getTickOffsetInArray(J, $) {
    if (J % $ != 0)
      throw new Error("tickIndex % tickSpacing not equal 0");
    const H = v0.getTickArrayStartIndexByTick(J, $), Q = Math.floor((J - H) / $);
    if (Q < 0 || Q >= _J)
      throw new Error("tick offset in array overflow");
    return Q;
  }
  static getTickArrayBitIndex(J, $) {
    const H = P0.tickCount($);
    let Q = J / H;
    if (J < 0 && J % H != 0)
      Q = Math.ceil(Q) - 1;
    else
      Q = Math.floor(Q);
    return Q;
  }
  static getTickArrayStartIndexByTick(J, $) {
    return this.getTickArrayBitIndex(J, $) * P0.tickCount($);
  }
  static getTickArrayOffsetInBitmapByTick(J, $) {
    const H = $ * _J, Q = Math.floor(J / H) + 512;
    return Math.abs(Q);
  }
  static checkTickArrayIsInitialized(J, $, H) {
    const Q = H * _J, W = Math.floor($ / Q) + 512, Z = Math.abs(W);
    return { isInitialized: J.testn(Z), startIndex: (Z - 512) * Q };
  }
  static getNextTickArrayStartIndex(J, $, H) {
    return H ? J - $ * _J : J + $ * _J;
  }
  static mergeTickArrayBitmap(J) {
    let $ = new NY.default(0);
    for (let H = 0;H < J.length; H++)
      $ = $.add(J[H].shln(64 * H));
    return $;
  }
  static getInitializedTickArrayInRange(J, $, H, Q, W) {
    const Z = Math.floor(Q / (H * _J));
    return [...v0.searchLowBitFromStart(J, $, Z - 1, W, H), ...v0.searchHightBitFromStart(J, $, Z, W, H)];
  }
  static getAllInitializedTickArrayStartIndex(J, $, H) {
    return v0.searchHightBitFromStart(J, $, 0, qH, H);
  }
  static getAllInitializedTickArrayInfo(J, $, H, Q, W) {
    const Z = [], Y = v0.getAllInitializedTickArrayStartIndex(H, Q, W);
    for (let z of Y) {
      const { publicKey: j } = m0(J, $, z);
      Z.push({ tickArrayStartIndex: z, tickArrayAddress: j });
    }
    return Z;
  }
  static getAllInitializedTickInTickArray(J) {
    return J.ticks.filter(($) => $.liquidityGross.gtn(0));
  }
  static searchLowBitFromStart(J, $, H, Q, W) {
    const Z = [...[...$.negativeTickArrayBitmap].reverse(), J.slice(0, 8), J.slice(8, 16), ...$.positiveTickArrayBitmap].map((j) => v0.mergeTickArrayBitmap(j)), Y = [];
    while (H >= -7680) {
      const j = Math.floor((H + 7680) / 512), V = (H + 7680) % 512;
      if (Z[j].testn(V))
        Y.push(H);
      if (H--, Y.length === Q)
        break;
    }
    const z = P0.tickCount(W);
    return Y.map((j) => j * z);
  }
  static searchHightBitFromStart(J, $, H, Q, W) {
    const Z = [...[...$.negativeTickArrayBitmap].reverse(), J.slice(0, 8), J.slice(8, 16), ...$.positiveTickArrayBitmap].map((j) => v0.mergeTickArrayBitmap(j)), Y = [];
    while (H < 7680) {
      const j = Math.floor((H + 7680) / 512), V = (H + 7680) % 512;
      if (Z[j].testn(V))
        Y.push(H);
      if (H++, Y.length === Q)
        break;
    }
    const z = P0.tickCount(W);
    return Y.map((j) => j * z);
  }
  static checkIsOutOfBoundary(J) {
    return J < AJ || J > mJ;
  }
  static nextInitTick(J, $, H, Q) {
    if (P0.getArrayStartIndex($, H) != J.startTickIndex)
      return null;
    let Z = Math.floor(($ - J.startTickIndex) / H);
    if (Q)
      while (Z >= 0) {
        if (J.ticks[Z].liquidityGross.gtn(0))
          return J.ticks[Z];
        Z = Z - 1;
      }
    else {
      Z = Z + 1;
      while (Z < _J) {
        if (J.ticks[Z].liquidityGross.gtn(0))
          return J.ticks[Z];
        Z = Z + 1;
      }
    }
    return null;
  }
  static firstInitializedTick(J, $) {
    if ($) {
      let H = _J - 1;
      while (H >= 0) {
        if (J.ticks[H].liquidityGross.gtn(0))
          return J.ticks[H];
        H = H - 1;
      }
    } else {
      let H = 0;
      while (H < _J) {
        if (J.ticks[H].liquidityGross.gtn(0))
          return J.ticks[H];
        H = H + 1;
      }
    }
    throw Error(`firstInitializedTick check error: ${J} - ${$}`);
  }
}
var fH = 14;

class i$ {
  static maxTickInTickarrayBitmap(J) {
    return J * _J * qH;
  }
  static getBitmapTickBoundary(J, $) {
    const H = this.maxTickInTickarrayBitmap($);
    let Q = Math.floor(Math.abs(J) / H);
    if (J < 0 && Math.abs(J) % H != 0)
      Q += 1;
    const W = H * Q;
    return J < 0 ? { minValue: -W, maxValue: -W + H } : { minValue: W, maxValue: W + H };
  }
  static nextInitializedTickArrayStartIndex(J, $, H, Q) {
    if (!P0.checkIsValidStartIndex($, H))
      throw Error("nextInitializedTickArrayStartIndex check error");
    const W = this.maxTickInTickarrayBitmap(H), Z = Q ? $ - P0.tickCount(H) : $ + P0.tickCount(H);
    if (Z < -W || Z >= W)
      return { isInit: false, tickIndex: $ };
    const Y = H * _J;
    let z = Z / Y + 512;
    if (Z < 0 && Z % Y != 0)
      z--;
    const j = Math.abs(z);
    if (Q) {
      const V = J.shln(1024 - j - 1), U = SY(1024, V);
      if (U !== null)
        return { isInit: true, tickIndex: (j - U - 512) * Y };
      else
        return { isInit: false, tickIndex: -W };
    } else {
      const V = J.shrn(j), U = wY(1024, V);
      if (U !== null)
        return { isInit: true, tickIndex: (j + U - 512) * Y };
      else
        return { isInit: false, tickIndex: W - P0.tickCount(H) };
    }
  }
}

class F8 {
  static getBitmapOffset(J, $) {
    if (!P0.checkIsValidStartIndex(J, $))
      throw new Error("No enough initialized tickArray");
    this.checkExtensionBoundary(J, $);
    const H = i$.maxTickInTickarrayBitmap($);
    let Q = Math.floor(Math.abs(J) / H) - 1;
    if (J < 0 && Math.abs(J) % H === 0)
      Q--;
    return Q;
  }
  static getBitmap(J, $, H) {
    const Q = this.getBitmapOffset(J, $);
    if (J < 0)
      return { offset: Q, tickarrayBitmap: H.negativeTickArrayBitmap[Q] };
    else
      return { offset: Q, tickarrayBitmap: H.positiveTickArrayBitmap[Q] };
  }
  static checkExtensionBoundary(J, $) {
    const { positiveTickBoundary: H, negativeTickBoundary: Q } = this.extensionTickBoundary($);
    if (J >= Q && J < H)
      throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary");
  }
  static extensionTickBoundary(J) {
    const $ = i$.maxTickInTickarrayBitmap(J), H = -$;
    if (mJ <= $)
      throw Error(`extensionTickBoundary check error: ${mJ}, ${$}`);
    if (H <= AJ)
      throw Error(`extensionTickBoundary check error: ${H}, ${AJ}`);
    return { positiveTickBoundary: $, negativeTickBoundary: H };
  }
  static checkTickArrayIsInit(J, $, H) {
    const { tickarrayBitmap: Q } = this.getBitmap(J, $, H), W = this.tickArrayOffsetInBitmap(J, $);
    return { isInitialized: v0.mergeTickArrayBitmap(Q).testn(W), startIndex: J };
  }
  static nextInitializedTickArrayFromOneBitmap(J, $, H, Q) {
    const W = P0.tickCount($), Z = H ? J - W : J + W, Y = P0.getArrayStartIndex(AJ, $), z = P0.getArrayStartIndex(mJ, $);
    if (Z < Y || Z > z)
      return { isInit: false, tickIndex: Z };
    const { tickarrayBitmap: j } = this.getBitmap(Z, $, Q);
    return this.nextInitializedTickArrayInBitmap(j, Z, $, H);
  }
  static nextInitializedTickArrayInBitmap(J, $, H, Q) {
    const { minValue: W, maxValue: Z } = i$.getBitmapTickBoundary($, H), Y = this.tickArrayOffsetInBitmap($, H);
    if (Q) {
      const z = v0.mergeTickArrayBitmap(J).shln(qH - 1 - Y), j = zQ(512, z) ? null : r6(512, z);
      if (j !== null)
        return { isInit: true, tickIndex: $ - j * P0.tickCount(H) };
      else
        return { isInit: false, tickIndex: W };
    } else {
      const z = v0.mergeTickArrayBitmap(J).shrn(Y), j = zQ(512, z) ? null : n6(512, z);
      if (j !== null)
        return { isInit: true, tickIndex: $ + j * P0.tickCount(H) };
      else
        return { isInit: false, tickIndex: Z - P0.tickCount(H) };
    }
  }
  static tickArrayOffsetInBitmap(J, $) {
    const H = Math.abs(J) % i$.maxTickInTickarrayBitmap($);
    let Q = Math.floor(H / P0.tickCount($));
    if (J < 0 && H != 0)
      Q = qH - Q;
    return Q;
  }
}
var hU = e([p0(8), o("bump"), UH("index"), c(""), yJ("protocolFeeRate"), yJ("tradeFeeRate"), UH("tickSpacing"), yJ("fundFeeRate"), z0(yJ(), 1, "padding"), c("fundOwner"), z0(P(), 3, "padding")]);
var Hj = e([yJ("blockTimestamp"), G0("sqrtPriceX64"), G0("cumulativeTimePriceX64"), z0(G0(), 1, "")]);
var o6 = e([p0(8), cJ("initialized"), c("poolId"), z0(Hj, 1000, "observations"), z0(G0(), 5, "")]);
var Qj = e([o("rewardState"), P("openTime"), P("endTime"), P("lastUpdateTime"), G0("emissionsPerSecondX64"), P("rewardTotalEmissioned"), P("rewardClaimed"), c("tokenMint"), c("tokenVault"), c("creator"), G0("rewardGrowthGlobalX64")]);
var gY = e([p0(8), o("bump"), c("ammConfig"), c("creator"), c("mintA"), c("mintB"), c("vaultA"), c("vaultB"), c("observationId"), o("mintDecimalsA"), o("mintDecimalsB"), UH("tickSpacing"), G0("liquidity"), G0("sqrtPriceX64"), kJ("tickCurrent"), UH("observationIndex"), UH("observationUpdateDuration"), G0("feeGrowthGlobalX64A"), G0("feeGrowthGlobalX64B"), P("protocolFeesTokenA"), P("protocolFeesTokenB"), G0("swapInAmountTokenA"), G0("swapOutAmountTokenB"), G0("swapInAmountTokenB"), G0("swapOutAmountTokenA"), o("status"), z0(o(), 7, ""), z0(Qj, 3, "rewardInfos"), z0(P(), 16, "tickArrayBitmap"), P("totalFeesTokenA"), P("totalFeesClaimedTokenA"), P("totalFeesTokenB"), P("totalFeesClaimedTokenB"), P("fundFeesTokenA"), P("fundFeesTokenB"), P("startTime"), z0(P(), 57, "padding")]);
var Wj = e([G0("growthInsideLastX64"), P("rewardAmountOwed")]);
var kY = e([p0(8), o("bump"), c("nftMint"), c("poolId"), kJ("tickLower"), kJ("tickUpper"), G0("liquidity"), G0("feeGrowthInsideLastX64A"), G0("feeGrowthInsideLastX64B"), P("tokenFeesOwedA"), P("tokenFeesOwedB"), z0(Wj, 3, "rewardInfos"), z0(P(), 8, "")]);
var EU = e([p0(8), o("bump"), c("poolId"), kJ("tickLowerIndex"), kJ("tickUpperIndex"), G0("liquidity"), G0("feeGrowthInsideLastX64A"), G0("feeGrowthInsideLastX64B"), P("tokenFeesOwedA"), P("tokenFeesOwedB"), z0(G0(), 3, "rewardGrowthInside"), z0(P(), 8, "")]);
var Zj = e([kJ("tick"), AZ("liquidityNet"), G0("liquidityGross"), G0("feeGrowthOutsideX64A"), G0("feeGrowthOutsideX64B"), z0(G0(), 3, "rewardGrowthsOutsideX64"), z0(yJ(), 13, "")]);
var jQ = e([p0(8), c("poolId"), kJ("startTickIndex"), z0(Zj, _J, "ticks"), o("initializedTickCount"), z0(o(), 115, "")]);
var xY = e([p0(329), z0(c(), 100, "whitelistMints")]);
var AY = e([p0(8), c("poolId"), z0(z0(P(), 8), fH, "positiveTickArrayBitmap"), z0(z0(P(), 8), fH, "negativeTickArrayBitmap")]);
var B0 = E0(EJ(), 1);
var fY = E0(EJ(), 1);

class Q$ {
  static getOutputAmountAndRemainAccounts(J, $, H, Q, W, Z = false) {
    const Y = H.equals(J.mintA.mint), z = [], { isExist: j, startIndex: V, nextAccountMeta: U } = this.getFirstInitializedTickArray(J, Y);
    if (!j || V === undefined || !U)
      throw new Error("Invalid tick array");
    try {
      const b = this.preInitializedTickArrayStartIndex(J, Y);
      if (b.isExist) {
        const { publicKey: N } = m0(J.programId, J.id, b.nextStartIndex);
        z.push(N);
      }
    } catch (b) {
    }
    z.push(U);
    const { allTrade: C, amountSpecifiedRemaining: q, amountCalculated: K, accounts: w2, sqrtPriceX64: O, feeAmount: h2 } = VQ.swapCompute(J.programId, J.id, $, J.tickArrayBitmap, J.exBitmapInfo, Y, J.ammConfig.tradeFeeRate, J.liquidity, J.tickCurrent, J.tickSpacing, J.sqrtPriceX64, Q, V, W, Z);
    return z.push(...w2), { allTrade: C, realTradeAmountIn: Q.sub(q), expectedAmountOut: K.mul(A$), remainingAccounts: z, executionPrice: O, feeAmount: h2 };
  }
  static getInputAmountAndRemainAccounts(J, $, H, Q, W) {
    const Z = H.equals(J.mintB.mint), Y = [], { isExist: z, startIndex: j, nextAccountMeta: V } = this.getFirstInitializedTickArray(J, Z);
    if (!z || j === undefined || !V)
      throw new Error("Invalid tick array");
    try {
      const w2 = this.preInitializedTickArrayStartIndex(J, Z);
      if (w2.isExist) {
        const { publicKey: O } = m0(J.programId, J.id, w2.nextStartIndex);
        Y.push(O);
      }
    } catch (w2) {
    }
    Y.push(V);
    const { amountCalculated: U, accounts: C, sqrtPriceX64: q, feeAmount: K } = VQ.swapCompute(J.programId, J.id, $, J.tickArrayBitmap, J.exBitmapInfo, Z, J.ammConfig.tradeFeeRate, J.liquidity, J.tickCurrent, J.tickSpacing, J.sqrtPriceX64, Q.mul(A$), j, W);
    return Y.push(...C), { expectedAmountIn: U, remainingAccounts: Y, executionPrice: q, feeAmount: K };
  }
  static getFirstInitializedTickArray(J, $) {
    const { isInitialized: H, startIndex: Q } = Q$.isOverflowDefaultTickarrayBitmap(J.tickSpacing, [J.tickCurrent]) ? F8.checkTickArrayIsInit(P0.getArrayStartIndex(J.tickCurrent, J.tickSpacing), J.tickSpacing, J.exBitmapInfo) : v0.checkTickArrayIsInitialized(v0.mergeTickArrayBitmap(J.tickArrayBitmap), J.tickCurrent, J.tickSpacing);
    if (H) {
      const { publicKey: Y } = m0(J.programId, J.id, Q);
      return { isExist: true, startIndex: Q, nextAccountMeta: Y };
    }
    const { isExist: W, nextStartIndex: Z } = this.nextInitializedTickArrayStartIndex(J, P0.getArrayStartIndex(J.tickCurrent, J.tickSpacing), $);
    if (W) {
      const { publicKey: Y } = m0(J.programId, J.id, Z);
      return { isExist: true, startIndex: Z, nextAccountMeta: Y };
    }
    return { isExist: false, nextAccountMeta: undefined, startIndex: undefined };
  }
  static preInitializedTickArrayStartIndex(J, $) {
    const H = Math.floor(J.tickCurrent / P0.tickCount(J.tickSpacing)), Q = !$ ? v0.searchLowBitFromStart(J.tickArrayBitmap, J.exBitmapInfo, H - 1, 1, J.tickSpacing) : v0.searchHightBitFromStart(J.tickArrayBitmap, J.exBitmapInfo, H + 1, 1, J.tickSpacing);
    return Q.length > 0 ? { isExist: true, nextStartIndex: Q[0] } : { isExist: false, nextStartIndex: 0 };
  }
  static nextInitializedTickArrayStartIndex(J, $, H) {
    $ = P0.getArrayStartIndex($, J.tickSpacing);
    while (true) {
      const { isInit: Q, tickIndex: W } = i$.nextInitializedTickArrayStartIndex(v0.mergeTickArrayBitmap(J.tickArrayBitmap), $, J.tickSpacing, H);
      if (Q)
        return { isExist: true, nextStartIndex: W };
      $ = W;
      const { isInit: Z, tickIndex: Y } = F8.nextInitializedTickArrayFromOneBitmap($, J.tickSpacing, H, J.exBitmapInfo);
      if (Z)
        return { isExist: true, nextStartIndex: Y };
      if ($ = Y, $ < AJ || $ > mJ)
        return { isExist: false, nextStartIndex: 0 };
    }
  }
  static async updatePoolRewardInfos({ connection: J, apiPoolInfo: $, chainTime: H, poolLiquidity: Q, rewardInfos: W }) {
    const Z = [];
    for (let Y = 0;Y < W.length; Y++) {
      const z = W[Y], j = $.rewardInfos[Y]?.programId ?? (await J.getAccountInfo(z.tokenMint))?.owner;
      if (j === undefined)
        throw Error("get new reward mint info error");
      const V = { ...z, perSecond: K0.x64ToDecimal(z.emissionsPerSecondX64), remainingRewards: undefined, tokenProgramId: new $PublicKey(j) };
      if (V.tokenMint.equals($PublicKey.default))
        continue;
      if (H <= V.openTime.toNumber() || Q.eq(J0)) {
        Z.push(V);
        continue;
      }
      const U = new fY.default(Math.min(V.endTime.toNumber(), H)), C = U.sub(V.lastUpdateTime), q = K0.mulDivFloor(C, V.emissionsPerSecondX64, Q), K = V.rewardGrowthGlobalX64.add(q), w2 = K0.mulDivFloor(C, V.emissionsPerSecondX64, O$), O = V.rewardTotalEmissioned.add(w2);
      Z.push({ ...V, rewardGrowthGlobalX64: K, rewardTotalEmissioned: O, lastUpdateTime: U });
    }
    return Z;
  }
  static isOverflowDefaultTickarrayBitmap(J, $) {
    const { maxTickBoundary: H, minTickBoundary: Q } = this.tickRange(J);
    for (let W of $) {
      const Z = v0.getTickArrayStartIndexByTick(W, J);
      if (Z >= H || Z < Q)
        return true;
    }
    return false;
  }
  static tickRange(J) {
    let $ = i$.maxTickInTickarrayBitmap(J), H = -$;
    if ($ > mJ)
      $ = mJ;
    if (H < AJ)
      H = AJ;
    return { maxTickBoundary: $, minTickBoundary: H };
  }
  static get_tick_array_offset(J, $) {
    if (!P0.checkIsValidStartIndex(J, $))
      throw new Error("No enough initialized tickArray");
    return J / P0.tickCount($) * qH;
  }
}
var gJ = function(J, $) {
  return JW(J.mul($), 64, 256);
};
var Yj = function(J, $, H) {
  const Q = J.toTwos(H).shln($);
  return Q.imaskn(H + 1), Q.fromTwos(H);
};
var JW = function(J, $, H) {
  const Q = J.toTwos(H).shrn($);
  return Q.imaskn(H - $ + 1), Q.fromTwos(H - $);
};

class K0 {
  static mulDivRoundingUp(J, $, H) {
    const Q = J.mul($);
    let W = Q.div(H);
    if (!Q.mod(H).eq(J0))
      W = W.add(k0);
    return W;
  }
  static mulDivFloor(J, $, H) {
    if (H.eq(J0))
      throw new Error("division by 0");
    return J.mul($).div(H);
  }
  static mulDivCeil(J, $, H) {
    if (H.eq(J0))
      throw new Error("division by 0");
    return J.mul($).add(H.sub(k0)).div(H);
  }
  static x64ToDecimal(J, $) {
    return new F0(J.toString()).div(F0.pow(2, 64)).toDecimalPlaces($);
  }
  static decimalToX64(J) {
    return new B0.default(J.mul(F0.pow(2, 64)).floor().toFixed());
  }
  static wrappingSubU128(J, $) {
    return J.add(Y8).sub($).mod(Y8);
  }
}

class S0 {
  static sqrtPriceX64ToPrice(J, $, H) {
    return K0.x64ToDecimal(J).pow(2).mul(F0.pow(10, $ - H));
  }
  static priceToSqrtPriceX64(J, $, H) {
    return K0.decimalToX64(J.mul(F0.pow(10, H - $)).sqrt());
  }
  static getNextSqrtPriceX64FromInput(J, $, H, Q) {
    if (!J.gt(J0))
      throw new Error("sqrtPriceX64 must greater than 0");
    if (!$.gt(J0))
      throw new Error("liquidity must greater than 0");
    return Q ? this.getNextSqrtPriceFromTokenAmountARoundingUp(J, $, H, true) : this.getNextSqrtPriceFromTokenAmountBRoundingDown(J, $, H, true);
  }
  static getNextSqrtPriceX64FromOutput(J, $, H, Q) {
    if (!J.gt(J0))
      throw new Error("sqrtPriceX64 must greater than 0");
    if (!$.gt(J0))
      throw new Error("liquidity must greater than 0");
    return Q ? this.getNextSqrtPriceFromTokenAmountBRoundingDown(J, $, H, false) : this.getNextSqrtPriceFromTokenAmountARoundingUp(J, $, H, false);
  }
  static getNextSqrtPriceFromTokenAmountARoundingUp(J, $, H, Q) {
    if (H.eq(J0))
      return J;
    const W = $.shln(YQ);
    if (Q) {
      const Z = W, Y = W.add(H.mul(J));
      if (Y.gte(Z))
        return K0.mulDivCeil(Z, J, Y);
      return K0.mulDivRoundingUp(Z, k0, Z.div(J).add(H));
    } else {
      const Z = H.mul(J);
      if (!W.gt(Z))
        throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");
      const Y = W.sub(Z);
      return K0.mulDivCeil(W, J, Y);
    }
  }
  static getNextSqrtPriceFromTokenAmountBRoundingDown(J, $, H, Q) {
    const W = H.shln(YQ);
    if (Q)
      return J.add(W.div($));
    else {
      const Z = K0.mulDivRoundingUp(W, k0, $);
      if (!J.gt(Z))
        throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");
      return J.sub(Z);
    }
  }
  static getSqrtPriceX64FromTick(J) {
    if (!Number.isInteger(J))
      throw new Error("tick must be integer");
    if (J < AJ || J > mJ)
      throw new Error("tick must be in MIN_TICK and MAX_TICK");
    const $ = J < 0 ? J * -1 : J;
    let H = ($ & 1) != 0 ? new B0.default("18445821805675395072") : new B0.default("18446744073709551616");
    if (($ & 2) != 0)
      H = gJ(H, new B0.default("18444899583751176192"));
    if (($ & 4) != 0)
      H = gJ(H, new B0.default("18443055278223355904"));
    if (($ & 8) != 0)
      H = gJ(H, new B0.default("18439367220385607680"));
    if (($ & 16) != 0)
      H = gJ(H, new B0.default("18431993317065453568"));
    if (($ & 32) != 0)
      H = gJ(H, new B0.default("18417254355718170624"));
    if (($ & 64) != 0)
      H = gJ(H, new B0.default("18387811781193609216"));
    if (($ & 128) != 0)
      H = gJ(H, new B0.default("18329067761203558400"));
    if (($ & 256) != 0)
      H = gJ(H, new B0.default("18212142134806163456"));
    if (($ & 512) != 0)
      H = gJ(H, new B0.default("17980523815641700352"));
    if (($ & 1024) != 0)
      H = gJ(H, new B0.default("17526086738831433728"));
    if (($ & 2048) != 0)
      H = gJ(H, new B0.default("16651378430235570176"));
    if (($ & 4096) != 0)
      H = gJ(H, new B0.default("15030750278694412288"));
    if (($ & 8192) != 0)
      H = gJ(H, new B0.default("12247334978884435968"));
    if (($ & 16384) != 0)
      H = gJ(H, new B0.default("8131365268886854656"));
    if (($ & 32768) != 0)
      H = gJ(H, new B0.default("3584323654725218816"));
    if (($ & 65536) != 0)
      H = gJ(H, new B0.default("696457651848324352"));
    if (($ & 131072) != 0)
      H = gJ(H, new B0.default("26294789957507116"));
    if (($ & 262144) != 0)
      H = gJ(H, new B0.default("37481735321082"));
    if (J > 0)
      H = OY.div(H);
    return H;
  }
  static getTickFromPrice(J, $, H) {
    return S0.getTickFromSqrtPriceX64(S0.priceToSqrtPriceX64(J, $, H));
  }
  static getTickFromSqrtPriceX64(J) {
    if (J.gt(K$) || J.lt(L$))
      throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");
    const $ = J.bitLength() - 1, H = new B0.default($ - 64), Q = Yj(H, 32, 128);
    let W = new B0.default("8000000000000000", "hex"), Z = 0, Y = new B0.default(0), z = $ >= 64 ? J.shrn($ - 63) : J.shln(63 - $);
    while (W.gt(new B0.default(0)) && Z < LY) {
      z = z.mul(z);
      const K = z.shrn(127);
      z = z.shrn(63 + K.toNumber()), Y = Y.add(W.mul(K)), W = W.shrn(1), Z += 1;
    }
    const j = Y.shrn(32), U = Q.add(j).mul(new B0.default(KY)), C = JW(U.sub(new B0.default(hY)), 64, 128).toNumber(), q = JW(U.add(new B0.default(EY)), 64, 128).toNumber();
    if (C == q)
      return C;
    else
      return S0.getSqrtPriceX64FromTick(q).lte(J) ? q : C;
  }
}

class X8 {
  static getTickWithPriceAndTickspacing(J, $, H, Q) {
    let Z = S0.getTickFromSqrtPriceX64(S0.priceToSqrtPriceX64(J, H, Q)) / $;
    if (Z < 0)
      Z = Math.floor(Z);
    else
      Z = Math.ceil(Z);
    return Z * $;
  }
  static roundPriceWithTickspacing(J, $, H, Q) {
    const W = X8.getTickWithPriceAndTickspacing(J, $, H, Q), Z = S0.getSqrtPriceX64FromTick(W);
    return S0.sqrtPriceX64ToPrice(Z, H, Q);
  }
}

class A0 {
  static addDelta(J, $) {
    return J.add($);
  }
  static getTokenAmountAFromLiquidity(J, $, H, Q) {
    if (J.gt($))
      [J, $] = [$, J];
    if (!J.gt(J0))
      throw new Error("sqrtPriceX64A must greater than 0");
    const W = H.ushln(YQ), Z = $.sub(J);
    return Q ? K0.mulDivRoundingUp(K0.mulDivCeil(W, Z, $), k0, J) : K0.mulDivFloor(W, Z, $).div(J);
  }
  static getTokenAmountBFromLiquidity(J, $, H, Q) {
    if (J.gt($))
      [J, $] = [$, J];
    if (!J.gt(J0))
      throw new Error("sqrtPriceX64A must greater than 0");
    return Q ? K0.mulDivCeil(H, $.sub(J), O$) : K0.mulDivFloor(H, $.sub(J), O$);
  }
  static getLiquidityFromTokenAmountA(J, $, H, Q) {
    if (J.gt($))
      [J, $] = [$, J];
    const W = H.mul(J).mul($), Z = $.sub(J), Y = W.div(Z);
    if (Q)
      return K0.mulDivRoundingUp(Y, k0, i6);
    else
      return Y.shrn(YQ);
  }
  static getLiquidityFromTokenAmountB(J, $, H) {
    if (J.gt($))
      [J, $] = [$, J];
    return K0.mulDivFloor(H, i6, $.sub(J));
  }
  static getLiquidityFromTokenAmounts(J, $, H, Q, W) {
    if ($.gt(H))
      [$, H] = [H, $];
    if (J.lte($))
      return A0.getLiquidityFromTokenAmountA($, H, Q, false);
    else if (J.lt(H)) {
      const Z = A0.getLiquidityFromTokenAmountA(J, H, Q, false), Y = A0.getLiquidityFromTokenAmountB($, J, W);
      return Z.lt(Y) ? Z : Y;
    } else
      return A0.getLiquidityFromTokenAmountB($, H, W);
  }
  static getAmountsFromLiquidity(J, $, H, Q, W) {
    if ($.gt(H))
      [$, H] = [H, $];
    if (J.lte($))
      return { amountA: A0.getTokenAmountAFromLiquidity($, H, Q, W), amountB: new B0.default(0) };
    else if (J.lt(H)) {
      const Z = A0.getTokenAmountAFromLiquidity(J, H, Q, W), Y = A0.getTokenAmountBFromLiquidity($, J, Q, W);
      return { amountA: Z, amountB: Y };
    } else
      return { amountA: new B0.default(0), amountB: A0.getTokenAmountBFromLiquidity($, H, Q, W) };
  }
  static getAmountsFromLiquidityWithSlippage(J, $, H, Q, W, Z, Y) {
    const { amountA: z, amountB: j } = A0.getAmountsFromLiquidity(J, $, H, Q, Z), V = W ? 1 + Y : 1 - Y, U = new B0.default(new F0(z.toString()).mul(V).toFixed(0)), C = new B0.default(new F0(j.toString()).mul(V).toFixed(0));
    return { amountSlippageA: U, amountSlippageB: C };
  }
}

class VQ {
  static swapCompute(J, $, H, Q, W, Z, Y, z, j, V, U, C, q, K, w2 = false) {
    if (C.eq(J0))
      throw new Error("amountSpecified must not be 0");
    if (!K)
      K = Z ? L$.add(k0) : K$.sub(k0);
    if (Z) {
      if (K.lt(L$))
        throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");
      if (K.gte(U))
        throw new Error("sqrtPriceX64 must smaller than current");
    } else {
      if (K.gt(K$))
        throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");
      if (K.lte(U))
        throw new Error("sqrtPriceX64 must greater than current");
    }
    const O = C.gt(J0), h2 = { amountSpecifiedRemaining: C, amountCalculated: J0, sqrtPriceX64: U, tick: j > q ? Math.min(q + P0.tickCount(V) - 1, j) : q, accounts: [], liquidity: z, feeAmount: new B0.default(0) };
    let b = q, N = H[q], x = 0;
    while (!h2.amountSpecifiedRemaining.eq(J0) && !h2.sqrtPriceX64.eq(K)) {
      if (x > 10)
        ;
      const k = {};
      k.sqrtPriceStartX64 = h2.sqrtPriceX64;
      const g = v0.nextInitTick(N, h2.tick, V, Z);
      let A = g ? g : null, I = null;
      if (!A?.liquidityGross.gtn(0)) {
        const u = Q$.nextInitializedTickArrayStartIndex({ tickCurrent: h2.tick, tickSpacing: V, tickArrayBitmap: Q, exBitmapInfo: W }, b, Z);
        if (!u.isExist) {
          if (w2)
            return { allTrade: false, amountSpecifiedRemaining: h2.amountSpecifiedRemaining, amountCalculated: h2.amountCalculated, feeAmount: h2.feeAmount, sqrtPriceX64: h2.sqrtPriceX64, liquidity: h2.liquidity, tickCurrent: h2.tick, accounts: h2.accounts };
          throw Error("swapCompute LiquidityInsufficient");
        }
        b = u.nextStartIndex;
        const { publicKey: a } = m0(J, $, b);
        I = a, N = H[b];
        try {
          A = v0.firstInitializedTick(N, Z);
        } catch (n) {
          throw Error("not found next tick info");
        }
      }
      if (k.tickNext = A.tick, k.initialized = A.liquidityGross.gtn(0), q !== b && I)
        h2.accounts.push(I), q = b;
      if (k.tickNext < AJ)
        k.tickNext = AJ;
      else if (k.tickNext > mJ)
        k.tickNext = mJ;
      k.sqrtPriceNextX64 = S0.getSqrtPriceX64FromTick(k.tickNext);
      let T;
      if (Z && k.sqrtPriceNextX64.lt(K) || !Z && k.sqrtPriceNextX64.gt(K))
        T = K;
      else
        T = k.sqrtPriceNextX64;
      if ([h2.sqrtPriceX64, k.amountIn, k.amountOut, k.feeAmount] = VQ.swapStepCompute(h2.sqrtPriceX64, T, h2.liquidity, h2.amountSpecifiedRemaining, Y), h2.feeAmount = h2.feeAmount.add(k.feeAmount), O)
        h2.amountSpecifiedRemaining = h2.amountSpecifiedRemaining.sub(k.amountIn.add(k.feeAmount)), h2.amountCalculated = h2.amountCalculated.sub(k.amountOut);
      else
        h2.amountSpecifiedRemaining = h2.amountSpecifiedRemaining.add(k.amountOut), h2.amountCalculated = h2.amountCalculated.add(k.amountIn.add(k.feeAmount));
      if (h2.sqrtPriceX64.eq(k.sqrtPriceNextX64)) {
        if (k.initialized) {
          let u = A.liquidityNet;
          if (Z)
            u = u.mul(A$);
          h2.liquidity = A0.addDelta(h2.liquidity, u);
        }
        h2.tick = Z ? k.tickNext - 1 : k.tickNext;
      } else if (h2.sqrtPriceX64 != k.sqrtPriceStartX64)
        h2.tick = S0.getTickFromSqrtPriceX64(h2.sqrtPriceX64);
      ++x;
    }
    try {
      const { nextStartIndex: k, isExist: g } = P0.nextInitializedTickArray(h2.tick, V, Z, Q, W);
      if (g && q !== k)
        h2.accounts.push(m0(J, $, k).publicKey), q = k;
    } catch (k) {
    }
    return { allTrade: true, amountSpecifiedRemaining: J0, amountCalculated: h2.amountCalculated, feeAmount: h2.feeAmount, sqrtPriceX64: h2.sqrtPriceX64, liquidity: h2.liquidity, tickCurrent: h2.tick, accounts: h2.accounts };
  }
  static swapStepCompute(J, $, H, Q, W) {
    const Z = { sqrtPriceX64Next: new B0.default(0), amountIn: new B0.default(0), amountOut: new B0.default(0), feeAmount: new B0.default(0) }, Y = J.gte($), z = Q.gte(J0);
    if (z) {
      const V = K0.mulDivFloor(Q, z8.sub(new B0.default(W.toString())), z8);
      if (Z.amountIn = Y ? A0.getTokenAmountAFromLiquidity($, J, H, true) : A0.getTokenAmountBFromLiquidity(J, $, H, true), V.gte(Z.amountIn))
        Z.sqrtPriceX64Next = $;
      else
        Z.sqrtPriceX64Next = S0.getNextSqrtPriceX64FromInput(J, H, V, Y);
    } else if (Z.amountOut = Y ? A0.getTokenAmountBFromLiquidity($, J, H, false) : A0.getTokenAmountAFromLiquidity(J, $, H, false), Q.mul(A$).gte(Z.amountOut))
      Z.sqrtPriceX64Next = $;
    else
      Z.sqrtPriceX64Next = S0.getNextSqrtPriceX64FromOutput(J, H, Q.mul(A$), Y);
    const j = $.eq(Z.sqrtPriceX64Next);
    if (Y) {
      if (!(j && z))
        Z.amountIn = A0.getTokenAmountAFromLiquidity(Z.sqrtPriceX64Next, J, H, true);
      if (!(j && !z))
        Z.amountOut = A0.getTokenAmountBFromLiquidity(Z.sqrtPriceX64Next, J, H, false);
    } else
      Z.amountIn = j && z ? Z.amountIn : A0.getTokenAmountBFromLiquidity(J, Z.sqrtPriceX64Next, H, true), Z.amountOut = j && !z ? Z.amountOut : A0.getTokenAmountAFromLiquidity(J, Z.sqrtPriceX64Next, H, false);
    if (!z && Z.amountOut.gt(Q.mul(A$)))
      Z.amountOut = Q.mul(A$);
    if (z && !Z.sqrtPriceX64Next.eq($))
      Z.feeAmount = Q.sub(Z.amountIn);
    else
      Z.feeAmount = K0.mulDivCeil(Z.amountIn, new B0.default(W), z8.sub(new B0.default(W)));
    return [Z.sqrtPriceX64Next, Z.amountIn, Z.amountOut, Z.feeAmount];
  }
}
var vH = E0(EJ(), 1);

class U8 {
  static getfeeGrowthInside(J, $, H) {
    let Q = new vH.default(0), W = new vH.default(0);
    if (J.tickCurrent >= $.tick)
      Q = $.feeGrowthOutsideX64A, W = $.feeGrowthOutsideX64B;
    else
      Q = J.feeGrowthGlobalX64A.sub($.feeGrowthOutsideX64A), W = J.feeGrowthGlobalX64B.sub($.feeGrowthOutsideX64B);
    let Z = new vH.default(0), Y = new vH.default(0);
    if (J.tickCurrent < H.tick)
      Z = H.feeGrowthOutsideX64A, Y = H.feeGrowthOutsideX64B;
    else
      Z = J.feeGrowthGlobalX64A.sub(H.feeGrowthOutsideX64A), Y = J.feeGrowthGlobalX64B.sub(H.feeGrowthOutsideX64B);
    const z = K0.wrappingSubU128(K0.wrappingSubU128(J.feeGrowthGlobalX64A, Q), Z), j = K0.wrappingSubU128(K0.wrappingSubU128(J.feeGrowthGlobalX64B, W), Y);
    return { feeGrowthInsideX64A: z, feeGrowthInsideBX64: j };
  }
  static GetPositionFees(J, $, H, Q) {
    const { feeGrowthInsideX64A: W, feeGrowthInsideBX64: Z } = this.getfeeGrowthInside(J, H, Q), Y = K0.mulDivFloor(K0.wrappingSubU128(W, $.feeGrowthInsideLastX64A), $.liquidity, O$), z = $.tokenFeesOwedA.add(Y), j = K0.mulDivFloor(K0.wrappingSubU128(Z, $.feeGrowthInsideLastX64B), $.liquidity, O$), V = $.tokenFeesOwedB.add(j);
    return { tokenFeeAmountA: z, tokenFeeAmountB: V };
  }
  static GetPositionRewards(J, $, H, Q) {
    const W = [], Z = this.getRewardGrowthInside(J.tickCurrent, H, Q, J.rewardInfos);
    for (let Y = 0;Y < Z.length; Y++) {
      const z = Z[Y], j = $.rewardInfos[Y], V = K0.wrappingSubU128(z, j.growthInsideLastX64), U = K0.mulDivFloor(V, $.liquidity, O$), C = j.rewardAmountOwed.add(U);
      W.push(C);
    }
    return W;
  }
  static getRewardGrowthInside(J, $, H, Q) {
    const W = [];
    for (let Z = 0;Z < Q.length; Z++) {
      let Y = new vH.default(0);
      if ($.liquidityGross.eqn(0))
        Y = Q[Z].rewardGrowthGlobalX64;
      else if (J < $.tick)
        Y = Q[Z].rewardGrowthGlobalX64.sub($.rewardGrowthsOutsideX64[Z]);
      else
        Y = $.rewardGrowthsOutsideX64[Z];
      let z = new vH.default(0);
      if (H.liquidityGross.eqn(0))
        ;
      else if (J < H.tick)
        z = H.rewardGrowthsOutsideX64[Z];
      else
        z = Q[Z].rewardGrowthGlobalX64.sub(H.rewardGrowthsOutsideX64[Z]);
      W.push(K0.wrappingSubU128(K0.wrappingSubU128(Q[Z].rewardGrowthGlobalX64, Y), z));
    }
    return W;
  }
}
var e0 = U0.from("Clmm");

class D8 extends V$ {
  static makeMockPoolInfo({ programId: J, mint1: $, mint2: H, ammConfig: Q, createPoolInstructionSimpleAddress: W, initialPrice: Z, startTime: Y, owner: z }) {
    const [j, V, U] = new f0.default($.mint.toBuffer()).gt(new f0.default(H.mint.toBuffer())) ? [H, $, new F0(1).div(Z)] : [$, H, Z], C = S0.priceToSqrtPriceX64(U, j.decimals, V.decimals);
    return { id: W.poolId, mintA: { programId: W.mintProgramIdA, mint: W.mintA, vault: W.mintAVault, decimals: j.decimals }, mintB: { programId: W.mintProgramIdB, mint: W.mintB, vault: W.mintBVault, decimals: V.decimals }, ammConfig: Q, observationId: W.observationId, creator: z, programId: J, version: 6, tickSpacing: Q.tickSpacing, liquidity: J0, sqrtPriceX64: C, currentPrice: U, tickCurrent: 0, observationIndex: 0, observationUpdateDuration: 0, feeGrowthGlobalX64A: J0, feeGrowthGlobalX64B: J0, protocolFeesTokenA: J0, protocolFeesTokenB: J0, swapInAmountTokenA: J0, swapOutAmountTokenB: J0, swapInAmountTokenB: J0, swapOutAmountTokenA: J0, tickArrayBitmap: [], rewardInfos: [], day: { volume: 0, volumeFee: 0, feeA: 0, feeB: 0, feeApr: 0, rewardApr: { A: 0, B: 0, C: 0 }, apr: 0, priceMax: 0, priceMin: 0 }, week: { volume: 0, volumeFee: 0, feeA: 0, feeB: 0, feeApr: 0, rewardApr: { A: 0, B: 0, C: 0 }, apr: 0, priceMax: 0, priceMin: 0 }, month: { volume: 0, volumeFee: 0, feeA: 0, feeB: 0, feeApr: 0, rewardApr: { A: 0, B: 0, C: 0 }, apr: 0, priceMax: 0, priceMin: 0 }, tvl: 0, lookupTableAccount: $PublicKey.default, startTime: Y.toNumber(), exBitmapInfo: { poolId: W.poolId, positiveTickArrayBitmap: Array.from({ length: fH }, () => Array.from({ length: 8 }, () => new f0.default(0))), negativeTickArrayBitmap: Array.from({ length: fH }, () => Array.from({ length: 8 }, () => new f0.default(0))) } };
  }
  static async makeCreatePoolInstructionSimple({ makeTxVersion: J, connection: $, programId: H, owner: Q, payer: W, mint1: Z, mint2: Y, ammConfig: z, initialPrice: j, startTime: V, computeBudgetConfig: U, lookupTableCache: C }) {
    const [q, K, w2] = new f0.default(Z.mint.toBuffer()).gt(new f0.default(Y.mint.toBuffer())) ? [Y, Z, new F0(1).div(j)] : [Z, Y, j], O = S0.priceToSqrtPriceX64(w2, q.decimals, K.decimals), h2 = await this.makeCreatePoolInstructions({ connection: $, programId: H, owner: Q, mintA: q, mintB: K, ammConfigId: z.id, initialPriceX64: O, startTime: V });
    return { address: { ...h2.address, mintA: q.mint, mintB: K.mint, mintProgramIdA: q.programId, mintProgramIdB: K.programId }, innerTransactions: await L0({ connection: $, makeTxVersion: J, computeBudgetConfig: U, payer: W, innerTransaction: [h2.innerTransaction], lookupTableCache: C }) };
  }
  static async makeOpenPositionFromLiquidityInstructionSimple({ makeTxVersion: J, connection: $, poolInfo: H, ownerInfo: Q, amountMaxA: W, amountMaxB: Z, tickLower: Y, tickUpper: z, liquidity: j, associatedOnly: V = true, checkCreateATAOwner: U = false, withMetadata: C = "create", getEphemeralSigners: q, computeBudgetConfig: K, lookupTableCache: w2 }) {
    const O = [], h2 = [], b = [], N = [], x = [], k = Q.useSOLBalance && H.mintA.mint.equals(r.WSOL.mint), g = Q.useSOLBalance && H.mintB.mint.equals(r.WSOL.mint), A = await this._selectOrCreateTokenAccount({ programId: H.mintA.programId, mint: H.mintA.mint, tokenAccounts: k ? [] : Q.tokenAccounts, owner: Q.wallet, createInfo: k || W.eq(J0) ? { connection: $, payer: Q.feePayer, amount: W, frontInstructions: O, endInstructions: h2, frontInstructionsType: b, endInstructionsType: N, signers: x } : undefined, associatedOnly: k ? false : V, checkCreateATAOwner: U }), I = await this._selectOrCreateTokenAccount({ programId: H.mintB.programId, mint: H.mintB.mint, tokenAccounts: g ? [] : Q.tokenAccounts, owner: Q.wallet, createInfo: g || Z.eq(J0) ? { connection: $, payer: Q.feePayer, amount: Z, frontInstructions: O, endInstructions: h2, frontInstructionsType: b, endInstructionsType: N, signers: x } : undefined, associatedOnly: g ? false : V, checkCreateATAOwner: U });
    e0.assertArgument(A !== undefined && I !== undefined, "cannot found target token accounts", "tokenAccounts", Q.tokenAccounts);
    const T = await this.makeOpenPositionFromLiquidityInstructions({ poolInfo: H, ownerInfo: { ...Q, tokenAccountA: A, tokenAccountB: I }, tickLower: Y, tickUpper: z, liquidity: j, amountMaxA: W, amountMaxB: Z, withMetadata: C, getEphemeralSigners: q });
    return { address: T.address, innerTransactions: await L0({ connection: $, makeTxVersion: J, computeBudgetConfig: K, payer: Q.feePayer, innerTransaction: [{ instructionTypes: b, instructions: O, signers: x }, T.innerTransaction, { instructionTypes: N, instructions: h2, signers: [] }], lookupTableCache: w2 }) };
  }
  static async makeOpenPositionFromBaseInstructionSimple({ connection: J, poolInfo: $, ownerInfo: H, tickLower: Q, tickUpper: W, base: Z, baseAmount: Y, otherAmountMax: z, associatedOnly: j = true, checkCreateATAOwner: V = false, computeBudgetConfig: U, withMetadata: C = "create", makeTxVersion: q, lookupTableCache: K, getEphemeralSigners: w2 }) {
    const O = [], h2 = [], b = [], N = [], x = [], k = H.useSOLBalance && $.mintA.mint.equals(r.WSOL.mint), g = H.useSOLBalance && $.mintB.mint.equals(r.WSOL.mint), A = await this._selectOrCreateTokenAccount({ programId: $.mintA.programId, mint: $.mintA.mint, tokenAccounts: k ? [] : H.tokenAccounts, owner: H.wallet, createInfo: k ? { connection: J, payer: H.feePayer, amount: Z === "MintA" ? Y : z, frontInstructions: O, endInstructions: h2, frontInstructionsType: b, endInstructionsType: N, signers: x } : undefined, associatedOnly: k ? false : j, checkCreateATAOwner: V }), I = await this._selectOrCreateTokenAccount({ programId: $.mintB.programId, mint: $.mintB.mint, tokenAccounts: g ? [] : H.tokenAccounts, owner: H.wallet, createInfo: g ? { connection: J, payer: H.feePayer, amount: Z === "MintA" ? z : Y, frontInstructions: O, endInstructions: h2, frontInstructionsType: b, endInstructionsType: N, signers: x } : undefined, associatedOnly: g ? false : j, checkCreateATAOwner: V });
    e0.assertArgument(A !== undefined && I !== undefined, "cannot found target token accounts", "tokenAccounts", H.tokenAccounts);
    const T = await this.makeOpenPositionFromBaseInstructions({ poolInfo: $, ownerInfo: { ...H, tokenAccountA: A, tokenAccountB: I }, tickLower: Q, tickUpper: W, base: Z, baseAmount: Y, otherAmountMax: z, withMetadata: C, getEphemeralSigners: w2 });
    return { address: T.address, innerTransactions: await L0({ connection: J, makeTxVersion: q, computeBudgetConfig: U, payer: H.feePayer, innerTransaction: [{ instructionTypes: b, instructions: O, signers: x }, T.innerTransaction, { instructionTypes: N, instructions: h2, signers: [] }], lookupTableCache: K }) };
  }
  static async makeIncreasePositionFromLiquidityInstructionSimple({ connection: J, poolInfo: $, ownerPosition: H, ownerInfo: Q, amountMaxA: W, amountMaxB: Z, liquidity: Y, associatedOnly: z = true, checkCreateATAOwner: j = false, computeBudgetConfig: V, makeTxVersion: U, lookupTableCache: C }) {
    const q = [], K = [], w2 = [], O = [], h2 = [], b = Q.useSOLBalance && $.mintA.mint.equals(r.WSOL.mint), N = Q.useSOLBalance && $.mintB.mint.equals(r.WSOL.mint), x = await this._selectOrCreateTokenAccount({ programId: $.mintA.programId, mint: $.mintA.mint, tokenAccounts: b ? [] : Q.tokenAccounts, owner: Q.wallet, createInfo: b ? { connection: J, payer: Q.feePayer, amount: W, frontInstructions: q, endInstructions: K, frontInstructionsType: w2, endInstructionsType: O, signers: h2 } : undefined, associatedOnly: b ? false : z, checkCreateATAOwner: j }), k = await this._selectOrCreateTokenAccount({ programId: $.mintB.programId, mint: $.mintB.mint, tokenAccounts: N ? [] : Q.tokenAccounts, owner: Q.wallet, createInfo: N ? { connection: J, payer: Q.feePayer, amount: Z, frontInstructions: q, endInstructions: K, frontInstructionsType: w2, endInstructionsType: O, signers: h2 } : undefined, associatedOnly: N ? false : z, checkCreateATAOwner: j });
    e0.assertArgument(!!x || !!k, "cannot found target token accounts", "tokenAccounts", Q.tokenAccounts);
    const g = this.makeIncreasePositionFromLiquidityInstructions({ poolInfo: $, ownerPosition: H, ownerInfo: { wallet: Q.wallet, tokenAccountA: x, tokenAccountB: k }, liquidity: Y, amountMaxA: W, amountMaxB: Z });
    return { address: g.address, innerTransactions: await L0({ connection: J, makeTxVersion: U, computeBudgetConfig: V, payer: Q.feePayer, innerTransaction: [{ instructionTypes: w2, instructions: q, signers: h2 }, g.innerTransaction, { instructionTypes: O, instructions: K, signers: [] }], lookupTableCache: C }) };
  }
  static async makeIncreasePositionFromBaseInstructionSimple({ connection: J, poolInfo: $, ownerPosition: H, ownerInfo: Q, base: W, baseAmount: Z, otherAmountMax: Y, associatedOnly: z = true, checkCreateATAOwner: j = false, computeBudgetConfig: V, makeTxVersion: U, lookupTableCache: C }) {
    const q = [], K = [], w2 = [], O = [], h2 = [], b = Q.useSOLBalance && $.mintA.mint.equals(r.WSOL.mint), N = Q.useSOLBalance && $.mintB.mint.equals(r.WSOL.mint), x = await this._selectOrCreateTokenAccount({ programId: $.mintA.programId, mint: $.mintA.mint, tokenAccounts: b ? [] : Q.tokenAccounts, owner: Q.wallet, createInfo: b ? { connection: J, payer: Q.feePayer, amount: W === "MintA" ? Z : Y, frontInstructions: q, endInstructions: K, frontInstructionsType: w2, endInstructionsType: O, signers: h2 } : undefined, associatedOnly: b ? false : z, checkCreateATAOwner: j }), k = await this._selectOrCreateTokenAccount({ programId: $.mintB.programId, mint: $.mintB.mint, tokenAccounts: N ? [] : Q.tokenAccounts, owner: Q.wallet, createInfo: N ? { connection: J, payer: Q.feePayer, amount: W === "MintA" ? Y : Z, frontInstructions: q, endInstructions: K, frontInstructionsType: w2, endInstructionsType: O, signers: h2 } : undefined, associatedOnly: N ? false : z, checkCreateATAOwner: j });
    e0.assertArgument(!!x || !!k, "cannot found target token accounts", "tokenAccounts", Q.tokenAccounts);
    const g = this.makeIncreasePositionFromBaseInstructions({ poolInfo: $, ownerPosition: H, ownerInfo: { wallet: Q.wallet, tokenAccountA: x, tokenAccountB: k }, base: W, baseAmount: Z, otherAmountMax: Y });
    return { address: g.address, innerTransactions: await L0({ connection: J, makeTxVersion: U, computeBudgetConfig: V, payer: Q.feePayer, innerTransaction: [{ instructionTypes: w2, instructions: q, signers: h2 }, g.innerTransaction, { instructionTypes: O, instructions: K, signers: [] }], lookupTableCache: C }) };
  }
  static async makeDecreaseLiquidityInstructionSimple({ connection: J, poolInfo: $, ownerPosition: H, ownerInfo: Q, liquidity: W, amountMinA: Z, amountMinB: Y, associatedOnly: z = true, checkCreateATAOwner: j = false, computeBudgetConfig: V, makeTxVersion: U, lookupTableCache: C }) {
    const q = [], K = [], w2 = [], O = [], h2 = [], b = Q.useSOLBalance && $.mintA.mint.equals(r.WSOL.mint), N = Q.useSOLBalance && $.mintB.mint.equals(r.WSOL.mint), x = await this._selectOrCreateTokenAccount({ programId: $.mintA.programId, mint: $.mintA.mint, tokenAccounts: b ? [] : Q.tokenAccounts, owner: Q.wallet, createInfo: { connection: J, payer: Q.feePayer, amount: 0, frontInstructions: q, frontInstructionsType: w2, endInstructions: b ? K : [], endInstructionsType: b ? O : [], signers: h2 }, associatedOnly: b ? false : z, checkCreateATAOwner: j }), k = await this._selectOrCreateTokenAccount({ programId: $.mintB.programId, mint: $.mintB.mint, tokenAccounts: N ? [] : Q.tokenAccounts, owner: Q.wallet, createInfo: { connection: J, payer: Q.feePayer, amount: 0, frontInstructions: q, frontInstructionsType: w2, endInstructions: N ? K : [], endInstructionsType: N ? O : [], signers: h2 }, associatedOnly: N ? false : z, checkCreateATAOwner: j }), g = [];
    for (let T of $.rewardInfos) {
      const u = Q.useSOLBalance && T.tokenMint.equals(r.WSOL.mint), a = T.tokenMint.equals($.mintA.mint) ? x : T.tokenMint.equals($.mintB.mint) ? k : await this._selectOrCreateTokenAccount({ programId: T.tokenProgramId, mint: T.tokenMint, tokenAccounts: u ? [] : Q.tokenAccounts, owner: Q.wallet, createInfo: { connection: J, payer: Q.feePayer, amount: 0, frontInstructions: q, frontInstructionsType: w2, endInstructions: u ? K : [], endInstructionsType: u ? O : [], signers: h2 }, associatedOnly: u ? false : z, checkCreateATAOwner: j });
      g.push(a);
    }
    e0.assertArgument(!!x || !!k, "cannot found target token accounts", "tokenAccounts", Q.tokenAccounts);
    const A = this.makeDecreaseLiquidityInstructions({ poolInfo: $, ownerPosition: H, ownerInfo: { wallet: Q.wallet, tokenAccountA: x, tokenAccountB: k, rewardAccounts: g }, liquidity: W, amountMinA: Z, amountMinB: Y }), I = Q.closePosition ? this.makeClosePositionInstructions({ poolInfo: $, ownerInfo: Q, ownerPosition: H }) : { address: {}, innerTransaction: { instructions: [], signers: [], instructionTypes: [] } };
    return { address: A.address, innerTransactions: await L0({ connection: J, makeTxVersion: U, computeBudgetConfig: V, payer: Q.feePayer, innerTransaction: [{ instructionTypes: w2, instructions: q, signers: h2 }, A.innerTransaction, { instructionTypes: O, instructions: K, signers: [] }, I.innerTransaction], lookupTableCache: C }) };
  }
  static async makeSwapBaseInInstructionSimple({ connection: J, poolInfo: $, ownerInfo: H, inputMint: Q, amountIn: W, amountOutMin: Z, priceLimit: Y, remainingAccounts: z, associatedOnly: j = true, checkCreateATAOwner: V = false, computeBudgetConfig: U, makeTxVersion: C, lookupTableCache: q }) {
    const K = [], w2 = [], O = [], h2 = [], b = [];
    let N;
    if (!Y || Y.equals(new F0(0)))
      N = Q.equals($.mintA.mint) ? L$.add(k0) : K$.sub(k0);
    else
      N = S0.priceToSqrtPriceX64(Y, $.mintA.decimals, $.mintB.decimals);
    const x = $.mintA.mint.equals(Q), k = H.useSOLBalance && $.mintA.mint.equals(r.WSOL.mint), g = H.useSOLBalance && $.mintB.mint.equals(r.WSOL.mint), A = await this._selectOrCreateTokenAccount({ programId: $.mintA.programId, mint: $.mintA.mint, tokenAccounts: k ? [] : H.tokenAccounts, owner: H.wallet, createInfo: k || !x ? { connection: J, payer: H.feePayer, amount: x ? W : 0, frontInstructions: K, endInstructions: w2, frontInstructionsType: O, endInstructionsType: h2, signers: b } : undefined, associatedOnly: k ? false : j, checkCreateATAOwner: V }), I = await this._selectOrCreateTokenAccount({ programId: $.mintB.programId, mint: $.mintB.mint, tokenAccounts: g ? [] : H.tokenAccounts, owner: H.wallet, createInfo: g || x ? { connection: J, payer: H.feePayer, amount: x ? 0 : W, frontInstructions: K, endInstructions: w2, frontInstructionsType: O, endInstructionsType: h2, signers: b } : undefined, associatedOnly: g ? false : j, checkCreateATAOwner: V });
    e0.assertArgument(!!A || !!I, "cannot found target token accounts", "tokenAccounts", H.tokenAccounts);
    const T = this.makeSwapBaseInInstructions({ poolInfo: $, ownerInfo: { wallet: H.wallet, tokenAccountA: A, tokenAccountB: I }, inputMint: Q, amountIn: W, amountOutMin: Z, sqrtPriceLimitX64: N, remainingAccounts: z });
    return { address: T.address, innerTransactions: await L0({ connection: J, makeTxVersion: C, computeBudgetConfig: U, payer: H.feePayer, innerTransaction: [{ instructionTypes: O, instructions: K, signers: b }, T.innerTransaction, { instructionTypes: h2, instructions: w2, signers: [] }], lookupTableCache: q }) };
  }
  static async makeSwapBaseOutInstructionSimple({ connection: J, poolInfo: $, ownerInfo: H, outputMint: Q, amountOut: W, amountInMax: Z, priceLimit: Y, remainingAccounts: z, associatedOnly: j = true, checkCreateATAOwner: V = false, computeBudgetConfig: U, makeTxVersion: C, lookupTableCache: q }) {
    const K = [], w2 = [], O = [], h2 = [], b = [];
    let N;
    if (!Y || Y.equals(new F0(0)))
      N = Q.equals($.mintB.mint) ? L$.add(k0) : K$.sub(k0);
    else
      N = S0.priceToSqrtPriceX64(Y, $.mintA.decimals, $.mintB.decimals);
    const x = $.mintA.mint.equals(Q), k = H.useSOLBalance && $.mintA.mint.equals(r.WSOL.mint), g = H.useSOLBalance && $.mintB.mint.equals(r.WSOL.mint), A = await this._selectOrCreateTokenAccount({ programId: $.mintA.programId, mint: $.mintA.mint, tokenAccounts: k ? [] : H.tokenAccounts, owner: H.wallet, createInfo: k || !x ? { connection: J, payer: H.feePayer, amount: x ? Z : 0, frontInstructions: K, endInstructions: w2, frontInstructionsType: O, endInstructionsType: h2, signers: b } : undefined, associatedOnly: k ? false : j, checkCreateATAOwner: V }), I = await this._selectOrCreateTokenAccount({ programId: $.mintB.programId, mint: $.mintB.mint, tokenAccounts: g ? [] : H.tokenAccounts, owner: H.wallet, createInfo: g || x ? { connection: J, payer: H.feePayer, amount: x ? 0 : Z, frontInstructions: K, endInstructions: w2, frontInstructionsType: O, endInstructionsType: h2, signers: b } : undefined, associatedOnly: g ? false : j, checkCreateATAOwner: V });
    e0.assertArgument(!!A || !!I, "cannot found target token accounts", "tokenAccounts", H.tokenAccounts);
    const T = this.makeSwapBaseOutInstructions({ poolInfo: $, ownerInfo: { wallet: H.wallet, tokenAccountA: A, tokenAccountB: I }, outputMint: Q, amountOut: W, amountInMax: Z, sqrtPriceLimitX64: N, remainingAccounts: z });
    return { address: T.address, innerTransactions: await L0({ connection: J, makeTxVersion: C, computeBudgetConfig: U, payer: H.feePayer, innerTransaction: [{ instructionTypes: O, instructions: K, signers: b }, T.innerTransaction, { instructionTypes: h2, instructions: w2, signers: [] }], lookupTableCache: q }) };
  }
  static async makeCLosePositionInstructionSimple({ poolInfo: J, ownerPosition: $, ownerInfo: H, makeTxVersion: Q, lookupTableCache: W, connection: Z }) {
    const Y = this.makeClosePositionInstructions({ poolInfo: J, ownerInfo: H, ownerPosition: $ });
    return { address: Y.address, innerTransactions: await L0({ connection: Z, makeTxVersion: Q, computeBudgetConfig: undefined, payer: H.feePayer, innerTransaction: [Y.innerTransaction], lookupTableCache: W }) };
  }
  static async makeInitRewardInstructionSimple({ connection: J, poolInfo: $, ownerInfo: H, rewardInfo: Q, chainTime: W, associatedOnly: Z = true, checkCreateATAOwner: Y = false, makeTxVersion: z, lookupTableCache: j }) {
    e0.assertArgument(Q.endTime > Q.openTime, "reward time error", "rewardInfo", Q), e0.assertArgument(Q.openTime > W, "reward must be paid later", "rewardInfo", Q);
    const V = [], U = [], C = [], q = [], K = [], w2 = H.useSOLBalance && Q.mint.equals(r.WSOL.mint), O = Q.perSecond.mul(Q.endTime - Q.openTime), h2 = await this._selectOrCreateTokenAccount({ programId: Q.programId, mint: Q.mint, tokenAccounts: w2 ? [] : H.tokenAccounts, owner: H.wallet, createInfo: w2 ? { connection: J, payer: H.feePayer, amount: new f0.default(new F0(O.toFixed(0)).gte(O) ? O.toFixed(0) : O.add(1).toFixed(0)), frontInstructions: V, endInstructions: U, frontInstructionsType: C, endInstructionsType: q, signers: K } : undefined, associatedOnly: w2 ? false : Z, checkCreateATAOwner: Y });
    e0.assertArgument(h2, "no money", "ownerRewardAccount", H.tokenAccounts);
    const b = this.makeInitRewardInstructions({ poolInfo: $, ownerInfo: { wallet: H.wallet, tokenAccount: h2 }, rewardInfo: { programId: Q.programId, mint: Q.mint, openTime: Q.openTime, endTime: Q.endTime, emissionsPerSecondX64: K0.decimalToX64(Q.perSecond) } });
    return { address: b.address, innerTransactions: await L0({ connection: J, makeTxVersion: z, computeBudgetConfig: undefined, payer: H.feePayer, innerTransaction: [{ instructionTypes: C, instructions: V, signers: K }, b.innerTransaction, { instructionTypes: q, instructions: U, signers: [] }], lookupTableCache: j }) };
  }
  static async makeInitRewardsInstructionSimple({ connection: J, poolInfo: $, ownerInfo: H, rewardInfos: Q, associatedOnly: W = true, checkCreateATAOwner: Z = false, computeBudgetConfig: Y, makeTxVersion: z, lookupTableCache: j }) {
    for (let h2 of Q)
      e0.assertArgument(h2.endTime > h2.openTime, "reward time error", "rewardInfo", h2);
    const V = [], U = [], C = [], q = [], K = [], w2 = [];
    for (let h2 of Q) {
      const b = H.useSOLBalance && h2.mint.equals(r.WSOL.mint), N = h2.perSecond.mul(h2.endTime - h2.openTime), x = await this._selectOrCreateTokenAccount({ programId: h2.programId, mint: h2.mint, tokenAccounts: b ? [] : H.tokenAccounts, owner: H.wallet, createInfo: b ? { connection: J, payer: H.feePayer, amount: new f0.default(new F0(N.toFixed(0)).gte(N) ? N.toFixed(0) : N.add(1).toFixed(0)), frontInstructions: V, endInstructions: U, frontInstructionsType: C, endInstructionsType: q, signers: w2 } : undefined, associatedOnly: b ? false : W, checkCreateATAOwner: Z });
      e0.assertArgument(x, "no money", "ownerRewardAccount", H.tokenAccounts), K.push(this.makeInitRewardInstructions({ poolInfo: $, ownerInfo: { wallet: H.wallet, tokenAccount: x }, rewardInfo: { programId: h2.programId, mint: h2.mint, openTime: h2.openTime, endTime: h2.endTime, emissionsPerSecondX64: K0.decimalToX64(h2.perSecond) } }));
    }
    let O = {};
    for (let h2 of K)
      O = { ...O, ...h2.address };
    return { address: O, innerTransactions: await L0({ connection: J, makeTxVersion: z, computeBudgetConfig: Y, payer: H.feePayer, innerTransaction: [{ instructionTypes: C, instructions: V, signers: w2 }, ...K.map((h2) => h2.innerTransaction), { instructionTypes: q, instructions: U, signers: [] }], lookupTableCache: j }) };
  }
  static async makeSetRewardInstructionSimple({ connection: J, poolInfo: $, ownerInfo: H, rewardInfo: Q, chainTime: W, associatedOnly: Z = true, checkCreateATAOwner: Y = false, makeTxVersion: z, lookupTableCache: j }) {
    e0.assertArgument(Q.endTime > Q.openTime, "reward time error", "rewardInfo", Q), e0.assertArgument(Q.openTime > W, "reward must be paid later", "rewardInfo", Q);
    const V = [], U = [], C = [], q = [], K = [], w2 = H.useSOLBalance && Q.mint.equals(r.WSOL.mint), O = await this._selectOrCreateTokenAccount({ programId: Q.programId, mint: Q.mint, tokenAccounts: w2 ? [] : H.tokenAccounts, owner: H.wallet, createInfo: w2 ? { connection: J, payer: H.feePayer, amount: new f0.default(new F0(Q.perSecond.sub(Q.endTime - Q.openTime).toFixed(0)).gte(Q.perSecond.sub(Q.endTime - Q.openTime)) ? Q.perSecond.sub(Q.endTime - Q.openTime).toFixed(0) : Q.perSecond.sub(Q.endTime - Q.openTime).add(1).toFixed(0)), frontInstructions: V, endInstructions: U, frontInstructionsType: C, endInstructionsType: q, signers: K } : undefined, associatedOnly: w2 ? false : Z, checkCreateATAOwner: Y });
    e0.assertArgument(O, "no money", "ownerRewardAccount", H.tokenAccounts);
    const h2 = this.makeSetRewardInstructions({ poolInfo: $, ownerInfo: { wallet: H.wallet, tokenAccount: O }, rewardInfo: { mint: Q.mint, openTime: Q.openTime, endTime: Q.endTime, emissionsPerSecondX64: K0.decimalToX64(Q.perSecond) } });
    return { address: h2.address, innerTransactions: await L0({ connection: J, makeTxVersion: z, computeBudgetConfig: undefined, payer: H.feePayer, innerTransaction: [{ instructionTypes: C, instructions: V, signers: K }, h2.innerTransaction, { instructionTypes: q, instructions: U, signers: [] }], lookupTableCache: j }) };
  }
  static async makeSetRewardsInstructionSimple({ connection: J, poolInfo: $, ownerInfo: H, rewardInfos: Q, chainTime: W, associatedOnly: Z = true, checkCreateATAOwner: Y = false, computeBudgetConfig: z, makeTxVersion: j, lookupTableCache: V }) {
    const U = [], C = [], q = [], K = [], w2 = [], O = [];
    for (let b of Q) {
      e0.assertArgument(b.endTime > b.openTime, "reward time error", "rewardInfo", b), e0.assertArgument(b.openTime > W, "reward must be paid later", "rewardInfo", b);
      const N = H.useSOLBalance && b.mint.equals(r.WSOL.mint), x = await this._selectOrCreateTokenAccount({ programId: b.programId, mint: b.mint, tokenAccounts: N ? [] : H.tokenAccounts, owner: H.wallet, createInfo: N ? { connection: J, payer: H.feePayer, amount: new f0.default(new F0(b.perSecond.sub(b.endTime - b.openTime).toFixed(0)).gte(b.perSecond.sub(b.endTime - b.openTime)) ? b.perSecond.sub(b.endTime - b.openTime).toFixed(0) : b.perSecond.sub(b.endTime - b.openTime).add(1).toFixed(0)), frontInstructions: U, endInstructions: C, frontInstructionsType: q, endInstructionsType: K, signers: O } : undefined, associatedOnly: N ? false : Z, checkCreateATAOwner: Y });
      e0.assertArgument(x, "no money", "ownerRewardAccount", H.tokenAccounts), w2.push(this.makeSetRewardInstructions({ poolInfo: $, ownerInfo: { wallet: H.wallet, tokenAccount: x }, rewardInfo: { mint: b.mint, openTime: b.openTime, endTime: b.endTime, emissionsPerSecondX64: K0.decimalToX64(b.perSecond) } }));
    }
    let h2 = {};
    for (let b of w2)
      h2 = { ...h2, ...b.address };
    return { address: h2, innerTransactions: await L0({ connection: J, makeTxVersion: j, computeBudgetConfig: z, payer: H.feePayer, innerTransaction: [{ instructionTypes: q, instructions: U, signers: O }, ...w2.map((b) => b.innerTransaction), { instructionTypes: K, instructions: C, signers: [] }], lookupTableCache: V }) };
  }
  static async makeCollectRewardInstructionSimple({ connection: J, poolInfo: $, ownerInfo: H, rewardMint: Q, associatedOnly: W = true, checkCreateATAOwner: Z = false, computeBudgetConfig: Y, makeTxVersion: z, lookupTableCache: j }) {
    const V = [], U = [], C = [], q = [], K = [], w2 = $.rewardInfos.find((N) => N.tokenMint.equals(Q));
    if (e0.assertArgument(w2 !== undefined, "reward mint error", "not found reward mint", Q), w2 === undefined)
      throw Error("reward mint error");
    const O = H.useSOLBalance && Q.equals(r.WSOL.mint), h2 = await this._selectOrCreateTokenAccount({ programId: w2.tokenProgramId, mint: Q, tokenAccounts: O ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.feePayer, amount: 0, frontInstructions: V, endInstructions: O ? U : [], frontInstructionsType: C, endInstructionsType: q, signers: K }, associatedOnly: O ? false : W, checkCreateATAOwner: Z });
    e0.assertArgument(h2, "no money", "ownerRewardAccount", H.tokenAccounts);
    const b = this.makeCollectRewardInstructions({ poolInfo: $, ownerInfo: { wallet: H.wallet, tokenAccount: h2 }, rewardMint: Q });
    return { address: b.address, innerTransactions: await L0({ connection: J, makeTxVersion: z, computeBudgetConfig: Y, payer: H.feePayer, innerTransaction: [{ instructionTypes: C, instructions: V, signers: K }, b.innerTransaction, { instructionTypes: q, instructions: U, signers: [] }], lookupTableCache: j }) };
  }
  static async makeCollectRewardsInstructionSimple({ connection: J, poolInfo: $, ownerInfo: H, rewardMints: Q, associatedOnly: W = true, checkCreateATAOwner: Z = false, computeBudgetConfig: Y, makeTxVersion: z, lookupTableCache: j }) {
    const V = [], U = [], C = [], q = [], K = [], w2 = [];
    for (let h2 of Q) {
      const b = $.rewardInfos.find((k) => k.tokenMint.equals(h2));
      if (e0.assertArgument(b !== undefined, "reward mint error", "not found reward mint", h2), b === undefined)
        throw Error("reward mint error");
      const N = H.useSOLBalance && h2.equals(r.WSOL.mint), x = await this._selectOrCreateTokenAccount({ programId: b.tokenProgramId, mint: h2, tokenAccounts: N ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.feePayer, amount: 0, frontInstructions: V, endInstructions: N ? U : [], signers: w2, frontInstructionsType: C, endInstructionsType: q }, associatedOnly: N ? false : W, checkCreateATAOwner: Z });
      e0.assertArgument(x, "no money", "ownerRewardAccount", H.tokenAccounts), K.push(this.makeCollectRewardInstructions({ poolInfo: $, ownerInfo: { wallet: H.wallet, tokenAccount: x }, rewardMint: h2 }));
    }
    let O = {};
    for (let h2 of K)
      O = { ...O, ...h2.address };
    return { address: O, innerTransactions: await L0({ connection: J, makeTxVersion: z, computeBudgetConfig: Y, payer: H.feePayer, innerTransaction: [{ instructionTypes: C, instructions: V, signers: w2 }, ...K.map((h2) => h2.innerTransaction), { instructionTypes: q, instructions: U, signers: [] }], lookupTableCache: j }) };
  }
  static async makeHarvestAllRewardInstructionSimple({ connection: J, fetchPoolInfos: $, ownerInfo: H, associatedOnly: Q = true, checkCreateATAOwner: W = false, makeTxVersion: Z, lookupTableCache: Y }) {
    const z = {};
    for (let w2 of H.tokenAccounts)
      if (Q) {
        if (n0(H.wallet, w2.accountInfo.mint, w2.programId).publicKey.equals(w2.pubkey))
          z[w2.accountInfo.mint.toString()] = w2.pubkey;
      } else
        z[w2.accountInfo.mint.toString()] = w2.pubkey;
    const j = [], V = [], U = [], C = [], q = [], K = [];
    for (let w2 of Object.values($)) {
      if (w2.positionAccount === undefined)
        continue;
      if (!w2.positionAccount.find((g) => !g.tokenFeeAmountA.isZero() || !g.tokenFeeAmountB.isZero() || g.rewardInfos.find((A) => !A.pendingReward.isZero())))
        continue;
      const O = w2.state, h2 = H.useSOLBalance && O.mintA.mint.equals(r.WSOL.mint), b = H.useSOLBalance && O.mintB.mint.equals(r.WSOL.mint), N = z[O.mintA.mint.toString()] ?? await this._selectOrCreateTokenAccount({ programId: O.mintA.programId, mint: O.mintA.mint, tokenAccounts: h2 ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.feePayer, amount: 0, frontInstructions: j, frontInstructionsType: U, endInstructions: h2 ? V : [], endInstructionsType: h2 ? C : [], signers: K }, associatedOnly: h2 ? false : Q, checkCreateATAOwner: W }), x = z[O.mintB.mint.toString()] ?? await this._selectOrCreateTokenAccount({ programId: O.mintB.programId, mint: O.mintB.mint, tokenAccounts: b ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.feePayer, amount: 0, frontInstructions: j, frontInstructionsType: U, endInstructions: b ? V : [], endInstructionsType: b ? C : [], signers: K }, associatedOnly: b ? false : Q, checkCreateATAOwner: W });
      z[O.mintA.mint.toString()] = N, z[O.mintB.mint.toString()] = x;
      const k = [];
      for (let g of O.rewardInfos) {
        const A = H.useSOLBalance && g.tokenMint.equals(r.WSOL.mint), I = z[g.tokenMint.toString()] ?? await this._selectOrCreateTokenAccount({ programId: g.tokenProgramId, mint: g.tokenMint, tokenAccounts: A ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.feePayer, amount: 0, frontInstructions: j, endInstructions: A ? V : [], frontInstructionsType: U, endInstructionsType: C, signers: K }, associatedOnly: A ? false : Q, checkCreateATAOwner: W });
        z[g.tokenMint.toString()] = I, k.push(I);
      }
      for (let g of w2.positionAccount)
        q.push(this.makeDecreaseLiquidityInstructions({ poolInfo: O, ownerPosition: g, ownerInfo: { wallet: H.wallet, tokenAccountA: N, tokenAccountB: x, rewardAccounts: k }, liquidity: J0, amountMinA: J0, amountMinB: J0 }));
    }
    return { address: {}, innerTransactions: await L0({ connection: J, makeTxVersion: Z, computeBudgetConfig: undefined, payer: H.feePayer, innerTransaction: [{ instructionTypes: U, instructions: j, signers: K }, ...q.map((w2) => w2.innerTransaction), { instructionTypes: C, instructions: V, signers: [] }], lookupTableCache: Y }) };
  }
  static async makeCreatePoolInstructions({ connection: J, programId: $, owner: H, mintA: Q, mintB: W, ammConfigId: Z, initialPriceX64: Y, startTime: z }) {
    const j = g$({ fromPublicKey: H, programId: $ }), V = _Y($, Z, Q.mint, W.mint).publicKey, U = e6($, V, Q.mint).publicKey, C = e6($, V, W.mint).publicKey, q = [$SystemProgram.createAccountWithSeed({ fromPubkey: H, basePubkey: H, seed: j.seed, newAccountPubkey: j.publicKey, lamports: await J.getMinimumBalanceForRentExemption(o6.span), space: o6.span, programId: $ }), FY($, V, H, Z, j.publicKey, Q.mint, U, Q.programId, W.mint, C, W.programId, D$($, V).publicKey, Y, z)];
    return { address: { observationId: j.publicKey, poolId: V, mintAVault: U, mintBVault: C }, innerTransaction: { instructions: q, signers: [], instructionTypes: [$0.createAccount, $0.clmmCreatePool], lookupTableAddress: [] } };
  }
  static async makeOpenPositionFromLiquidityInstructions({ poolInfo: J, ownerInfo: $, tickLower: H, tickUpper: Q, liquidity: W, amountMaxA: Z, amountMaxB: Y, withMetadata: z, getEphemeralSigners: j }) {
    const V = [];
    let U;
    if (j)
      U = new $PublicKey((await j(1))[0]);
    else {
      const k = $Keypair.generate();
      V.push(k), U = k.publicKey;
    }
    const C = v0.getTickArrayStartIndexByTick(H, J.ammConfig.tickSpacing), q = v0.getTickArrayStartIndexByTick(Q, J.ammConfig.tickSpacing), { publicKey: K } = m0(J.programId, J.id, C), { publicKey: w2 } = m0(J.programId, J.id, q), { publicKey: O } = n0($.wallet, U, m2), { publicKey: h2 } = t6(U), { publicKey: b } = a$(J.programId, U), { publicKey: N } = TH(J.programId, J.id, H, Q), x = XY(J.programId, $.feePayer, J.id, $.wallet, U, O, h2, N, K, w2, b, $.tokenAccountA, $.tokenAccountB, J.mintA.vault, J.mintB.vault, J.mintA.mint, J.mintB.mint, H, Q, C, q, W, Z, Y, z, Q$.isOverflowDefaultTickarrayBitmap(J.tickSpacing, [C, q]) ? D$(J.programId, J.id).publicKey : undefined);
    return { address: { nftMint: U, tickArrayLower: K, tickArrayUpper: w2, positionNftAccount: O, metadataAccount: h2, personalPosition: b, protocolPosition: N }, innerTransaction: { instructions: [x], signers: V, instructionTypes: [$0.clmmOpenPosition], lookupTableAddress: [J.lookupTableAccount].filter((k) => k && !k.equals($PublicKey.default)) } };
  }
  static async makeOpenPositionFromBaseInstructions({ poolInfo: J, ownerInfo: $, tickLower: H, tickUpper: Q, base: W, baseAmount: Z, otherAmountMax: Y, withMetadata: z, getEphemeralSigners: j }) {
    const V = [];
    let U;
    if (j)
      U = new $PublicKey((await j(1))[0]);
    else {
      const k = $Keypair.generate();
      V.push(k), U = k.publicKey;
    }
    const C = v0.getTickArrayStartIndexByTick(H, J.ammConfig.tickSpacing), q = v0.getTickArrayStartIndexByTick(Q, J.ammConfig.tickSpacing), { publicKey: K } = m0(J.programId, J.id, C), { publicKey: w2 } = m0(J.programId, J.id, q), { publicKey: O } = n0($.wallet, U, m2), { publicKey: h2 } = t6(U), { publicKey: b } = a$(J.programId, U), { publicKey: N } = TH(J.programId, J.id, H, Q), x = UY(J.programId, $.feePayer, J.id, $.wallet, U, O, h2, N, K, w2, b, $.tokenAccountA, $.tokenAccountB, J.mintA.vault, J.mintB.vault, J.mintA.mint, J.mintB.mint, H, Q, C, q, z, W, Z, Y, Q$.isOverflowDefaultTickarrayBitmap(J.tickSpacing, [C, q]) ? D$(J.programId, J.id).publicKey : undefined);
    return { address: { nftMint: U, tickArrayLower: K, tickArrayUpper: w2, positionNftAccount: O, metadataAccount: h2, personalPosition: b, protocolPosition: N }, innerTransaction: { instructions: [x], signers: V, instructionTypes: [$0.clmmOpenPosition], lookupTableAddress: [J.lookupTableAccount].filter((k) => k && !k.equals($PublicKey.default)) } };
  }
  static makeIncreasePositionFromLiquidityInstructions({ poolInfo: J, ownerPosition: $, ownerInfo: H, liquidity: Q, amountMaxA: W, amountMaxB: Z }) {
    const Y = v0.getTickArrayStartIndexByTick($.tickLower, J.ammConfig.tickSpacing), z = v0.getTickArrayStartIndexByTick($.tickUpper, J.ammConfig.tickSpacing), { publicKey: j } = m0(J.programId, J.id, Y), { publicKey: V } = m0(J.programId, J.id, z), { publicKey: U } = n0(H.wallet, $.nftMint, m2), { publicKey: C } = a$(J.programId, $.nftMint), { publicKey: q } = TH(J.programId, J.id, $.tickLower, $.tickUpper);
    return { address: { tickArrayLower: j, tickArrayUpper: V, positionNftAccount: U, personalPosition: C, protocolPosition: q }, innerTransaction: { instructions: [qY(J.programId, H.wallet, U, C, J.id, q, j, V, H.tokenAccountA, H.tokenAccountB, J.mintA.vault, J.mintB.vault, J.mintA.mint, J.mintB.mint, Q, W, Z, Q$.isOverflowDefaultTickarrayBitmap(J.tickSpacing, [Y, z]) ? D$(J.programId, J.id).publicKey : undefined)], signers: [], instructionTypes: [$0.clmmIncreasePosition], lookupTableAddress: [J.lookupTableAccount].filter((K) => K && !K.equals($PublicKey.default)) } };
  }
  static makeIncreasePositionFromBaseInstructions({ poolInfo: J, ownerPosition: $, ownerInfo: H, base: Q, baseAmount: W, otherAmountMax: Z }) {
    const Y = v0.getTickArrayStartIndexByTick($.tickLower, J.ammConfig.tickSpacing), z = v0.getTickArrayStartIndexByTick($.tickUpper, J.ammConfig.tickSpacing), { publicKey: j } = m0(J.programId, J.id, Y), { publicKey: V } = m0(J.programId, J.id, z), { publicKey: U } = n0(H.wallet, $.nftMint, m2), { publicKey: C } = a$(J.programId, $.nftMint), { publicKey: q } = TH(J.programId, J.id, $.tickLower, $.tickUpper);
    return { address: { tickArrayLower: j, tickArrayUpper: V, positionNftAccount: U, personalPosition: C, protocolPosition: q }, innerTransaction: { instructions: [vY(J.programId, H.wallet, U, C, J.id, q, j, V, H.tokenAccountA, H.tokenAccountB, J.mintA.vault, J.mintB.vault, J.mintA.mint, J.mintB.mint, Q, W, Z, Q$.isOverflowDefaultTickarrayBitmap(J.tickSpacing, [Y, z]) ? D$(J.programId, J.id).publicKey : undefined)], signers: [], instructionTypes: [$0.clmmIncreasePosition], lookupTableAddress: [J.lookupTableAccount].filter((K) => K && !K.equals($PublicKey.default)) } };
  }
  static makeDecreaseLiquidityInstructions({ poolInfo: J, ownerPosition: $, ownerInfo: H, liquidity: Q, amountMinA: W, amountMinB: Z }) {
    const Y = v0.getTickArrayStartIndexByTick($.tickLower, J.ammConfig.tickSpacing), z = v0.getTickArrayStartIndexByTick($.tickUpper, J.ammConfig.tickSpacing), { publicKey: j } = m0(J.programId, J.id, Y), { publicKey: V } = m0(J.programId, J.id, z), { publicKey: U } = n0(H.wallet, $.nftMint, m2), { publicKey: C } = a$(J.programId, $.nftMint), { publicKey: q } = TH(J.programId, J.id, $.tickLower, $.tickUpper), K = [];
    for (let w2 = 0;w2 < J.rewardInfos.length; w2++)
      K.push({ poolRewardVault: J.rewardInfos[w2].tokenVault, ownerRewardVault: H.rewardAccounts[w2], rewardMint: J.rewardInfos[w2].tokenMint });
    return { address: { tickArrayLower: j, tickArrayUpper: V, positionNftAccount: U, personalPosition: C, protocolPosition: q }, innerTransaction: { instructions: [CY(J.programId, H.wallet, U, C, J.id, q, j, V, H.tokenAccountA, H.tokenAccountB, J.mintA.vault, J.mintB.vault, J.mintA.mint, J.mintB.mint, K, Q, W, Z, Q$.isOverflowDefaultTickarrayBitmap(J.tickSpacing, [Y, z]) ? D$(J.programId, J.id).publicKey : undefined)], signers: [], instructionTypes: [$0.clmmDecreasePosition], lookupTableAddress: [J.lookupTableAccount].filter((w2) => w2 && !w2.equals($PublicKey.default)) } };
  }
  static makeClosePositionInstructions({ poolInfo: J, ownerInfo: $, ownerPosition: H }) {
    const { publicKey: Q } = n0($.wallet, H.nftMint, m2), { publicKey: W } = a$(J.programId, H.nftMint);
    return { address: { positionNftAccount: Q, personalPosition: W }, innerTransaction: { instructions: [DY(J.programId, $.wallet, H.nftMint, Q, W)], signers: [], instructionTypes: [$0.clmmClosePosition], lookupTableAddress: [J.lookupTableAccount].filter((Z) => Z && !Z.equals($PublicKey.default)) } };
  }
  static makeSwapBaseInInstructions({ poolInfo: J, ownerInfo: $, inputMint: H, amountIn: Q, amountOutMin: W, sqrtPriceLimitX64: Z, remainingAccounts: Y }) {
    const z = J.mintA.mint.equals(H);
    return { address: {}, innerTransaction: { instructions: [a6(J.programId, $.wallet, J.id, J.ammConfig.id, z ? $.tokenAccountA : $.tokenAccountB, z ? $.tokenAccountB : $.tokenAccountA, z ? J.mintA.vault : J.mintB.vault, z ? J.mintB.vault : J.mintA.vault, z ? J.mintA.mint : J.mintB.mint, z ? J.mintB.mint : J.mintA.mint, Y, J.observationId, Q, W, Z, true, D$(J.programId, J.id).publicKey)], signers: [], lookupTableAddress: [J.lookupTableAccount].filter((j) => j && !j.equals($PublicKey.default)), instructionTypes: [$0.clmmSwapBaseIn] } };
  }
  static makeSwapBaseOutInstructions({ poolInfo: J, ownerInfo: $, outputMint: H, amountOut: Q, amountInMax: W, sqrtPriceLimitX64: Z, remainingAccounts: Y }) {
    const z = J.mintA.mint.equals(H);
    return { address: {}, innerTransaction: { instructions: [a6(J.programId, $.wallet, J.id, J.ammConfig.id, z ? $.tokenAccountB : $.tokenAccountA, z ? $.tokenAccountA : $.tokenAccountB, z ? J.mintB.vault : J.mintA.vault, z ? J.mintA.vault : J.mintB.vault, z ? J.mintB.mint : J.mintA.mint, z ? J.mintA.mint : J.mintB.mint, Y, J.observationId, Q, W, Z, false, D$(J.programId, J.id).publicKey)], signers: [], lookupTableAddress: [J.lookupTableAccount].filter((j) => j && !j.equals($PublicKey.default)), instructionTypes: [$0.clmmSwapBaseOut] } };
  }
  static makeInitRewardInstructions({ poolInfo: J, ownerInfo: $, rewardInfo: H }) {
    const Q = PY(J.programId, J.id, H.mint).publicKey, W = G8(J.programId).publicKey;
    return { address: { poolRewardVault: Q, operationId: W }, innerTransaction: { instructions: [RY(J.programId, $.wallet, J.id, W, J.ammConfig.id, $.tokenAccount, H.programId, H.mint, Q, H.openTime, H.endTime, H.emissionsPerSecondX64)], signers: [], instructionTypes: [$0.clmmInitReward], lookupTableAddress: [J.lookupTableAccount].filter((Z) => Z && !Z.equals($PublicKey.default)) } };
  }
  static makeSetRewardInstructions({ poolInfo: J, ownerInfo: $, rewardInfo: H }) {
    let Q, W, Z;
    for (let z = 0;z < J.rewardInfos.length; z++)
      if (J.rewardInfos[z].tokenMint.equals(H.mint))
        Q = z, W = J.rewardInfos[z].tokenVault, Z = J.rewardInfos[z].tokenMint;
    if (Q === undefined || W === undefined || Z === undefined)
      throw Error("reward mint check error");
    const Y = G8(J.programId).publicKey;
    return { address: { rewardVault: W, operationId: Y }, innerTransaction: { instructions: [BY(J.programId, $.wallet, J.id, Y, J.ammConfig.id, $.tokenAccount, W, Z, Q, H.openTime, H.endTime, H.emissionsPerSecondX64)], signers: [], instructionTypes: [$0.clmmInitReward], lookupTableAddress: [J.lookupTableAccount].filter((z) => z && !z.equals($PublicKey.default)) } };
  }
  static makeCollectRewardInstructions({ poolInfo: J, ownerInfo: $, rewardMint: H }) {
    let Q, W;
    for (let Z = 0;Z < J.rewardInfos.length; Z++)
      if (J.rewardInfos[Z].tokenMint.equals(H))
        Q = Z, W = J.rewardInfos[Z].tokenVault;
    if (Q === undefined || W === undefined)
      throw Error("reward mint check error");
    return { address: { rewardVault: W }, innerTransaction: { instructions: [MY(J.programId, $.wallet, J.id, $.tokenAccount, W, H, Q)], signers: [], instructionTypes: [$0.clmmInitReward], lookupTableAddress: [J.lookupTableAccount].filter((Z) => Z && !Z.equals($PublicKey.default)) } };
  }
  static getLiquidityAmountOutFromAmountIn({ poolInfo: J, inputA: $, tickLower: H, tickUpper: Q, amount: W, slippage: Z, add: Y, token2022Infos: z, epochInfo: j, amountHasFee: V }) {
    const U = J.sqrtPriceX64, C = S0.getSqrtPriceX64FromTick(H), q = S0.getSqrtPriceX64FromTick(Q), K = Y ? 1 - Z : 1 + Z, w2 = sJ(W, z[$ ? J.mintA.mint.toString() : J.mintB.mint.toString()]?.feeConfig, j, !V), O = new f0.default(new F0(w2.amount.sub(w2.fee ?? J0).toString()).mul(K).toFixed(0));
    let h2;
    if (U.lte(C))
      h2 = $ ? A0.getLiquidityFromTokenAmountA(C, q, O, !Y) : new f0.default(0);
    else if (U.lte(q)) {
      const b = A0.getLiquidityFromTokenAmountA(U, q, O, !Y), N = A0.getLiquidityFromTokenAmountB(C, U, O);
      h2 = $ ? b : N;
    } else
      h2 = $ ? new f0.default(0) : A0.getLiquidityFromTokenAmountB(C, q, O);
    return this.getAmountsFromLiquidity({ poolInfo: J, tickLower: H, tickUpper: Q, liquidity: h2, slippage: Z, add: Y, token2022Infos: z, epochInfo: j, amountAddFee: V });
  }
  static getLiquidityFromAmounts({ poolInfo: J, tickLower: $, tickUpper: H, amountA: Q, amountB: W, slippage: Z, add: Y, token2022Infos: z, epochInfo: j, amountHasFee: V }) {
    const [U, C, q, K] = $ < H ? [$, H, Q, W] : [H, $, W, Q], w2 = J.sqrtPriceX64, O = S0.getSqrtPriceX64FromTick(U), h2 = S0.getSqrtPriceX64FromTick(C), [b, N] = [sJ(q, z[J.mintA.mint.toString()]?.feeConfig, j, !V), sJ(K, z[J.mintB.mint.toString()]?.feeConfig, j, !V)], x = A0.getLiquidityFromTokenAmounts(w2, O, h2, b.amount.sub(b.fee ?? J0), N.amount.sub(N.fee ?? J0));
    return this.getAmountsFromLiquidity({ poolInfo: J, tickLower: $, tickUpper: H, liquidity: x, slippage: Z, add: Y, token2022Infos: z, epochInfo: j, amountAddFee: !V });
  }
  static getAmountsFromLiquidity({ poolInfo: J, tickLower: $, tickUpper: H, liquidity: Q, slippage: W, add: Z, token2022Infos: Y, epochInfo: z, amountAddFee: j }) {
    const V = S0.getSqrtPriceX64FromTick($), U = S0.getSqrtPriceX64FromTick(H), C = Z ? 1 + W : 1 - W, q = A0.getAmountsFromLiquidity(J.sqrtPriceX64, V, U, Q, Z), [K, w2] = [sJ(q.amountA, Y[J.mintA.mint.toString()]?.feeConfig, z, j), sJ(q.amountB, Y[J.mintB.mint.toString()]?.feeConfig, z, j)], [O, h2] = [sJ(new f0.default(new F0(q.amountA.toString()).mul(C).toFixed(0)), Y[J.mintA.mint.toString()]?.feeConfig, z, j), sJ(new f0.default(new F0(q.amountB.toString()).mul(C).toFixed(0)), Y[J.mintB.mint.toString()]?.feeConfig, z, j)];
    return { liquidity: Q, amountA: K, amountB: w2, amountSlippageA: O, amountSlippageB: h2, expirationTime: JQ(K.expirationTime, w2.expirationTime) };
  }
  static getPriceAndTick({ poolInfo: J, price: $, baseIn: H }) {
    const Q = H ? $ : new F0(1).div($), W = X8.getTickWithPriceAndTickspacing(Q, J.ammConfig.tickSpacing, J.mintA.decimals, J.mintB.decimals), Z = S0.getSqrtPriceX64FromTick(W), Y = S0.sqrtPriceX64ToPrice(Z, J.mintA.decimals, J.mintB.decimals);
    return H ? { tick: W, price: Y } : { tick: W, price: new F0(1).div(Y) };
  }
  static getTickPrice({ poolInfo: J, tick: $, baseIn: H }) {
    const Q = S0.getSqrtPriceX64FromTick($), W = S0.sqrtPriceX64ToPrice(Q, J.mintA.decimals, J.mintB.decimals);
    return H ? { tick: $, price: W, tickSqrtPriceX64: Q } : { tick: $, price: new F0(1).div(W), tickSqrtPriceX64: Q };
  }
  static computeAmountOutFormat({ poolInfo: J, tickArrayCache: $, token2022Infos: H, epochInfo: Q, amountIn: W, currencyOut: Z, slippage: Y, catchLiquidityInsufficient: z = false }) {
    const j = W instanceof O0, V = (j ? W.token : r.WSOL).mint, U = W.raw, C = Y.numerator.toNumber() / Y.denominator.toNumber(), { allTrade: q, realAmountIn: K, amountOut: w2, minAmountOut: O, expirationTime: h2, currentPrice: b, executionPrice: N, priceImpact: x, fee: k, remainingAccounts: g } = this.computeAmountOut({ poolInfo: J, tickArrayCache: $, baseMint: V, amountIn: U, slippage: C, token2022Infos: H, epochInfo: Q, catchLiquidityInsufficient: z }), A = { ...K, amount: j ? new O0(W.token, K.amount) : new r0(Y$.SOL, K.amount), fee: K.fee === undefined ? undefined : j ? new O0(W.token, K.fee) : new r0(Y$.SOL, K.fee) }, I = { ...w2, amount: Z instanceof r ? new O0(Z, w2.amount) : new r0(Z, w2.amount), fee: w2.fee === undefined ? undefined : Z instanceof r ? new O0(Z, w2.fee) : new r0(Z, w2.fee) }, T = { ...O, amount: Z instanceof r ? new O0(Z, O.amount) : new r0(Z, O.amount), fee: O.fee === undefined ? undefined : Z instanceof r ? new O0(Z, O.fee) : new r0(Z, O.fee) }, u = new PJ(j ? W.token : W.currency, new f0.default(10).pow(new f0.default(20 + (j ? W.token : W.currency).decimals)), Z instanceof r ? Z : r.WSOL, b.mul(new F0(10 ** (20 + (Z instanceof r ? Z : r.WSOL).decimals))).toFixed(0)), a = new PJ(j ? W.token : W.currency, new f0.default(10).pow(new f0.default(20 + (j ? W.token : W.currency).decimals)), Z instanceof r ? Z : r.WSOL, N.mul(new F0(10 ** (20 + (Z instanceof r ? Z : r.WSOL).decimals))).toFixed(0)), n = j ? new O0(W.token, k) : new r0(W.currency, k);
    return { allTrade: q, realAmountIn: A, amountOut: I, minAmountOut: T, expirationTime: h2, currentPrice: u, executionPrice: a, priceImpact: x, fee: n, remainingAccounts: g };
  }
  static async computeAmountOutAndCheckToken({ connection: J, poolInfo: $, tickArrayCache: H, baseMint: Q, amountIn: W, slippage: Z, priceLimit: Y = new F0(0), catchLiquidityInsufficient: z = false }) {
    const j = await J.getEpochInfo(), V = await b6({ connection: J, mints: [$.mintA, $.mintB].filter((U) => U.programId.equals(W$)).map((U) => U.mint) });
    return this.computeAmountOut({ poolInfo: $, tickArrayCache: H, baseMint: Q, amountIn: W, slippage: Z, priceLimit: Y, token2022Infos: V, epochInfo: j, catchLiquidityInsufficient: z });
  }
  static computeAmountOut({ poolInfo: J, tickArrayCache: $, baseMint: H, token2022Infos: Q, epochInfo: W, amountIn: Z, slippage: Y, priceLimit: z = new F0(0), catchLiquidityInsufficient: j = false }) {
    let V;
    if (z.equals(new F0(0)))
      V = H.equals(J.mintA.mint) ? L$.add(k0) : K$.sub(k0);
    else
      V = S0.priceToSqrtPriceX64(z, J.mintA.decimals, J.mintB.decimals);
    const U = sJ(Z, Q[H.toString()]?.feeConfig, W, false), { allTrade: C, realTradeAmountIn: q, expectedAmountOut: K, remainingAccounts: w2, executionPrice: O, feeAmount: h2 } = Q$.getOutputAmountAndRemainAccounts(J, $, H, U.amount.sub(U.fee ?? J0), V, j), b = sJ(q, Q[H.toString()]?.feeConfig, W, true), N = J.mintA.mint.equals(H) ? J.mintB.mint : J.mintA.mint, x = sJ(K, Q[N.toString()]?.feeConfig, W, false), k = S0.sqrtPriceX64ToPrice(O, J.mintA.decimals, J.mintB.decimals), g = H.equals(J.mintA.mint) ? k : new F0(1).div(k), A = K.mul(new f0.default(Math.floor((1 - Y) * 10000000000))).div(new f0.default(10000000000)), I = sJ(A, Q[N.toString()]?.feeConfig, W, false), T = J.mintA.mint.equals(H) ? J.currentPrice : new F0(1).div(J.currentPrice), u = new F0(g).sub(T).abs(), a = T, n = new uJ(new F0(u).mul(1000000000000000).toFixed(0), new F0(a).mul(1000000000000000).toFixed(0));
    return { allTrade: C, realAmountIn: b, amountOut: x, minAmountOut: I, expirationTime: JQ(b.expirationTime, x.expirationTime), currentPrice: J.currentPrice, executionPrice: g, priceImpact: n, fee: h2, remainingAccounts: w2 };
  }
  static async computeAmountInAndCheckToken({ connection: J, poolInfo: $, tickArrayCache: H, baseMint: Q, amountOut: W, slippage: Z, priceLimit: Y = new F0(0) }) {
    const z = await J.getEpochInfo(), j = await b6({ connection: J, mints: [$.mintA, $.mintB].filter((V) => V.programId.equals(W$)).map((V) => V.mint) });
    return this.computeAmountIn({ poolInfo: $, tickArrayCache: H, baseMint: Q, amountOut: W, slippage: Z, priceLimit: Y, token2022Infos: j, epochInfo: z });
  }
  static computeAmountIn({ poolInfo: J, tickArrayCache: $, baseMint: H, token2022Infos: Q, epochInfo: W, amountOut: Z, slippage: Y, priceLimit: z = new F0(0) }) {
    let j;
    if (z.equals(new F0(0)))
      j = H.equals(J.mintB.mint) ? L$.add(k0) : K$.sub(k0);
    else
      j = S0.priceToSqrtPriceX64(z, J.mintA.decimals, J.mintB.decimals);
    const V = sJ(Z, Q[H.toString()]?.feeConfig, W, true), { expectedAmountIn: U, remainingAccounts: C, executionPrice: q, feeAmount: K } = Q$.getInputAmountAndRemainAccounts(J, $, H, V.amount.sub(V.fee ?? J0), j), w2 = J.mintA.mint.equals(H) ? J.mintB.mint : J.mintA.mint, O = sJ(U, Q[w2.toString()]?.feeConfig, W, true), h2 = S0.sqrtPriceX64ToPrice(q, J.mintA.decimals, J.mintB.decimals), b = H.equals(J.mintA.mint) ? h2 : new F0(1).div(h2), N = U.mul(new f0.default(Math.floor((1 + Y) * 10000000000))).div(new f0.default(10000000000)), x = sJ(N, Q[w2.toString()]?.feeConfig, W, true), k = J.mintA.mint.equals(H) ? J.currentPrice : new F0(1).div(J.currentPrice), g = new F0(b).sub(k).abs(), A = k, I = new uJ(new F0(g).mul(1000000000000000).toFixed(0), new F0(A).mul(1000000000000000).toFixed(0));
    return { amountIn: O, maxAmountIn: x, realAmountOut: V, expirationTime: JQ(O.expirationTime, V.expirationTime), currentPrice: J.currentPrice, executionPrice: b, priceImpact: I, fee: K, remainingAccounts: C };
  }
  static estimateAprsForPriceRangeMultiplier({ poolInfo: J, aprType: $, positionTickLowerIndex: H, positionTickUpperIndex: Q }) {
    const W = J[$], Z = this.getTickPrice({ poolInfo: J, tick: H, baseIn: true }).price.toNumber(), Y = this.getTickPrice({ poolInfo: J, tick: Q, baseIn: true }).price.toNumber(), z = Math.max(Z, W.priceMin), V = Math.min(Y, W.priceMax) - z, U = Y - Z, C = W.priceMax - W.priceMin;
    let q;
    if (V <= 0)
      q = 0;
    else if (U === V)
      q = C / V;
    else if (C === V)
      q = V / U;
    else
      q = V / C * (V / U);
    return { feeApr: W.feeApr * q, rewardsApr: [W.rewardApr.A * q, W.rewardApr.B * q, W.rewardApr.C * q], apr: W.apr * q };
  }
  static estimateAprsForPriceRangeDelta({ poolInfo: J, aprType: $, mintPrice: H, rewardMintDecimals: Q, liquidity: W, positionTickLowerIndex: Z, positionTickUpperIndex: Y, chainTime: z }) {
    const j = $ === "day" ? 1 : $ === "week" ? 7 : $ === "month" ? 30 : 0, V = J[$], U = H[J.mintA.mint.toString()], C = H[J.mintB.mint.toString()], q = J.mintA.decimals, K = J.mintB.decimals;
    if (!V || !U || !C)
      return { feeApr: 0, rewardsApr: [0, 0, 0], apr: 0 };
    const w2 = S0.getSqrtPriceX64FromTick(Z), O = S0.getSqrtPriceX64FromTick(Y), { amountSlippageA: h2, amountSlippageB: b } = A0.getAmountsFromLiquidityWithSlippage(J.sqrtPriceX64, w2, O, J.liquidity, false, false, 0), { amountSlippageA: N, amountSlippageB: x } = A0.getAmountsFromLiquidityWithSlippage(J.sqrtPriceX64, w2, O, W, false, false, 0), k = new F0(h2.toString()).div(new F0(10).pow(q)).mul(U.toFixed(q)).add(new F0(b.toString()).div(new F0(10).pow(K)).mul(C.toFixed(K))), g = new F0(N.toString()).div(new F0(10).pow(q)).mul(U.toFixed(q)).add(new F0(x.toString()).div(new F0(10).pow(K)).mul(C.toFixed(K))), A = g.div(k.add(g)).div(g), T = new F0(V.volumeFee).mul(365).div(j).mul(A).mul(100).toNumber(), u = 31536000, a = J.rewardInfos.map((n) => {
      const Z0 = Q[n.tokenMint.toString()], _ = H[n.tokenMint.toString()];
      if (z < n.openTime.toNumber() || z > n.endTime.toNumber() || n.perSecond.equals(0) || !_ || Z0 === undefined)
        return 0;
      return new F0(_.toFixed(Z0)).mul(n.perSecond.mul(u)).div(new F0(10).pow(Z0)).mul(A).mul(100).toNumber();
    });
    return { feeApr: T, rewardsApr: a, apr: T + a.reduce((n, Z0) => n + Z0, 0) };
  }
  static async fetchMultiplePoolInfos({ connection: J, poolKeys: $, ownerInfo: H, chainTime: Q, batchRequest: W = false, updateOwnerRewardAndFee: Z = true }) {
    const Y = await J$(J, $.map((q) => new $PublicKey(q.id)), { batchRequest: W }), z = {};
    for (let q = 0;q < $.length; q++) {
      const K = $[q], w2 = Y[q];
      if (w2 === null)
        continue;
      z[K.id] = D$(w2.owner, new $PublicKey(K.id)).publicKey;
    }
    const j = await this.fetchExBitmaps({ connection: J, exBitmapAddress: Object.values(z), batchRequest: W }), V = [], U = {}, C = [];
    for (let q = 0;q < $.length; q++) {
      const K = $[q], w2 = Y[q], O = j[z[K.id].toString()];
      if (w2 === null)
        continue;
      const h2 = gY.decode(w2.data);
      if (U[K.id] = { state: { id: new $PublicKey(K.id), mintA: { programId: new $PublicKey(K.mintProgramIdA), mint: h2.mintA, vault: h2.vaultA, decimals: h2.mintDecimalsA }, mintB: { programId: new $PublicKey(K.mintProgramIdB), mint: h2.mintB, vault: h2.vaultB, decimals: h2.mintDecimalsB }, observationId: h2.observationId, ammConfig: { ...K.ammConfig, id: new $PublicKey(K.ammConfig.id) }, creator: h2.creator, programId: w2.owner, version: 6, tickSpacing: h2.tickSpacing, liquidity: h2.liquidity, sqrtPriceX64: h2.sqrtPriceX64, currentPrice: S0.sqrtPriceX64ToPrice(h2.sqrtPriceX64, h2.mintDecimalsA, h2.mintDecimalsB), tickCurrent: h2.tickCurrent, observationIndex: h2.observationIndex, observationUpdateDuration: h2.observationUpdateDuration, feeGrowthGlobalX64A: h2.feeGrowthGlobalX64A, feeGrowthGlobalX64B: h2.feeGrowthGlobalX64B, protocolFeesTokenA: h2.protocolFeesTokenA, protocolFeesTokenB: h2.protocolFeesTokenB, swapInAmountTokenA: h2.swapInAmountTokenA, swapOutAmountTokenB: h2.swapOutAmountTokenB, swapInAmountTokenB: h2.swapInAmountTokenB, swapOutAmountTokenA: h2.swapOutAmountTokenA, tickArrayBitmap: h2.tickArrayBitmap, rewardInfos: await Q$.updatePoolRewardInfos({ connection: J, apiPoolInfo: K, chainTime: Q, poolLiquidity: h2.liquidity, rewardInfos: h2.rewardInfos.filter((b) => !b.tokenMint.equals($PublicKey.default)) }), day: K.day, week: K.week, month: K.month, tvl: K.tvl, lookupTableAccount: K.lookupTableAccount ? new $PublicKey(K.lookupTableAccount) : $PublicKey.default, startTime: h2.startTime.toNumber(), exBitmapInfo: O } }, H)
        C.push(...U[K.id].state.rewardInfos.filter((b) => b.creator.equals(H.wallet)));
      if (!V.find((b) => b.equals(w2.owner)))
        V.push(w2.owner);
    }
    if (H) {
      const q = H.tokenAccounts.filter((h2) => h2.accountInfo.amount.eq(new f0.default(1))).map((h2) => h2.accountInfo.mint), K = [];
      for (let h2 of q)
        for (let b of V)
          K.push(a$(b, h2).publicKey);
      const w2 = await J$(J, K, { batchRequest: W }), O = {};
      for (let h2 of w2) {
        if (h2 === null)
          continue;
        const b = kY.decode(h2.data), N = b.poolId.toString(), x = U[N];
        if (x === undefined)
          continue;
        const k = x.state, g = this.getTickPrice({ poolInfo: k, tick: b.tickLower, baseIn: true }), A = this.getTickPrice({ poolInfo: k, tick: b.tickUpper, baseIn: true }), { amountA: I, amountB: T } = A0.getAmountsFromLiquidity(k.sqrtPriceX64, g.tickSqrtPriceX64, A.tickSqrtPriceX64, b.liquidity, false), u = 1 / (1 - Math.sqrt(Math.sqrt(g.price.div(A.price).toNumber())));
        U[N].positionAccount = [...U[N].positionAccount ?? [], { poolId: b.poolId, nftMint: b.nftMint, priceLower: g.price, priceUpper: A.price, amountA: I, amountB: T, tickLower: b.tickLower, tickUpper: b.tickUpper, liquidity: b.liquidity, feeGrowthInsideLastX64A: b.feeGrowthInsideLastX64A, feeGrowthInsideLastX64B: b.feeGrowthInsideLastX64B, tokenFeesOwedA: b.tokenFeesOwedA, tokenFeesOwedB: b.tokenFeesOwedB, rewardInfos: b.rewardInfos.map((Z0) => ({ ...Z0, pendingReward: new f0.default(0) })), leverage: u, tokenFeeAmountA: new f0.default(0), tokenFeeAmountB: new f0.default(0) }];
        const a = v0.getTickArrayAddressByTick(U[N].state.programId, b.poolId, b.tickLower, U[N].state.tickSpacing), n = v0.getTickArrayAddressByTick(U[N].state.programId, b.poolId, b.tickUpper, U[N].state.tickSpacing);
        O[`${U[N].state.programId.toString()}-${b.poolId.toString()}-${b.tickLower}`] = a, O[`${U[N].state.programId.toString()}-${b.poolId.toString()}-${b.tickUpper}`] = n;
      }
      if (Z) {
        const h2 = Object.values(O), b = await J$(J, h2, { batchRequest: W }), N = {};
        for (let x = 0;x < h2.length; x++) {
          const k = b[x];
          if (k === null)
            continue;
          const g = h2[x];
          N[g.toString()] = { address: g, ...jQ.decode(k.data) };
        }
        for (let { state: x, positionAccount: k } of Object.values(U)) {
          if (!k)
            continue;
          for (let g of k) {
            const A = `${x.programId.toString()}-${x.id.toString()}-${g.tickLower}`, I = `${x.programId.toString()}-${x.id.toString()}-${g.tickUpper}`, T = N[O[A].toString()], u = N[O[I].toString()], a = T.ticks[v0.getTickOffsetInArray(g.tickLower, x.tickSpacing)], n = u.ticks[v0.getTickOffsetInArray(g.tickUpper, x.tickSpacing)], { tokenFeeAmountA: Z0, tokenFeeAmountB: _ } = U8.GetPositionFees(x, g, a, n), G = U8.GetPositionRewards(x, g, a, n);
            g.tokenFeeAmountA = Z0.gte(J0) && Z0.lt(j8) ? Z0 : J0, g.tokenFeeAmountB = _.gte(J0) && Z0.lt(j8) ? _ : J0;
            for (let v = 0;v < G.length; v++)
              g.rewardInfos[v].pendingReward = G[v].gte(J0) && G[v].lt(j8) ? G[v] : J0;
          }
        }
      }
    }
    if (C.length > 0) {
      const q = C.map((O) => O.tokenVault), K = await J$(J, q, { batchRequest: W }), w2 = {};
      for (let O = 0;O < q.length; O++) {
        const h2 = q[O].toString(), b = K[O];
        if (b === null)
          continue;
        const N = $$.decode(b.data);
        w2[h2] = N.amount;
      }
      for (let O of C) {
        const h2 = w2[O.tokenVault.toString()];
        O.remainingRewards = h2 !== undefined ? h2.sub(O.rewardTotalEmissioned.sub(O.rewardClaimed)) : J0;
      }
    }
    return U;
  }
  static async fetchMultiplePoolTickArrays({ connection: J, poolKeys: $, batchRequest: H }) {
    const Q = {}, W = [];
    for (let z of $) {
      const j = v0.getTickArrayStartIndexByTick(z.tickCurrent, z.tickSpacing), V = v0.getInitializedTickArrayInRange(z.tickArrayBitmap, z.exBitmapInfo, z.tickSpacing, j, 7);
      for (let U of V) {
        const { publicKey: C } = m0(z.programId, z.id, U);
        W.push({ pubkey: C }), Q[C.toString()] = z.id;
      }
    }
    const Z = await FH(J, W, { batchRequest: H }), Y = {};
    for (let z of Z) {
      if (!z.accountInfo)
        continue;
      const j = Q[z.pubkey.toString()];
      if (!j)
        continue;
      if (Y[j.toString()] === undefined)
        Y[j.toString()] = {};
      const V = jQ.decode(z.accountInfo.data);
      Y[j.toString()][V.startTickIndex] = { ...V, address: z.pubkey };
    }
    return Y;
  }
  static async fetchExBitmaps({ connection: J, exBitmapAddress: $, batchRequest: H }) {
    const Q = await FH(J, $.map((Z) => ({ pubkey: Z })), { batchRequest: H }), W = {};
    for (let Z of Q) {
      if (Z.accountInfo === null)
        continue;
      W[Z.pubkey.toString()] = AY.decode(Z.accountInfo.data);
    }
    return W;
  }
  static async getWhiteListMint({ connection: J, programId: $ }) {
    const H = await J.getAccountInfo(G8($).publicKey);
    if (!H)
      return [];
    return xY.decode(H.data).whitelistMints.filter((W) => !W.equals($PublicKey.default));
  }
}
var IY = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin";
var Vj = new $PublicKey(IY);
var mY = { [IY]: 3 };
var dY = { 3: Vj };
var $W = e([p0(5), p0(8), c("ownAddress"), P("vaultSignerNonce"), c("baseMint"), c("quoteMint"), c("baseVault"), P("baseDepositsTotal"), P("baseFeesAccrued"), c("quoteVault"), P("quoteDepositsTotal"), P("quoteFeesAccrued"), P("quoteDustThreshold"), c("requestQueue"), c("eventQueue"), c("bids"), c("asks"), P("baseLotSize"), P("quoteLotSize"), P("feeRateBps"), P("referrerRebatesAccrued"), p0(7)]);
var pY = { 3: $W };
var q8 = U0.from("Serum");

class v8 {
  static getProgramId(J) {
    const $ = dY[J];
    return q8.assertArgument(!!$, "invalid version", "version", J), $;
  }
  static getVersion(J) {
    const $ = J.toBase58(), H = mY[$];
    return q8.assertArgument(!!H, "invalid program id", "programId", $), H;
  }
  static getStateLayout(J) {
    const $ = pY[J];
    return q8.assertArgument(!!$, "invalid version", "version", J), $;
  }
  static getLayouts(J) {
    return { state: this.getStateLayout(J) };
  }
  static getAssociatedAuthority({ programId: J, marketId: $ }) {
    const H = [$.toBuffer()];
    let Q = 0, W;
    while (Q < 100) {
      try {
        const Z = H.concat(Buffer.from([Q]), Buffer.alloc(7));
        W = $PublicKey.createProgramAddressSync(Z, J);
      } catch (Z) {
        if (Z instanceof TypeError)
          throw Z;
        Q++;
        continue;
      }
      return { publicKey: W, nonce: Q };
    }
    return q8.throwArgumentError("unable to find a viable program address nonce", "params", { programId: J, marketId: $ });
  }
}
var Dj = function(J, $) {
  return [0, RH - 2];
};
var qj = function(J) {
  return [0, RH - 2];
};
var vj = function(J) {
  return [0, RH - 2];
};
var Cj = function(J, $, H) {
  const [Q, W] = Dj($, H);
  let Z = Q, Y = W, z = 0;
  const j = $ * J.multiplier / H;
  while (Z <= Y) {
    if (z = Math.floor((Y + Z) / 2), z === 0 || z >= RH - 2)
      return [z, z, false];
    const V = J.DataElement[z].x * J.multiplier / J.DataElement[z].y, U = J.DataElement[z - 1].x * J.multiplier / J.DataElement[z - 1].y, C = J.DataElement[z + 1].x * J.multiplier / J.DataElement[z + 1].y;
    if (j === V)
      return [z, z, true];
    else if (j === U)
      return [z - 1, z - 1, true];
    else if (j === C)
      return [z + 1, z + 1, true];
    else if (j < U)
      Y = z - 1;
    else if (j > U && j < V)
      return [z - 1, z, true];
    else if (j > V && j < C)
      return [z, z + 1, true];
    else
      Z = z + 1;
  }
  return [z, z, false];
};
var HW = function(J, $, H) {
  const [Q, W, Z] = Cj(J, $, H);
  if (!Z)
    return 0;
  if (Q === W) {
    const Y = J.DataElement[Q].x;
    return $ * J.multiplier / Y;
  } else {
    const Y = J.DataElement[Q].x, z = J.DataElement[Q].y, j = J.DataElement[W].x, V = J.DataElement[W].y, U = H * (j * z - Y * V), C = Y * U, q = (j - Y) * ($ * z - Y * H) * V, K = C + q;
    return $ * J.multiplier * U / K;
  }
};
var CH = function(J, $, H) {
  return $ * J.multiplier / H;
};
var lY = function(J, $, H) {
  return $ * H / J.multiplier;
};
var Rj = function(J, $) {
  const [H, Q] = qj($);
  let W = H, Z = Q, Y = 0;
  const z = $;
  while (W < Z) {
    if (Y = Math.floor((Z + W) / 2), Y <= 0 || Y > RH - 2)
      return [Y, Y, false];
    const j = J.DataElement[Y].x, V = J.DataElement[Y - 1].x, U = J.DataElement[Y + 1].x;
    if (z === j)
      return [Y, Y, true];
    else if (z === V)
      return [Y - 1, Y - 1, true];
    else if (z === U)
      return [Y + 1, Y + 1, true];
    else if (z < V)
      Z = Y - 1;
    else if (z > V && z < j)
      return [Y - 1, Y, true];
    else if (z > j && z < U)
      return [Y, Y + 1, true];
    else
      W = Y + 1;
  }
  return [Y, Y, false];
};
var Bj = function(J, $) {
  const [H, Q] = vj($);
  let W = H, Z = Q, Y = 0;
  const z = $;
  while (W <= Z) {
    if (Y = Math.floor((Z + W) / 2), Y <= 0 || Y >= RH - 2)
      return [Y, Y, false];
    const j = J.DataElement[Y].y, V = J.DataElement[Y - 1].y, U = J.DataElement[Y + 1].y;
    if (z === j)
      return [Y, Y, true];
    else if (z === V)
      return [Y - 1, Y - 1, true];
    else if (z === U)
      return [Y + 1, Y + 1, true];
    else if (z < U)
      W = Y + 1;
    else if (z < V && z > j)
      return [Y - 1, Y, true];
    else if (z < j && z > U)
      return [Y, Y + 1, true];
    else
      Z = Y - 1;
  }
  return [Y, Y, false];
};
var uY = function(J, $, H, Q) {
  const W = Q ? $ + H : $ - H, [Z, Y, z] = Rj(J, W);
  if (!z)
    return [0, 0, false, z];
  if (Z === Y)
    return [J.DataElement[Y].price, J.DataElement[Y].y, false, z];
  else {
    const j = J.DataElement[Z].x, V = J.DataElement[Y].x, U = J.DataElement[Z].price, C = J.DataElement[Y].price, q = J.DataElement[Z].y, K = J.DataElement[Y].y;
    if ($ >= j && $ <= V)
      if (Q)
        return [C, K, true, z];
      else
        return [U, q, true, z];
    else {
      let w2, O;
      if (Q)
        w2 = U + (C - U) * ($ - j) / (V - j), O = q - (W - j) * J.multiplier / C;
      else
        w2 = U + (C - U) * ($ - j) / (V - j), O = K + (V - W) * J.multiplier / U;
      return [w2, O, false, z];
    }
  }
};
var Mj = function(J, $, H, Q) {
  const W = Q ? $ - H : $ + H, [Z, Y, z] = Bj(J, W);
  if (!z)
    return [0, 0, false, z];
  if (Z === Y)
    return [J.DataElement[Y].price, J.DataElement[Y].x, false, z];
  else {
    const j = J.DataElement[Z].x, V = J.DataElement[Y].x, U = J.DataElement[Z].price, C = J.DataElement[Y].price, q = J.DataElement[Z].y, K = J.DataElement[Y].y;
    if ($ >= K && $ <= q)
      return Q ? [C, V, true, z] : [U, j, true, z];
    else {
      let w2, O;
      if (Q)
        w2 = U + (C - U) * (q - $) / (q - K), O = j + C * (q - W) / J.multiplier;
      else
        w2 = U + (C - U) * (q - $) / (q - K), O = V - U * (W - K) / J.multiplier;
      return [w2, O, false, z];
    }
  }
};
var Oj = function(J, $) {
  const H = uY(J, $, 0, false);
  if (H[3])
    return H[0];
  else
    return 0;
};
var yH = new $PublicKey("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo");
var RH = 50000;
var Xj = e([P("x"), P("y"), P("price")]);
var Uj = e([P("accountType"), P("status"), P("multiplier"), P("validDataCount"), z0(Xj, RH, "DataElement")]);
var GQ;
var W0 = U0.from("Liquidity");
var FQ = { accountType: 0, status: 0, multiplier: 0, validDataCount: 0, DataElement: [] };
var E$;
(function(J) {
  J[J.Uninitialized = 0] = "Uninitialized", J[J.Initialized = 1] = "Initialized", J[J.Disabled = 2] = "Disabled", J[J.RemoveLiquidityOnly = 3] = "RemoveLiquidityOnly", J[J.LiquidityOnly = 4] = "LiquidityOnly", J[J.OrderBook = 5] = "OrderBook", J[J.Swap = 6] = "Swap", J[J.WaitingForStart = 7] = "WaitingForStart";
})(E$ || (E$ = {}));
var nY = new TJ.default(25);
var QW = new TJ.default(1e4);

class S$ extends V$ {
  static getStateLayout(J) {
    const $ = m6[J];
    return W0.assertArgument(!!$, "invalid version", "version", J), $;
  }
  static getLayouts(J) {
    return { state: this.getStateLayout(J) };
  }
  static getAssociatedId({ programId: J, marketId: $ }) {
    const { publicKey: H } = h0([J.toBuffer(), $.toBuffer(), Buffer.from("amm_associated_seed", "utf-8")], J);
    return H;
  }
  static getAssociatedAuthority({ programId: J }) {
    return h0([Buffer.from([97, 109, 109, 32, 97, 117, 116, 104, 111, 114, 105, 116, 121])], J);
  }
  static getAssociatedBaseVault({ programId: J, marketId: $ }) {
    const { publicKey: H } = h0([J.toBuffer(), $.toBuffer(), Buffer.from("coin_vault_associated_seed", "utf-8")], J);
    return H;
  }
  static getAssociatedQuoteVault({ programId: J, marketId: $ }) {
    const { publicKey: H } = h0([J.toBuffer(), $.toBuffer(), Buffer.from("pc_vault_associated_seed", "utf-8")], J);
    return H;
  }
  static getAssociatedLpMint({ programId: J, marketId: $ }) {
    const { publicKey: H } = h0([J.toBuffer(), $.toBuffer(), Buffer.from("lp_mint_associated_seed", "utf-8")], J);
    return H;
  }
  static getAssociatedLpVault({ programId: J, marketId: $ }) {
    const { publicKey: H } = h0([J.toBuffer(), $.toBuffer(), Buffer.from("temp_lp_token_associated_seed", "utf-8")], J);
    return H;
  }
  static getAssociatedTargetOrders({ programId: J, marketId: $ }) {
    const { publicKey: H } = h0([J.toBuffer(), $.toBuffer(), Buffer.from("target_associated_seed", "utf-8")], J);
    return H;
  }
  static getAssociatedWithdrawQueue({ programId: J, marketId: $ }) {
    const { publicKey: H } = h0([J.toBuffer(), $.toBuffer(), Buffer.from("withdraw_associated_seed", "utf-8")], J);
    return H;
  }
  static getAssociatedOpenOrders({ programId: J, marketId: $ }) {
    const { publicKey: H } = h0([J.toBuffer(), $.toBuffer(), Buffer.from("open_order_associated_seed", "utf-8")], J);
    return H;
  }
  static getAssociatedConfigId({ programId: J }) {
    const { publicKey: $ } = h0([Buffer.from("amm_config_account_seed", "utf-8")], J);
    return $;
  }
  static getAssociatedPoolKeys({ version: J, marketVersion: $, marketId: H, baseMint: Q, quoteMint: W, baseDecimals: Z, quoteDecimals: Y, programId: z, marketProgramId: j }) {
    const V = this.getAssociatedId({ programId: z, marketId: H }), U = this.getAssociatedLpMint({ programId: z, marketId: H }), { publicKey: C, nonce: q } = this.getAssociatedAuthority({ programId: z }), K = this.getAssociatedBaseVault({ programId: z, marketId: H }), w2 = this.getAssociatedQuoteVault({ programId: z, marketId: H }), O = this.getAssociatedLpVault({ programId: z, marketId: H }), h2 = this.getAssociatedOpenOrders({ programId: z, marketId: H }), b = this.getAssociatedTargetOrders({ programId: z, marketId: H }), N = this.getAssociatedWithdrawQueue({ programId: z, marketId: H }), { publicKey: x } = v8.getAssociatedAuthority({ programId: j, marketId: H });
    return { id: V, baseMint: Q, quoteMint: W, lpMint: U, baseDecimals: Z, quoteDecimals: Y, lpDecimals: Z, version: J, programId: z, authority: C, nonce: q, baseVault: K, quoteVault: w2, lpVault: O, openOrders: h2, targetOrders: b, withdrawQueue: N, marketVersion: $, marketProgramId: j, marketId: H, marketAuthority: x, lookupTableAccount: $PublicKey.default, configId: this.getAssociatedConfigId({ programId: z }) };
  }
  static async getCreatePoolFee({ connection: J, programId: $ }) {
    const H = this.getAssociatedConfigId({ programId: $ }), Q = e([P("fee")]), W = await J.getAccountInfo(H, { dataSlice: { offset: 536, length: 8 } });
    if (W === null)
      throw Error("get config account error");
    return Q.decode(W.data).fee;
  }
  static makeAddLiquidityInstruction(J) {
    const { poolKeys: $, userKeys: H, baseAmountIn: Q, quoteAmountIn: W, fixedSide: Z } = J, { version: Y } = $;
    if (Y === 4 || Y === 5) {
      const z = e([o("instruction"), P("baseAmountIn"), P("quoteAmountIn"), P("fixedSide")]), j = Buffer.alloc(z.span);
      z.encode({ instruction: 3, baseAmountIn: H0(Q), quoteAmountIn: H0(W), fixedSide: H0(Z === "base" ? 0 : 1) }, j);
      const V = [d2(m2, false), y2($.id, false), d2($.authority, false), d2($.openOrders, false), y2($.targetOrders, false), y2($.lpMint, false), y2($.baseVault, false), y2($.quoteVault, false)];
      if (Y === 5)
        V.push(y2(yH, false));
      return V.push(d2($.marketId, false), y2(H.baseTokenAccount, false), y2(H.quoteTokenAccount, false), y2(H.lpTokenAccount, false), d2(H.owner, true), d2($.marketEventQueue, false)), { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: $.programId, keys: V, data: j })], signers: [], lookupTableAddress: [$.lookupTableAccount].filter((U) => U && !U.equals($PublicKey.default)), instructionTypes: [Y === 4 ? $0.ammV4AddLiquidity : $0.ammV5AddLiquidity] } };
    }
    return W0.throwArgumentError("invalid version", "poolKeys.version", Y);
  }
  static async makeAddLiquidityInstructionSimple(J) {
    const { connection: $, poolKeys: H, userKeys: Q, amountInA: W, amountInB: Z, fixedSide: Y, config: z, makeTxVersion: j, lookupTableCache: V, computeBudgetConfig: U } = J, { lpMint: C } = H, { tokenAccounts: q, owner: K, payer: w2 = K } = Q;
    W0.debug("amountInA:", W), W0.debug("amountInB:", Z), W0.assertArgument(!W.isZero() && !Z.isZero(), "amounts must greater than zero", "amountInA & amountInB", { amountInA: W.toFixed(), amountInB: Z.toFixed() });
    const { bypassAssociatedCheck: O, checkCreateATAOwner: h2 } = { ...{ bypassAssociatedCheck: false, checkCreateATAOwner: false }, ...z }, b = W instanceof O0 ? W.token : r.WSOL, N = Z instanceof O0 ? Z.token : r.WSOL, x = this._selectTokenAccount({ programId: m2, tokenAccounts: q, mint: b.mint, owner: K, config: { associatedOnly: false } }), k = this._selectTokenAccount({ programId: m2, tokenAccounts: q, mint: N.mint, owner: K, config: { associatedOnly: false } });
    W0.assertArgument(!!x || !!k, "cannot found target token accounts", "tokenAccounts", q);
    const g = this._selectTokenAccount({ programId: m2, tokenAccounts: q, mint: C, owner: K }), A = [b, N], I = [x, k], T = [W.raw, Z.raw], [u] = this._getAmountsSide(W, Z, H);
    let a = "base";
    if (u === "quote")
      if (A.reverse(), I.reverse(), T.reverse(), Y === "a")
        a = "quote";
      else if (Y === "b")
        a = "base";
      else
        return W0.throwArgumentError("invalid fixedSide", "fixedSide", Y);
    else if (u === "base")
      if (Y === "a")
        a = "base";
      else if (Y === "b")
        a = "quote";
      else
        return W0.throwArgumentError("invalid fixedSide", "fixedSide", Y);
    else
      return W0.throwArgumentError("invalid fixedSide", "fixedSide", Y);
    const [n, Z0] = A, [_, G] = I, [v, X] = T, D = [], M = [], L = [], S = [], R = [], F = await this._handleTokenAccount({ programId: m2, connection: $, side: "in", amount: v, mint: n.mint, tokenAccount: _, owner: K, payer: w2, frontInstructions: D, endInstructions: M, signers: R, bypassAssociatedCheck: O, frontInstructionsType: L, endInstructionsType: S, checkCreateATAOwner: h2 }), E = await this._handleTokenAccount({ programId: m2, connection: $, side: "in", amount: X, mint: Z0.mint, tokenAccount: G, owner: K, payer: w2, frontInstructions: D, endInstructions: M, signers: R, bypassAssociatedCheck: O, frontInstructionsType: L, endInstructionsType: S, checkCreateATAOwner: h2 }), f = await this._handleTokenAccount({ programId: m2, connection: $, side: "out", amount: 0, mint: C, tokenAccount: g, owner: K, payer: w2, frontInstructions: D, endInstructions: M, signers: R, bypassAssociatedCheck: O, frontInstructionsType: L, endInstructionsType: S, checkCreateATAOwner: h2 }), l = this.makeAddLiquidityInstruction({ poolKeys: H, userKeys: { baseTokenAccount: F, quoteTokenAccount: E, lpTokenAccount: f, owner: K }, baseAmountIn: v, quoteAmountIn: X, fixedSide: a });
    return { address: { lpTokenAccount: f }, innerTransactions: await L0({ connection: $, makeTxVersion: j, computeBudgetConfig: U, payer: w2, innerTransaction: [{ instructionTypes: L, instructions: D, signers: R }, l.innerTransaction, { instructionTypes: S, instructions: M, signers: [] }], lookupTableCache: V }) };
  }
  static makeRemoveLiquidityInstruction(J) {
    const { poolKeys: $, userKeys: H, amountIn: Q } = J, { version: W } = $;
    if (W === 4 || W === 5) {
      const Z = e([o("instruction"), P("amountIn")]), Y = Buffer.alloc(Z.span);
      Z.encode({ instruction: 4, amountIn: H0(Q) }, Y);
      const z = [d2(m2, false), y2($.id, false), d2($.authority, false), y2($.openOrders, false), y2($.targetOrders, false), y2($.lpMint, false), y2($.baseVault, false), y2($.quoteVault, false)];
      if (W === 5)
        z.push(y2(yH, false));
      else
        z.push(y2($.withdrawQueue, false)), z.push(y2($.lpVault, false));
      return z.push(d2($.marketProgramId, false), y2($.marketId, false), y2($.marketBaseVault, false), y2($.marketQuoteVault, false), d2($.marketAuthority, false), y2(H.lpTokenAccount, false), y2(H.baseTokenAccount, false), y2(H.quoteTokenAccount, false), d2(H.owner, true), y2($.marketEventQueue, false), y2($.marketBids, false), y2($.marketAsks, false)), { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: $.programId, keys: z, data: Y })], signers: [], lookupTableAddress: [$.lookupTableAccount].filter((j) => j && !j.equals($PublicKey.default)), instructionTypes: [W === 4 ? $0.ammV4RemoveLiquidity : $0.ammV5RemoveLiquidity] } };
    }
    return W0.throwArgumentError("invalid version", "poolKeys.version", W);
  }
  static async makeRemoveLiquidityInstructionSimple(J) {
    const { connection: $, poolKeys: H, userKeys: Q, amountIn: W, config: Z, makeTxVersion: Y, lookupTableCache: z, computeBudgetConfig: j } = J, { baseMint: V, quoteMint: U, lpMint: C } = H, { tokenAccounts: q, owner: K, payer: w2 = K } = Q;
    W0.debug("amountIn:", W), W0.assertArgument(!W.isZero(), "amount must greater than zero", "amountIn", W.toFixed()), W0.assertArgument(W instanceof O0 && W.token.mint.equals(C), "amountIn's token not match lpMint", "amountIn", W);
    const O = this._selectTokenAccount({ programId: m2, tokenAccounts: q, mint: C, owner: K, config: { associatedOnly: false } });
    if (!O)
      return W0.throwArgumentError("cannot found lpTokenAccount", "tokenAccounts", q);
    const h2 = this._selectTokenAccount({ programId: m2, tokenAccounts: q, mint: V, owner: K }), b = this._selectTokenAccount({ programId: m2, tokenAccounts: q, mint: U, owner: K }), { bypassAssociatedCheck: N, checkCreateATAOwner: x } = { ...{ bypassAssociatedCheck: false, checkCreateATAOwner: false }, ...Z }, k = [], g = [], A = [], I = [], T = [], u = O, a = await this._handleTokenAccount({ programId: m2, connection: $, side: "out", amount: 0, mint: V, tokenAccount: h2, owner: K, payer: w2, frontInstructions: k, endInstructions: g, signers: T, bypassAssociatedCheck: N, frontInstructionsType: A, checkCreateATAOwner: x }), n = await this._handleTokenAccount({ programId: m2, connection: $, side: "out", amount: 0, mint: U, tokenAccount: b, owner: K, payer: w2, frontInstructions: k, endInstructions: g, signers: T, bypassAssociatedCheck: N, frontInstructionsType: A, checkCreateATAOwner: x }), Z0 = this.makeRemoveLiquidityInstruction({ poolKeys: H, userKeys: { lpTokenAccount: u, baseTokenAccount: a, quoteTokenAccount: n, owner: K }, amountIn: W.raw });
    return { address: { lpTokenAccount: u }, innerTransactions: await L0({ connection: $, makeTxVersion: Y, computeBudgetConfig: j, payer: w2, innerTransaction: [{ instructionTypes: A, instructions: k, signers: T }, Z0.innerTransaction, { instructionTypes: I, instructions: g, signers: [] }], lookupTableCache: z }) };
  }
  static makeSwapInstruction(J) {
    const { poolKeys: $, userKeys: H, amountIn: Q, amountOut: W, fixedSide: Z } = J, { version: Y } = $;
    if (Y === 4 || Y === 5) {
      if (Z === "in")
        return this.makeSwapFixedInInstruction({ poolKeys: $, userKeys: H, amountIn: Q, minAmountOut: W }, Y);
      else if (Z === "out")
        return this.makeSwapFixedOutInstruction({ poolKeys: $, userKeys: H, maxAmountIn: Q, amountOut: W }, Y);
      return W0.throwArgumentError("invalid params", "params", J);
    }
    return W0.throwArgumentError("invalid version", "poolKeys.version", Y);
  }
  static makeSwapFixedInInstruction({ poolKeys: J, userKeys: $, amountIn: H, minAmountOut: Q }, W) {
    const Z = e([o("instruction"), P("amountIn"), P("minAmountOut")]), Y = Buffer.alloc(Z.span);
    Z.encode({ instruction: 9, amountIn: H0(H), minAmountOut: H0(Q) }, Y);
    const z = [d2(m2, false), y2(J.id, false), d2(J.authority, false), y2(J.openOrders, false)];
    if (W === 4)
      z.push(y2(J.targetOrders, false));
    if (z.push(y2(J.baseVault, false), y2(J.quoteVault, false)), W === 5)
      z.push(y2(yH, false));
    return z.push(d2(J.marketProgramId, false), y2(J.marketId, false), y2(J.marketBids, false), y2(J.marketAsks, false), y2(J.marketEventQueue, false), y2(J.marketBaseVault, false), y2(J.marketQuoteVault, false), d2(J.marketAuthority, false), y2($.tokenAccountIn, false), y2($.tokenAccountOut, false), d2($.owner, true)), { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: z, data: Y })], signers: [], lookupTableAddress: [J.lookupTableAccount].filter((j) => j && !j.equals($PublicKey.default)), instructionTypes: [W === 4 ? $0.ammV4SwapBaseIn : $0.ammV5SwapBaseIn] } };
  }
  static makeSwapFixedOutInstruction({ poolKeys: J, userKeys: $, maxAmountIn: H, amountOut: Q }, W) {
    const Z = e([o("instruction"), P("maxAmountIn"), P("amountOut")]), Y = Buffer.alloc(Z.span);
    Z.encode({ instruction: 11, maxAmountIn: H0(H), amountOut: H0(Q) }, Y);
    const z = [d2(m2, false), y2(J.id, false), d2(J.authority, false), y2(J.openOrders, false), y2(J.targetOrders, false), y2(J.baseVault, false), y2(J.quoteVault, false)];
    if (W === 5)
      z.push(y2(yH, false));
    return z.push(d2(J.marketProgramId, false), y2(J.marketId, false), y2(J.marketBids, false), y2(J.marketAsks, false), y2(J.marketEventQueue, false), y2(J.marketBaseVault, false), y2(J.marketQuoteVault, false), d2(J.marketAuthority, false), y2($.tokenAccountIn, false), y2($.tokenAccountOut, false), d2($.owner, true)), { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: z, data: Y })], signers: [], lookupTableAddress: [J.lookupTableAccount].filter((j) => j && !j.equals($PublicKey.default)), instructionTypes: [W === 4 ? $0.ammV4SwapBaseOut : $0.ammV5SwapBaseOut] } };
  }
  static async makeSwapInstructionSimple(J) {
    const { connection: $, poolKeys: H, userKeys: Q, amountIn: W, amountOut: Z, fixedSide: Y, config: z, makeTxVersion: j, lookupTableCache: V, computeBudgetConfig: U } = J, { tokenAccounts: C, owner: q, payer: K = q } = Q;
    W0.debug("amountIn:", W), W0.debug("amountOut:", Z), W0.assertArgument(!W.isZero() && !Z.isZero(), "amounts must greater than zero", "currencyAmounts", { amountIn: W.toFixed(), amountOut: Z.toFixed() });
    const { bypassAssociatedCheck: w2, checkCreateATAOwner: O } = { ...{ bypassAssociatedCheck: false, checkCreateATAOwner: false }, ...z }, h2 = W instanceof O0 ? W.token : r.WSOL, b = Z instanceof O0 ? Z.token : r.WSOL, N = this._selectTokenAccount({ programId: m2, tokenAccounts: C, mint: h2.mint, owner: q, config: { associatedOnly: false } }), x = this._selectTokenAccount({ programId: m2, tokenAccounts: C, mint: b.mint, owner: q }), [k, g] = [W.raw, Z.raw], A = [], I = [], T = [], u = [], a = [], n = await this._handleTokenAccount({ programId: m2, connection: $, side: "in", amount: k, mint: h2.mint, tokenAccount: N, owner: q, payer: K, frontInstructions: A, endInstructions: I, signers: a, bypassAssociatedCheck: w2, frontInstructionsType: T, checkCreateATAOwner: O }), Z0 = await this._handleTokenAccount({ programId: m2, connection: $, side: "out", amount: 0, mint: b.mint, tokenAccount: x, owner: q, payer: K, frontInstructions: A, endInstructions: I, signers: a, bypassAssociatedCheck: w2, frontInstructionsType: T, checkCreateATAOwner: O }), _ = this.makeSwapInstruction({ poolKeys: H, userKeys: { tokenAccountIn: n, tokenAccountOut: Z0, owner: q }, amountIn: k, amountOut: g, fixedSide: Y });
    return { address: {}, innerTransactions: await L0({ connection: $, makeTxVersion: j, computeBudgetConfig: U, payer: K, innerTransaction: [{ instructionTypes: T, instructions: A, signers: a }, _.innerTransaction, { instructionTypes: u, instructions: I, signers: [] }], lookupTableCache: V }) };
  }
  static makeSimulatePoolInfoInstruction({ poolKeys: J }) {
    const $ = e([o("instruction"), o("simulateType")]), H = Buffer.alloc($.span);
    $.encode({ instruction: 12, simulateType: 0 }, H);
    const Q = [d2(J.id, false), d2(J.authority, false), d2(J.openOrders, false), d2(J.baseVault, false), d2(J.quoteVault, false), d2(J.lpMint, false), d2(J.marketId, false), d2(J.marketEventQueue, false)];
    return { address: {}, innerTransaction: { instructions: [new $TransactionInstruction({ programId: J.programId, keys: Q, data: H })], signers: [], lookupTableAddress: [J.lookupTableAccount].filter((W) => W && !W.equals($PublicKey.default)), instructionTypes: [J.version === 4 ? $0.ammV4SimulatePoolInfo : $0.ammV5SimulatePoolInfo] } };
  }
  static isV4(J) {
    return J.withdrawQueue !== undefined;
  }
  static async makeCreatePoolV4InstructionV2Simple({ connection: J, programId: $, marketInfo: H, baseMintInfo: Q, quoteMintInfo: W, baseAmount: Z, quoteAmount: Y, startTime: z, ownerInfo: j, associatedOnly: V = false, computeBudgetConfig: U, checkCreateATAOwner: C = false, makeTxVersion: q, lookupTableCache: K, feeDestinationId: w2 }) {
    const O = [], h2 = [], b = [], N = [], x = [], k = j.useSOLBalance && Q.mint.equals(r.WSOL.mint), g = j.useSOLBalance && W.mint.equals(r.WSOL.mint), A = await this._selectOrCreateTokenAccount({ programId: m2, mint: Q.mint, tokenAccounts: k ? [] : j.tokenAccounts, owner: j.wallet, createInfo: k ? { connection: J, payer: j.feePayer, amount: Z, frontInstructions: O, frontInstructionsType: b, endInstructions: k ? h2 : [], endInstructionsType: k ? N : [], signers: x } : undefined, associatedOnly: k ? false : V, checkCreateATAOwner: C }), I = await this._selectOrCreateTokenAccount({ programId: m2, mint: W.mint, tokenAccounts: g ? [] : j.tokenAccounts, owner: j.wallet, createInfo: g ? { connection: J, payer: j.feePayer, amount: Y, frontInstructions: O, frontInstructionsType: b, endInstructions: g ? h2 : [], endInstructionsType: g ? N : [], signers: x } : undefined, associatedOnly: g ? false : V, checkCreateATAOwner: C });
    if (A === undefined || I === undefined)
      throw Error("you don't has some token account");
    const T = GQ.getAssociatedPoolKeys({ version: 4, marketVersion: 3, marketId: H.marketId, baseMint: Q.mint, quoteMint: W.mint, baseDecimals: Q.decimals, quoteDecimals: W.decimals, programId: $, marketProgramId: H.programId }), u = this.makeCreatePoolV4InstructionV2({ programId: $, ammId: T.id, ammAuthority: T.authority, ammOpenOrders: T.openOrders, lpMint: T.lpMint, coinMint: T.baseMint, pcMint: T.quoteMint, coinVault: T.baseVault, pcVault: T.quoteVault, ammTargetOrders: T.targetOrders, marketProgramId: T.marketProgramId, marketId: T.marketId, userWallet: j.wallet, userCoinVault: A, userPcVault: I, userLpVault: n0(j.wallet, T.lpMint, m2).publicKey, ammConfigId: T.configId, feeDestinationId: w2, nonce: T.nonce, openTime: z, coinAmount: Z, pcAmount: Y }).innerTransaction;
    return { address: { programId: $, ammId: T.id, ammAuthority: T.authority, ammOpenOrders: T.openOrders, lpMint: T.lpMint, coinMint: T.baseMint, pcMint: T.quoteMint, coinVault: T.baseVault, pcVault: T.quoteVault, withdrawQueue: T.withdrawQueue, ammTargetOrders: T.targetOrders, poolTempLp: T.lpVault, marketProgramId: T.marketProgramId, marketId: T.marketId }, innerTransactions: await L0({ connection: J, makeTxVersion: q, computeBudgetConfig: U, payer: j.feePayer, innerTransaction: [{ instructionTypes: b, instructions: O, signers: x }, u, { instructionTypes: N, instructions: h2, signers: [] }], lookupTableCache: K }) };
  }
  static makeCreatePoolV4InstructionV2({ programId: J, ammId: $, ammAuthority: H, ammOpenOrders: Q, lpMint: W, coinMint: Z, pcMint: Y, coinVault: z, pcVault: j, ammTargetOrders: V, marketProgramId: U, marketId: C, userWallet: q, userCoinVault: K, userPcVault: w2, userLpVault: O, nonce: h2, openTime: b, coinAmount: N, pcAmount: x, lookupTableAddress: k, ammConfigId: g, feeDestinationId: A }) {
    const I = e([o("instruction"), o("nonce"), P("openTime"), P("pcAmount"), P("coinAmount")]), T = [{ pubkey: m2, isSigner: false, isWritable: false }, { pubkey: tJ, isSigner: false, isWritable: false }, { pubkey: t0, isSigner: false, isWritable: false }, { pubkey: v$, isSigner: false, isWritable: false }, { pubkey: $, isSigner: false, isWritable: true }, { pubkey: H, isSigner: false, isWritable: false }, { pubkey: Q, isSigner: false, isWritable: true }, { pubkey: W, isSigner: false, isWritable: true }, { pubkey: Z, isSigner: false, isWritable: false }, { pubkey: Y, isSigner: false, isWritable: false }, { pubkey: z, isSigner: false, isWritable: true }, { pubkey: j, isSigner: false, isWritable: true }, { pubkey: V, isSigner: false, isWritable: true }, { pubkey: g, isSigner: false, isWritable: false }, { pubkey: A, isSigner: false, isWritable: true }, { pubkey: U, isSigner: false, isWritable: false }, { pubkey: C, isSigner: false, isWritable: false }, { pubkey: q, isSigner: true, isWritable: true }, { pubkey: K, isSigner: false, isWritable: true }, { pubkey: w2, isSigner: false, isWritable: true }, { pubkey: O, isSigner: false, isWritable: true }], u = Buffer.alloc(I.span);
    I.encode({ instruction: 1, nonce: h2, openTime: b, coinAmount: N, pcAmount: x }, u);
    const a = new $TransactionInstruction({ keys: T, programId: J, data: u });
    return { address: {}, innerTransaction: { instructions: [a], signers: [], lookupTableAddress: k ? [k] : undefined, instructionTypes: [$0.ammV4CreatePoolV2] } };
  }
  static async makeRemoveAllLpAndCreateClmmPosition({ connection: J, poolKeys: $, removeLpAmount: H, userKeys: Q, clmmPoolKeys: W, createPositionInfo: Z, farmInfo: Y, computeBudgetConfig: z, checkCreateATAOwner: j = false, getEphemeralSigners: V, makeTxVersion: U, lookupTableCache: C }) {
    if (!($.baseMint.equals(W.mintA.mint) || $.baseMint.equals(W.mintB.mint)))
      throw Error("mint check error");
    if (!($.quoteMint.equals(W.mintA.mint) || $.quoteMint.equals(W.mintB.mint)))
      throw Error("mint check error");
    const q = [], K = [], w2 = [], O = [], h2 = [], b = {};
    for (let _ of Q.tokenAccounts)
      if (b[_.accountInfo.mint.toString()] === undefined || n0(Q.owner, _.accountInfo.mint, m2).publicKey.equals(_.pubkey))
        b[_.accountInfo.mint.toString()] = _.pubkey;
    const N = b[$.lpMint.toString()];
    if (N === undefined)
      throw Error("find lp account error in trade accounts");
    const x = H.add(Y?.amount ?? new TJ.default(0)), k = $.baseMint.equals(r.WSOL.mint), g = $.quoteMint.equals(r.WSOL.mint), A = await this._selectOrCreateTokenAccount({ programId: m2, mint: $.baseMint, tokenAccounts: Q.tokenAccounts, owner: Q.owner, createInfo: { connection: J, payer: Q.payer ?? Q.owner, frontInstructions: q, frontInstructionsType: w2, endInstructions: k ? K : [], endInstructionsType: k ? O : [], signers: h2 }, associatedOnly: true, checkCreateATAOwner: j }), I = await this._selectOrCreateTokenAccount({ programId: m2, mint: $.quoteMint, tokenAccounts: Q.tokenAccounts, owner: Q.owner, createInfo: { connection: J, payer: Q.payer ?? Q.owner, amount: 0, frontInstructions: q, frontInstructionsType: w2, endInstructions: g ? K : [], endInstructionsType: g ? O : [], signers: h2 }, associatedOnly: true, checkCreateATAOwner: j });
    b[$.baseMint.toString()] = A, b[$.quoteMint.toString()] = I;
    const T = this.makeRemoveLiquidityInstruction({ poolKeys: $, userKeys: { lpTokenAccount: N, baseTokenAccount: A, quoteTokenAccount: I, owner: Q.owner }, amountIn: x }), [u, a] = $.baseMint.equals(W.mintA.mint) ? [A, I] : [I, A], n = await D8.makeOpenPositionFromLiquidityInstructions({ poolInfo: W, ownerInfo: { feePayer: Q.payer ?? Q.owner, wallet: Q.owner, tokenAccountA: u, tokenAccountB: a }, withMetadata: "create", ...Z, getEphemeralSigners: V });
    let Z0 = { instructions: [], signers: [], instructionTypes: [] };
    if (Y !== undefined) {
      const _ = [];
      for (let G of Y.poolKeys.rewardInfos) {
        const v = G.rewardMint.equals(r.WSOL.mint);
        _.push(b[G.rewardMint.toString()] ?? await this._selectOrCreateTokenAccount({ programId: m2, mint: G.rewardMint, tokenAccounts: Q.tokenAccounts, owner: Q.owner, createInfo: { connection: J, payer: Q.payer ?? Q.owner, frontInstructions: q, frontInstructionsType: w2, endInstructions: v ? K : [], endInstructionsType: v ? O : [], signers: h2 }, associatedOnly: true, checkCreateATAOwner: j }));
      }
      Z0 = aJ.makeWithdrawInstruction({ poolKeys: Y.poolKeys, amount: Y.amount, userKeys: { ledger: aJ.getAssociatedLedgerAccount({ programId: Y.poolKeys.programId, poolId: Y.poolKeys.id, owner: Q.owner, version: Y.poolKeys.version }), lpTokenAccount: N, rewardTokenAccounts: _, owner: Q.owner } }).innerTransaction;
    }
    return { address: { ...T.address, ...n.address }, innerTransactions: await L0({ connection: J, makeTxVersion: U, computeBudgetConfig: z, payer: Q.payer ?? Q.owner, innerTransaction: [{ instructionTypes: w2, instructions: q, signers: h2 }, Z0, T.innerTransaction, n.innerTransaction, { instructionTypes: O, instructions: K, signers: [] }], lookupTableCache: C }) };
  }
  static async fetchAllPoolKeys(J, $, H) {
    const Q = (await Promise.all(Object.entries(m6).map(([j, V]) => {
      try {
        return J.getProgramAccounts($[Number(j)], { filters: [{ dataSize: V.span }] }).then((U) => {
          return U.map((C) => {
            return { id: C.pubkey, version: Number(j), programId: $[Number(j)], ...V.decode(C.account.data) };
          });
        });
      } catch (U) {
        if (U instanceof Error)
          return W0.throwError("failed to fetch pool info", U0.errors.RPC_ERROR, { message: U.message });
      }
    }))).flat(), W = Q.map((j) => j.marketId), Z = {};
    try {
      const j = await J$(J, W, H);
      for (let V of j) {
        if (V === null)
          continue;
        const U = { programId: V.owner, ...$W.decode(V.data) };
        Z[U.ownAddress.toString()] = U;
      }
    } catch (j) {
      if (j instanceof Error)
        return W0.throwError("failed to fetch markets", U0.errors.RPC_ERROR, { message: j.message });
    }
    const Y = {};
    for (let [j, V] of Object.entries($))
      Y[j] = this.getAssociatedAuthority({ programId: V }).publicKey;
    const z = [];
    for (let j of Q) {
      if (j === undefined)
        continue;
      if (j.baseMint.equals($PublicKey.default))
        continue;
      const V = Z[j.marketId.toString()], U = V.programId;
      z.push({ id: j.id, baseMint: j.baseMint, quoteMint: j.quoteMint, lpMint: j.lpMint, baseDecimals: j.baseDecimal.toNumber(), quoteDecimals: j.quoteDecimal.toNumber(), lpDecimals: j.id.toString() === "6kmMMacvoCKBkBrqssLEdFuEZu2wqtLdNQxh9VjtzfwT" ? 5 : j.baseDecimal.toNumber(), version: j.version, programId: j.programId, authority: Y[j.version], openOrders: j.openOrders, targetOrders: j.targetOrders, baseVault: j.baseVault, quoteVault: j.quoteVault, marketVersion: 3, marketProgramId: U, marketId: V.ownAddress, marketAuthority: v8.getAssociatedAuthority({ programId: U, marketId: V.ownAddress }).publicKey, marketBaseVault: V.baseVault, marketQuoteVault: V.quoteVault, marketBids: V.bids, marketAsks: V.asks, marketEventQueue: V.eventQueue, ...j.version === 5 ? { modelDataAccount: j.modelDataAccount, withdrawQueue: $PublicKey.default, lpVault: $PublicKey.default } : { withdrawQueue: j.withdrawQueue, lpVault: j.lpVault }, lookupTableAccount: $PublicKey.default });
    }
    return z;
  }
  static async fetchInfo({ connection: J, poolKeys: $ }) {
    const H = await this.fetchMultipleInfo({ connection: J, pools: [$] });
    return W0.assertArgument(H.length === 1, `fetchInfo failed, ${H.length} pools found`, "poolKeys.id", $.id), H[0];
  }
  static async fetchMultipleInfo({ connection: J, pools: $, config: H }) {
    await rY(J);
    const Q = $.map((Y) => this.makeSimulatePoolInfoInstruction({ poolKeys: Y }));
    return (await M6(J, Q.map((Y) => Y.innerTransaction.instructions).flat(), "GetPoolData")).map((Y) => {
      const z = O6(Y, "GetPoolData"), j = new TJ.default(C$(z, "status")), V = Number(C$(z, "coin_decimals")), U = Number(C$(z, "pc_decimals")), C = Number(C$(z, "lp_decimals")), q = new TJ.default(C$(z, "pool_coin_amount")), K = new TJ.default(C$(z, "pool_pc_amount")), w2 = new TJ.default(C$(z, "pool_lp_supply"));
      let O = "0";
      try {
        O = C$(z, "pool_open_time");
      } catch (h2) {
      }
      return { status: j, baseDecimals: V, quoteDecimals: U, lpDecimals: C, baseReserve: q, quoteReserve: K, lpSupply: w2, startTime: new TJ.default(O) };
    });
  }
  static getEnabledFeatures(J) {
    const { status: $ } = J, H = $.toNumber();
    if (H === E$.Uninitialized)
      return { swap: false, addLiquidity: false, removeLiquidity: false };
    else if (H === E$.Initialized)
      return { swap: true, addLiquidity: true, removeLiquidity: true };
    else if (H === E$.Disabled)
      return { swap: false, addLiquidity: false, removeLiquidity: false };
    else if (H === E$.RemoveLiquidityOnly)
      return { swap: false, addLiquidity: false, removeLiquidity: true };
    else if (H === E$.LiquidityOnly)
      return { swap: false, addLiquidity: true, removeLiquidity: true };
    else if (H === E$.OrderBook)
      return { swap: false, addLiquidity: true, removeLiquidity: true };
    else if (H === E$.Swap)
      return { swap: true, addLiquidity: true, removeLiquidity: true };
    else if (H === E$.WaitingForStart) {
      const { startTime: Q } = J;
      if (Date.now() / 1000 < Q.toNumber())
        return { swap: false, addLiquidity: true, removeLiquidity: true };
      return { swap: true, addLiquidity: true, removeLiquidity: true };
    } else
      return { swap: false, addLiquidity: false, removeLiquidity: false };
  }
  static includesToken(J, $) {
    const { baseMint: H, quoteMint: Q } = $;
    return J.mint.equals(H) || J.mint.equals(Q);
  }
  static _getTokenSide(J, $) {
    const { baseMint: H, quoteMint: Q } = $;
    if (J.mint.equals(H))
      return "base";
    else if (J.mint.equals(Q))
      return "quote";
    else
      return W0.throwArgumentError("token not match with pool", "params", { token: J.mint, baseMint: H, quoteMint: Q });
  }
  static _getTokensSide(J, $, H) {
    const { baseMint: Q, quoteMint: W } = H, Z = this._getTokenSide(J, H), Y = this._getTokenSide($, H);
    return W0.assertArgument(Z !== Y, "tokens not match with pool", "params", { tokenA: J.mint, tokenB: $.mint, baseMint: Q, quoteMint: W }), [Z, Y];
  }
  static _getAmountSide(J, $) {
    const H = J instanceof O0 ? J.token : r.WSOL;
    return this._getTokenSide(H, $);
  }
  static _getAmountsSide(J, $, H) {
    const Q = J instanceof O0 ? J.token : r.WSOL, W = $ instanceof O0 ? $.token : r.WSOL;
    return this._getTokensSide(Q, W, H);
  }
  static computeAnotherAmount({ poolKeys: J, poolInfo: $, amount: H, anotherCurrency: Q, slippage: W }) {
    const { baseReserve: Z, quoteReserve: Y } = $;
    W0.debug("baseReserve:", Z.toString()), W0.debug("quoteReserve:", Y.toString());
    const z = H instanceof O0 ? H.token : H.currency;
    W0.debug("currencyIn:", z), W0.debug("amount:", H.toFixed()), W0.debug("anotherCurrency:", Q), W0.debug("slippage:", `${W.toSignificant()}%`);
    const j = this._getAmountSide(H, J);
    W0.debug("input side:", j);
    let V = J0;
    if (!H.isZero())
      V = j === "base" ? aQ(H.raw.mul(Y), Z) : aQ(H.raw.mul(Z), Y);
    const U = aQ(H.raw.mul($.lpSupply), j === "base" ? $.baseReserve : $.quoteReserve), q = new uJ(k0).add(W).mul(V).quotient, K = Q instanceof r ? new O0(Q, V) : new r0(Q, V), w2 = Q instanceof r ? new O0(Q, q) : new r0(Q, q);
    return W0.debug("anotheAmount:", K.toFixed()), W0.debug("maxAnotheAmount:", w2.toFixed()), { anotherAmount: K, maxAnotherAmount: w2, liquidity: U };
  }
  static _computePriceImpact(J, $, H) {
    const Q = J.raw.mul($), W = Q.sub(H).div(Q);
    return new uJ(W.numerator, W.denominator);
  }
  static getRate(J) {
    const { baseReserve: $, quoteReserve: H, baseDecimals: Q, quoteDecimals: W } = J;
    return new PJ(new Y$(Q), $, new Y$(W), H);
  }
  static computeAmountIn({ poolKeys: J, poolInfo: $, amountOut: H, currencyIn: Q, slippage: W }) {
    const { baseReserve: Z, quoteReserve: Y } = $;
    W0.debug("baseReserve:", Z.toString()), W0.debug("quoteReserve:", Y.toString());
    const z = H instanceof O0 ? H.token : H.currency;
    W0.debug("currencyOut:", z), W0.debug("amountOut:", H.toFixed()), W0.debug("currencyIn:", Q), W0.debug("slippage:", `${W.toSignificant()}%`);
    const j = [Z, Y], V = this._getAmountSide(H, J);
    if (V === "base")
      j.reverse();
    W0.debug("output side:", V);
    const [U, C] = j, q = new PJ(Q, U, z, C);
    W0.debug("currentPrice:", `1 ${Q.symbol} \u2248 ${q.toFixed()} ${z.symbol}`), W0.debug("currentPrice invert:", `1 ${z.symbol} \u2248 ${q.invert().toFixed()} ${Q.symbol}`);
    let K = J0, w2 = H.raw;
    if (!w2.isZero()) {
      if (w2.gt(C))
        w2 = C.sub(k0);
      const g = C.sub(w2);
      K = U.mul(w2).div(g).mul(QW).div(QW.sub(nY));
    }
    const h2 = new uJ(k0).add(W).mul(K).quotient, b = Q instanceof r ? new O0(Q, K) : new r0(Q, K), N = Q instanceof r ? new O0(Q, h2) : new r0(Q, h2);
    W0.debug("amountIn:", b.toFixed()), W0.debug("maxAmountIn:", N.toFixed());
    let x = null;
    if (!K.isZero() && !w2.isZero())
      x = new PJ(Q, K, z, w2), W0.debug("executionPrice:", `1 ${Q.symbol} \u2248 ${x.toFixed()} ${z.symbol}`), W0.debug("executionPrice invert:", `1 ${z.symbol} \u2248 ${x.invert().toFixed()} ${Q.symbol}`);
    const k = this._computePriceImpact(q, K, w2);
    return W0.debug("priceImpact:", `${k.toSignificant()}%`), { amountIn: b, maxAmountIn: N, currentPrice: q, executionPrice: x, priceImpact: k };
  }
}
GQ = S$;
S$.computeAmountOut = ({ poolKeys: J, poolInfo: $, amountIn: H, currencyOut: Q, slippage: W }) => {
  const Z = H instanceof O0 ? H.token : r.WSOL, Y = Q instanceof r ? Q : r.WSOL;
  W0.assertArgument(GQ.includesToken(Z, J) && GQ.includesToken(Y, J), "token not match with pool", "poolKeys", { poolKeys: J, tokenIn: Z, tokenOut: Y });
  const { baseReserve: z, quoteReserve: j } = $;
  W0.debug("baseReserve:", z.toString()), W0.debug("quoteReserve:", j.toString());
  const V = H instanceof O0 ? H.token : H.currency;
  W0.debug("currencyIn:", V), W0.debug("amountIn:", H.toFixed()), W0.debug("currencyOut:", Q), W0.debug("slippage:", `${W.toSignificant()}%`);
  const U = [z, j], C = GQ._getAmountSide(H, J);
  if (C === "quote")
    U.reverse();
  W0.debug("input side:", C);
  const [q, K] = U;
  let w2;
  if (J.version === 4)
    w2 = new PJ(V, q, Q, K);
  else {
    const n = iY(FQ, z.toNumber(), j.toNumber(), false);
    if (C === "quote")
      w2 = new PJ(V, new TJ.default(n * 1e6), Q, new TJ.default(1e6));
    else
      w2 = new PJ(V, new TJ.default(1e6), Q, new TJ.default(n * 1e6));
  }
  W0.debug("currentPrice:", `1 ${V.symbol} \u2248 ${w2.toFixed()} ${Q.symbol}`), W0.debug("currentPrice invert:", `1 ${Q.symbol} \u2248 ${w2.invert().toFixed()} ${V.symbol}`);
  const O = H.raw;
  let h2 = J0, b = J0;
  if (!O.isZero())
    if (J.version === 4) {
      b = oH(O.mul(nY), QW);
      const n = O.sub(b), Z0 = q.add(n);
      h2 = K.mul(n).div(Z0);
    } else {
      b = O.mul(new TJ.default(2)).div(new TJ.default(1e4));
      const n = O.sub(b);
      if (C === "quote")
        h2 = new TJ.default(cY(FQ, j.toNumber(), z.toNumber(), n.toNumber()));
      else
        h2 = new TJ.default(sY(FQ, j.toNumber(), z.toNumber(), n.toNumber()));
    }
  const x = new uJ(k0).add(W).invert().mul(h2).quotient, k = Q instanceof r ? new O0(Q, h2) : new r0(Q, h2), g = Q instanceof r ? new O0(Q, x) : new r0(Q, x);
  W0.debug("amountOut:", k.toFixed()), W0.debug("minAmountOut:", g.toFixed());
  let A = new PJ(V, O.sub(b), Q, h2);
  if (!O.isZero() && !h2.isZero())
    A = new PJ(V, O.sub(b), Q, h2), W0.debug("executionPrice:", `1 ${V.symbol} \u2248 ${A.toFixed()} ${Q.symbol}`), W0.debug("executionPrice invert:", `1 ${Q.symbol} \u2248 ${A.invert().toFixed()} ${V.symbol}`);
  const I = A.denominator.mul(w2.numerator), T = A.numerator.mul(w2.denominator).sub(I).abs(), u = new uJ(T, I);
  W0.debug("priceImpact:", `${u.toSignificant()}%`);
  const a = V instanceof r ? new O0(V, b) : new r0(V, b);
  return { amountOut: k, minAmountOut: g, currentPrice: w2, executionPrice: A, priceImpact: u, fee: a };
};
var G5 = { SERUM_MARKET: new $PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"), OPENBOOK_MARKET: new $PublicKey("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"), UTIL1216: new $PublicKey("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"), FarmV3: new $PublicKey("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"), FarmV5: new $PublicKey("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"), FarmV6: new $PublicKey("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"), AmmV4: new $PublicKey("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"), AmmStable: new $PublicKey("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"), CLMM: new $PublicKey("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"), Router: new $PublicKey("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS") };
var F5 = { SERUM_MARKET: $PublicKey.default, OPENBOOK_MARKET: new $PublicKey("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"), UTIL1216: $PublicKey.default, FarmV3: new $PublicKey("85BFyr98MbCUU9MVTEgzx1nbhWACbJqLzho6zd6DZcWL"), FarmV5: new $PublicKey("EcLzTrNg9V7qhcdyXDe2qjtPkiGzDM2UbdRaeaadU5r2"), FarmV6: new $PublicKey("Farm2hJLcqPtPg8M4rR6DMrsRNc5TPm5Cs4bVQrMe2T7"), AmmV4: new $PublicKey("HWy1jotHpo6UqeQxx49dpYYdQB8wj9Qk9MdxwjLvDHB8"), AmmStable: new $PublicKey("DDg4VmQaJV9ogWce7LpcjBA9bv22wRp5uaTPa5pGjijF"), CLMM: new $PublicKey("devi51mZmdwUJGU9hjN27vEz64Gps7uUefqxg27EAtH"), Router: new $PublicKey("BVChZ3XFEwTMUk1o9i3HAf91H6mFxSwa5X2wFAWhYPhU") };
var Lj = E0(EJ(), 1);
var Kj = E0(EJ(), 1);
var hj = function(J = "accountFlags") {
  const $ = new S6(J);
  return $.addBoolean("initialized"), $.addBoolean("market"), $.addBoolean("openOrders"), $.addBoolean("requestQueue"), $.addBoolean("eventQueue"), $.addBoolean("bids"), $.addBoolean("asks"), $;
};
var s5 = e([p0(5), hj("accountFlags"), c("ownAddress"), P("vaultSignerNonce"), c("baseMint"), c("quoteMint"), c("baseVault"), P("baseDepositsTotal"), P("baseFeesAccrued"), c("quoteVault"), P("quoteDepositsTotal"), P("quoteFeesAccrued"), P("quoteDustThreshold"), c("requestQueue"), c("eventQueue"), c("bids"), c("asks"), P("baseLotSize"), P("quoteLotSize"), P("feeRateBps"), P("referrerRebatesAccrued"), p0(7)]);
var WW = E0(EJ(), 1);
var ZW;

class r$ extends V$ {
  static getPdaPoolId(J, $) {
    return h0([this.SEED_CONFIG.pool.id, $.toBuffer()], J);
  }
  static getPdaOwnerId(J, $, H, Q) {
    return h0([this.SEED_CONFIG.owner.id, $.toBuffer(), H.toBuffer(), Buffer.from(new WW.default(Q).toArray())], J);
  }
  static async getAllInfo({ connection: J, programId: $, poolIds: H, wallet: Q, chainTime: W }) {
    if (H.length === 0)
      return [];
    const Z = H.map((V) => this.getPdaPoolId($, V).publicKey), Y = [];
    for (let V = 0;V < this.VERSION_PROJECT.length; V++)
      Y.push(...Z.map((U) => this.getPdaOwnerId($, U, Q, V).publicKey));
    const z = await J$(J, [...Z, ...Y]), j = [];
    for (let V = 0;V < z.length; V++) {
      const U = Math.floor(V / H.length), C = V % H.length, q = Z[C], K = Y[V], w2 = z[C], O = z[H.length + V];
      if (!(w2 && O))
        continue;
      if (w2.data.length !== this.POOL_LAYOUT.span || O.data.length !== this.OWNER_LAYOUT.span)
        continue;
      const h2 = this.POOL_LAYOUT.decode(w2.data), b = this.OWNER_LAYOUT.decode(O.data), N = h2.openTime.toNumber(), x = h2.endTime.toNumber(), k = b.tokenInfo.map((I) => I.debtAmount.gt(new WW.default(0))).filter((I) => !I).length !== 3, g = W > N && W < x && h2.status === 1, A = k && g;
      j.push({ programId: $, poolId: q, ammId: h2.ammId, ownerAccountId: K, snapshotLpAmount: b.lpAmount, project: this.VERSION_PROJECT[U], openTime: N, endTime: x, canClaim: A, canClaimErrorType: !k ? "alreadyClaimIt" : !g ? "outOfOperationalTime" : undefined, tokenInfo: h2.tokenInfo.map((I, T) => ({ programId: m2, mintAddress: I.mintAddress, mintVault: I.mintVault, mintDecimals: I.mintDecimals, perLpLoss: I.perLpLoss, debtAmount: b.tokenInfo[T].debtAmount.add(b.tokenInfo[T].claimedAmount) })) });
    }
    return j;
  }
  static async makeClaimInstructionSimple({ connection: J, poolInfo: $, ownerInfo: H, makeTxVersion: Q, lookupTableCache: W }) {
    const Z = [], Y = [], z = [], j = [], V = [], U = [], C = [], q = [];
    for (let K of $.tokenInfo)
      q.push(await this._selectOrCreateTokenAccount({ programId: K.programId, mint: K.mintAddress, tokenAccounts: K.mintAddress.equals(r.WSOL.mint) ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.wallet, amount: 0, frontInstructions: Z, endInstructions: K.mintAddress.equals(r.WSOL.mint) ? z : [], frontInstructionsType: Y, endInstructionsType: j, signers: C }, associatedOnly: K.mintAddress.equals(r.WSOL.mint) ? false : H.associatedOnly, checkCreateATAOwner: H.checkCreateATAOwner }));
    return V.push(this.makeClaimInstruction({ programId: $.programId, poolInfo: $, ownerInfo: { wallet: H.wallet, ownerPda: $.ownerAccountId, claimAddress: q } })), U.push($0.util1216OwnerClaim), { address: {}, innerTransactions: await L0({ connection: J, makeTxVersion: Q, computeBudgetConfig: undefined, payer: H.wallet, innerTransaction: [{ instructionTypes: Y, instructions: Z, signers: C }, { instructionTypes: U, instructions: V, signers: [] }, { instructionTypes: j, instructions: z, signers: [] }], lookupTableCache: W }) };
  }
  static async makeClaimAllInstructionSimple({ connection: J, poolInfos: $, ownerInfo: H, makeTxVersion: Q, lookupTableCache: W }) {
    const Z = [], Y = [], z = [], j = [], V = [], U = [], C = [], q = {};
    for (let K of $) {
      const w2 = [];
      for (let O of K.tokenInfo) {
        const h2 = q[O.mintAddress.toString()] ?? await this._selectOrCreateTokenAccount({ programId: O.programId, mint: O.mintAddress, tokenAccounts: O.mintAddress.equals(r.WSOL.mint) ? [] : H.tokenAccounts, owner: H.wallet, createInfo: { connection: J, payer: H.wallet, amount: 0, frontInstructions: Z, endInstructions: O.mintAddress.equals(r.WSOL.mint) ? z : [], frontInstructionsType: Y, endInstructionsType: j, signers: C }, associatedOnly: O.mintAddress.equals(r.WSOL.mint) ? false : H.associatedOnly, checkCreateATAOwner: H.checkCreateATAOwner });
        q[O.mintAddress.toString()] = h2, w2.push(h2);
      }
      V.push(this.makeClaimInstruction({ programId: K.programId, poolInfo: K, ownerInfo: { wallet: H.wallet, ownerPda: K.ownerAccountId, claimAddress: w2 } })), U.push($0.util1216OwnerClaim);
    }
    return { address: {}, innerTransactions: await L0({ connection: J, makeTxVersion: Q, computeBudgetConfig: undefined, payer: H.wallet, innerTransaction: [{ instructionTypes: Y, instructions: Z, signers: C }, { instructionTypes: U, instructions: V, signers: [] }, { instructionTypes: j, instructions: z, signers: [] }], lookupTableCache: W }) };
  }
  static makeClaimInstruction({ programId: J, poolInfo: $, ownerInfo: H }) {
    const Q = e([]), W = [{ pubkey: H.wallet, isSigner: true, isWritable: true }, { pubkey: $.poolId, isSigner: false, isWritable: true }, { pubkey: H.ownerPda, isSigner: false, isWritable: true }, ...H.claimAddress.map((z) => ({ pubkey: z, isSigner: false, isWritable: true })), ...$.tokenInfo.map(({ mintVault: z }) => ({ pubkey: z, isSigner: false, isWritable: true })), { pubkey: m2, isSigner: false, isWritable: false }], Z = Buffer.alloc(Q.span);
    Q.encode({}, Z);
    const Y = Buffer.from([10, 66, 208, 184, 161, 6, 191, 98, ...Z]);
    return new $TransactionInstruction({ keys: W, programId: J, data: Y });
  }
}
ZW = r$;
r$.CLAIMED_NUM = 3;
r$.POOL_LAYOUT = e([p0(8), o("bump"), o("status"), P("openTime"), P("endTime"), c("ammId"), z0(e([o("mintDecimals"), c("mintAddress"), c("mintVault"), P("perLpLoss"), P("totalClaimedAmount")]), ZW.CLAIMED_NUM, "tokenInfo"), z0(P(), 10, "padding")]);
r$.OWNER_LAYOUT = e([p0(8), o("bump"), o("version"), c("poolId"), c("owner"), P("lpAmount"), z0(e([c("mintAddress"), P("debtAmount"), P("claimedAmount")]), ZW.CLAIMED_NUM, "tokenInfo"), z0(P(), 4, "padding")]);
r$.DEFAULT_POOL_ID = ["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", "6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg", "AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA", "DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut", "7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX", "6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj", "EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb", "AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P", "6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map((J) => new $PublicKey(J));
r$.SEED_CONFIG = { pool: { id: Buffer.from("pool_seed", "utf8") }, owner: { id: Buffer.from("user_claim_seed", "utf8") } };
r$.VERSION_PROJECT = [undefined, "Francium", "Tulip", "Larix"];
var eY = { id: "73hB2xN1R7Q47xyTBzQJMRMDvjGjetBc6AaDvYaE85hD", baseMint: "AmghZTmRCWooJS8wHodqGcZnLzvxgsdegmF3GCTb7YQw", quoteMint: "So11111111111111111111111111111111111111112", lpMint: "AxQ1wYZqkfBvoRyaMby1gLs2xwxc2dv6YXJ2vyHfXKW7", baseDecimals: 8, quoteDecimals: 9, lpDecimals: 8, version: 4, programId: "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8", authority: "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1", openOrders: "CBJYgSfKLu81VrxzKU9MNJ1PXuoXp4fDUGmwEszS9PUA", targetOrders: "69pr6RJeoqCCt3eqbUM4mCCA38awL9etaSsjgxRu3PMH", baseVault: "9hQmiGtVJLUQLfRVyraDRBroZyVFR4qz6Jym5LNyWZji", quoteVault: "AcjfNpuWboWv32mUfTyhQBvqiSqDuL5GBrRw3roX1nA5", withdrawQueue: "11111111111111111111111111111111", lpVault: "11111111111111111111111111111111", marketVersion: 4, marketProgramId: "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX", marketId: "D6Xh8GK9u8B8cYNLiCwiiLaPFrj3aSxc4XodVxebNtbv", marketAuthority: "7EDQCDrgLw6utkCabGcjBCcziLqb1S6UF7DABceGBVad", marketBaseVault: "5uiyywWfSS1BZnS87gHu3ad3VrAUa719bKkgTcCnaxxJ", marketQuoteVault: "EbLcv9Up4hy49FXfXuJiGLHjLV7iqS78goYv2EuS77FN", marketBids: "3WaYqHbXAAdAjjpW5SZ9D4Tkai1Qyy5gnFmtT4c1LDvS", marketAsks: "6h9qh3aCPzgLTawXP3gJ8tnnZt5K3mLwGMMy696sqtoT", marketEventQueue: "ADNssU3T9MUsDbsrE6jSqwb1qJV1JXYh9vnDNtTahigP", lookupTableAccount: "J3WPh5nvxYDucBgw1n9HvJXwsJDcZwZMtyWPHbnpWXYQ" };
var XQ = wH(eY);
// src/bot/index.ts
var import_bs58 = __toESM(require_bs583(), 1);
var import_dotenv = __toESM(require_main(), 1);
import_dotenv.config();
var payer = $Keypair.fromSecretKey(import_bs58.default.decode(String(process.env.WALLET_SECRET_KEY)));
if (!payer)
  throw new Error("WALLET_SECRET_KEY error please check before using.");

class SwapBot {
  scriptExecuted = 0;
  totalOrdersPlaced = 0;
  BUY_ORDER_AMOUNT;
  BUY_ORDER_NO;
  SELL_ORDER_AMOUNT;
  SELL_ORDER_NO;
  ORDER_INTERVAL;
  REPEAR_STEP;
  connection = new $Connection($clusterApiUrl("mainnet-beta"));
  payer = payer;
  constructor() {
    this.BUY_ORDER_AMOUNT = process.env.BUY_ORDER_AMOUNT;
    this.BUY_ORDER_NO = process.env.BUY_ORDER_NO;
    this.SELL_ORDER_AMOUNT = process.env.SELL_ORDER_AMOUNT;
    this.SELL_ORDER_NO = process.env.SELL_ORDER_NO;
    this.ORDER_INTERVAL = process.env.ORDER_INTERVAL;
    this.REPEAR_STEP = process.env.REPEAR_STEP;
  }
  async sleep(time) {
    console.log("sleeping:", time, "ms");
    return new Promise((rs) => {
      setTimeout(rs, time);
    });
  }
  interleaveArrays(arr1, arr2) {
    const result = [];
    for (let i = 0;i < Math.max(arr1.length, arr2.length); i++) {
      if (i < arr1.length) {
        result.push(arr1[i]);
      }
      if (i < arr2.length) {
        result.push(arr2[i]);
      }
    }
    return result;
  }
  getShuffledOrders() {
    const buys = Array.from(Array(Number(this.BUY_ORDER_NO))).map((_) => "buy");
    const sells = Array.from(Array(Number(this.SELL_ORDER_NO))).map((_) => "sell");
    const shuffle = this.interleaveArrays(buys, sells);
    return shuffle;
  }
  async createBuyorder() {
    console.log("Creating buy order for", this.totalOrdersPlaced);
    const resp = await x7(this.connection, payer, Number(this.BUY_ORDER_AMOUNT), "in");
    console.log("buy order created:", resp);
  }
  async createSellOrder() {
    console.log("Creating sell order for", this.totalOrdersPlaced);
    const resp = await x7(this.connection, payer, Number(this.SELL_ORDER_AMOUNT) / Number(this.SELL_ORDER_NO), "out");
    console.log("sell order created:", resp);
  }
  async startProcess() {
    if (this.scriptExecuted >= Number(this.REPEAR_STEP)) {
      console.log("script executed:", this.scriptExecuted, "times");
      return;
    }
    const orders = this.getShuffledOrders();
    for (const direction of orders) {
      this.totalOrdersPlaced += 1;
      if (direction === "buy")
        await this.createBuyorder();
      else if (direction === "sell")
        await this.createSellOrder();
      await this.sleep(Number(this.ORDER_INTERVAL));
    }
    this.scriptExecuted += 1;
    await this.startProcess();
  }
}
export {
  SwapBot
};
